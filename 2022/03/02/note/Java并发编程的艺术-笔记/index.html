<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangfx.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="并发编程的艺术">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程的艺术-读书笔记">
<meta property="og:url" content="http://wangfx.top/2022/03/02/note/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="qGuang">
<meta property="og:description" content="并发编程的艺术">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406221211.png">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407212754.png">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407212920.png">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407203140.jpg">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407200109.png">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407205722.png">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407215123.png">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407215809.png">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407220233.png">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409130536.jpeg">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409130649.jpeg">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409132659.jpeg">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409133303.png">
<meta property="og:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409133555.jpeg">
<meta property="article:published_time" content="2022-03-02T13:59:04.000Z">
<meta property="article:modified_time" content="2022-07-16T14:44:15.686Z">
<meta property="article:author" content="qianguang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406221211.png">

<link rel="canonical" href="http://wangfx.top/2022/03/02/note/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>并发编程的艺术-读书笔记 | qGuang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">qGuang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">简简单单，安安静静</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangfx.top/2022/03/02/note/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianguang">
      <meta itemprop="description" content="浅光的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qGuang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          并发编程的艺术-读书笔记
        </h1>

        <div class="post-meta">
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-02 21:59:04" itemprop="dateCreated datePublished" datetime="2022-03-02T21:59:04+08:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-16 22:44:15" itemprop="dateModified" datetime="2022-07-16T22:44:15+08:00">2022-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web后端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%90%8E%E7%AB%AF/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          
            <div class="post-description">并发编程的艺术</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="并发编程的艺术"><a href="#并发编程的艺术" class="headerlink" title="并发编程的艺术"></a>并发编程的艺术</h1><h2 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1 volatile"></a>1 volatile</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">汇编角度lock+操作系统角度分析原理</span><br><span class="line">保证可见性，不保证原子性，从JMM内存模型的角度分析</span><br><span class="line">禁止指令重排</span><br><span class="line">优化，volatile修饰的变量追加到64字节，从操作系统角度分析，高速缓存行的长度为64位，每次读取会锁定当前的高速缓存行</span><br></pre></td></tr></table></figure>

<p>（1）关键字volatile是Java虚拟机提供的最轻量级的同步机制，它的执行成本更低<br>（2）如何保证可见性？<br>    关键字volatile可以用来修饰字段（成员变量），也就是告诉程序任何对该变量的访问都需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量的可见性</p>
<p>​	不妨从汇编码角度看看volatile修饰之后发生了什么？我们知道Java代码被编译器编译生成字节码，字节码被类加载器加载到JVM里，JVM执行字节码转换成汇编指令在CPU上运行，比方说下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance = new instance();   instance有volatile修饰，转换成汇编码</span><br><span class="line">=&gt; lock add $0*0(%esp)</span><br></pre></td></tr></table></figure>

<p>​		转换成汇编码可以看到，JVM会向处理器发送前缀是lock的指令，这个变量所在的缓存行的数据写入主内存，其他处理器会通过嗅探在总线传来的数据，判断自己的缓存值是否过期（当我们写入主内存后，其他处理器的缓存失效），当处理器对这个数据修改的时候，会重新从系统内存读取数据到处理器的缓存<br>​		总结来说，加上volatile前缀主要实现了，lock前缀指令会让处理器缓存写回主内存；一个处理器缓存写回主内存会让其他处理器缓存失效；保证了所有线程对volatile修饰变量的可见性</p>
<p>（3）volatile的优化<br>jdk7的并发包增加了一个队列集合类，会自动将volatile修饰的变量追加到64位<br>因为英特尔i7处理器的高速缓存行是64字节带宽，不支持部分填充缓存行，如果队列的头尾结点不足64个字节，那么处理器会读到同一个缓存行里，当一个处理器试图修改缓存行的时候，会将整个缓存行锁定，那么其他处理器此时不能访问缓存行的尾部结点！</p>
<p>（4）volatile的读和写的内存语义<br>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新回主内存<br>当读一个volatile变量时，JMM会把该线程的本地内存设置为无效，从主内存中读取共享变量</p>
<p>问：你在哪些地方使用volatile?<br>答：多线程的单例模式情况下</p>
<h2 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2 synchronized"></a>2 synchronized</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">汇编角度monitor监视器的获取，moitorenter和moitorexit，monitor的获取是排他性的，分析原理</span><br><span class="line">Java对象头，synchronized用的锁是存在Java头中的</span><br></pre></td></tr></table></figure>

<p>（1）synchronized在并发编程的时候也广泛使用，很多人称作是重量级锁。但其实从java SE1.6对synchronized进行优化后，已经不是很重了。为减少获取锁和释放锁带来的性能开销，引入了偏向锁和轻量级锁。<br>（2）底层实现：<br>    synchronized基于进入和退出monitor对象实现同步，monitor enter指令插入在同步代码块开始的位置，monitor exit插入在同步代码块结束或者发生异常的位置。任何一个对象都要有一个montor对象相关联，当一个monitor被持有的时候，就处在锁定状态。当线程执行到monitor enter的时候，就尝试获取monitor的所有权，即尝试获取锁，当运行到monitor exit就释放锁。<br>    synchronized的锁一般存在Java对象头中<br>    关键字synchronized保证线程对变量访问的可见性和排他性</p>
<h2 id="3-锁"><a href="#3-锁" class="headerlink" title="3 锁"></a>3 锁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无锁、偏向锁、轻量级锁、重量级锁、可重入锁、读写锁</span><br><span class="line">每个锁的概念，实现方法，获取每个锁的方法</span><br></pre></td></tr></table></figure>

<p>在Java SE1.6的时候，锁一共有4个状态，从低到高是无锁状态，偏向锁状态，轻量锁状态和重量锁状态</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406221211.png" alt="image-20210406221211482" style="zoom:50%;" />

<p>（1）偏向锁<br>    研究的时候发现，大多数情况下都不存在锁的竞争，锁总是由同一个线程多次获得，为了让线程以更低的代价获得锁，引入了偏向锁的概念。<br>    当一个线程获取到锁的时候，会在对象头里面写入锁偏向的线程ID，以后该线程进入和退出同步块的时候不需要CAS操作来进行加锁和解锁，只需要简单的看一下对象头是否存储了指向当前线程的偏向锁。测试成功，表明获得了偏向锁；测试失败，查看当前是否是偏向锁。如果是偏向锁，那么CAS将对象头的偏向锁指向当前线程，如果不是，那么CAS竞争锁<br>    偏向锁使用了一种等待竞争出现才释放锁的方法<br>（2）轻量级锁<br>    使用轻量级锁时，不需要申请互斥量，仅仅将对象头中的Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁<br>    轻量级解锁的时候，会用cas操作将mark word的部分字节替换回对象头，如果成功，表明没有竞争，如果失败，表示当前存在竞争。导致锁膨胀，升级为重量级锁<br>（3）重量级锁<br>锁被持有时，其他线程进行等待</p>
<h2 id="4-AQS"><a href="#4-AQS" class="headerlink" title="4 AQS"></a>4 AQS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以参考《并发编程的艺术》P121</span><br><span class="line">Java同步器框架，可以构建锁和其他同步组件的基础框架</span><br><span class="line">同步组件ReentrantLock、CountDownLatch、ReentrantReadWriteLock实现都依赖于AQS</span><br><span class="line">实现机制：volatile修饰的state+FIFO队列</span><br></pre></td></tr></table></figure>

<p>问：什么是AQS？<br>答：AQS是队列同步器，这个类在java.util.concurrent.locks包下面。AQS是一个用来构建锁和同步器的框架，比如ReentrantLock，Semaphore，SynchronousQueue等等皆是基于AQS的。</p>
<p>问：AQS的核心思想是什么？它是怎么实现的？<br><strong>答：AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong> AQS使用一个voliate int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。<strong>AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</strong></p>
<p>​	AQS定义了两种资源获取方式：独占（只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如ReentrantLock） 和共享（多个线程可同时访问执行，如Semaphore&#x2F;CountDownLatch，Semaphore、CountDownLatCh、 CyclicBarrier ）。ReentrantReadWriteLock 可以看成是组合式，允许多个线程同时对某一资源进行读。</p>
<p>​	AQS底层使用了模板方法模式， 自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在上层已经帮我们实现好了。</p>
<p>问：AQS独占式同步状态的获取和释放｜同步队列FIFO?<br>答：图中画虚线的结点在通过循环CAS去获取同步状态state(volatile)</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407212754.png" alt="image-20210407212754756" style="zoom:50%;" />

<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407212920.png" alt="image-20210407212919973" style="zoom: 33%;" />

<p>​	分析了独占式同步状态获取和释放过程后，适当做个总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用 tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。</p>
<h2 id="5-CAS"><a href="#5-CAS" class="headerlink" title="5 CAS"></a>5 CAS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">compare and swap</span><br><span class="line">除了偏向锁，其他锁的实现方法都采用了CAS</span><br><span class="line">CAS是一种基于锁的操作，而且是乐观锁。</span><br><span class="line">CAS的三个问题+解决方式</span><br><span class="line">	ABA问题=》版本号；</span><br><span class="line">	长时间自旋CAS，消耗资源=》引入pause机制；</span><br><span class="line">	只能保证一个共享变量的院子操作=》封装对象</span><br></pre></td></tr></table></figure>

<p>（1）CAS：cas需要两个数值，一个是改变前的旧值，一个是希望改变后的新值，在操作期间比较旧值有没有发生变化，如果没有发生变化，才变换成新值，否则不发生改变<br>（2）ABA问题：通过加上版本号，比方说现在A-&gt;B-&gt;A,那么我们可以加上版本号，变化成1A-&gt;2B-&gt;3A<br>        只能保证一个共享变量的院子操作，JDK提供了AtomicReference，就可以把多个变量放在一个对象里面，保证原子性</p>
<h2 id="6-JUC"><a href="#6-JUC" class="headerlink" title="6 JUC"></a>6 JUC</h2><p>JUC全称：java.util.concurrent，是JDK提供的一个处理并发的工具包。</p>
<p>atomic包里面存放的是支持原子操作的、处理基本数据类型的类。该包下大量使用到了CAS技术</p>
<p>locks里面存放的是实现处理并发的类。该包下大量使用到了AQS技术</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407203140.jpg" alt="preview"></p>
<h2 id="7-死锁问题"><a href="#7-死锁问题" class="headerlink" title="7 死锁问题"></a>7 死锁问题</h2><p>（1）所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局。<br>（2）产生的原因：<br>互斥使用：所占有的资源具有排他性控制，同一时刻只能给一个进程使用<br>不可剥夺：进程获得的资源不可以强行被剥夺<br>占有和保持：进程获取其他资源获取不到，并不会释放自己占有的资源<br>循环等待：发生死锁的时候，必然会形成一个循环等待的环形链<br>（3）如何防止死锁：<br>    首先写代码前，对于并发的编程，强烈建议使用JDK并发包提供的并发容器和工具类，因为这些都是经过充分优化<br>    当形成了死锁，我们就破坏死锁形成的条件，比如一个进程获得的资源可以强行的进行剥夺；一个进程必须获得了全部的资源，才可以占用资源；<br>    我在看《MySQL技术内幕-深入理解InnoDB引擎》这本书的时候，看到关于解决数据库死锁的方案。一个是设置等待超时的时间限制；一个是在innodb引擎中发生死锁，会有形成一个等待图，innodb存储引擎就是用这个方式进行死锁检测。innodb存储引擎选择回滚undo量最小的事务来解决死锁问题。</p>
<h2 id="8-Java如何实现原子操作"><a href="#8-Java如何实现原子操作" class="headerlink" title="8 Java如何实现原子操作"></a>8 Java如何实现原子操作</h2><p>在Java中，可以通过锁或者循环CAS来实现原子操作；Java提供了一些支持院子操作的类，AtomicBoolean,AtomicInteger,AtomicLong等等</p>
<h2 id="9-Java内存模型"><a href="#9-Java内存模型" class="headerlink" title="9 Java内存模型"></a>9 Java内存模型</h2><p>问：解释一下JMM<br>答：首先JMM本身就是一个抽象的概念，本身并不存在。由于JVM运行的实体时线程，每个线程创建时JVM都会为他创建一个工作内存，工作内存时每个线程的私有空间，而Java内存模型中规定的所有变量都存储在主内存，主内存是共享区域，所有线程都可以访问。<br>如果一个线程A要和线程B通信的话，需要进行下面的操作：<br>1 线程A把本地内存的A中更新过的共享变量刷新到主内存中<br>2 线程B从主内存中读取线程A之前更新过的数据</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407200109.png" alt="image-20210407200109037" style="zoom: 33%;" />

<p>（1）happens-before<br>在JMM中，如果一个操作要对另一个操作可见，那么两个操作就必须要有happens-before的关系。<br>happens-before并不要求前一个操作必须在后一个操作之前执行！仅要求前一个操作对后一个操作可见，且前一个操作的执行顺序在后一个操作之前。</p>
<p>（2）重排序<br>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p>
<h2 id="10-可重入锁｜递归锁"><a href="#10-可重入锁｜递归锁" class="headerlink" title="10 可重入锁｜递归锁"></a>10 可重入锁｜递归锁</h2><p>可重入锁是指同一个线程可以多次获取同一把锁。除此之外，还可以选择设置为公平锁或者是非公平锁<br>默认情况下是非公平锁；非公平锁虽然可能导致线程的“饥饿“，但是可以进行较少的线程切换，保证了较大的吞吐量</p>
<p>实现原理：volatile 变量 + CAS设置值 + AQS，ReentrantLock锁的实现步骤总结为三点</p>
<pre><code> 1、未竞争到锁的线程将会被CAS为一个链表结构并且被挂起。
 2、竞争到锁的线程执行完后释放锁并且将唤醒链表中的下一个节点。
 3、被唤醒的节点将从被挂起的地方继续执行逻辑
</code></pre>
<p><strong>【AQS】</strong></p>
<p>是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。AQS解决了在实现同步容器时设计的大量细节问题。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407205722.png" alt="img" style="zoom: 50%;" />

<p>AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus</p>
<p>ReentrantLock的基本实现可以概括为：先通过CAS尝试获取锁。如果此时已经有线程占据了锁，那就加入AQS队列并且被挂起。当锁被释放之后，排在CLH队列（CLH同步队列是一个FIFO双向队列）队首的线程会被唤醒，然后CAS再次尝试获取锁。在这个时候，如果：</p>
<p>非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；<br>公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁。</p>
<h2 id="11-自旋锁"><a href="#11-自旋锁" class="headerlink" title="11 自旋锁"></a>11 自旋锁</h2><p>尝试获取锁的进程不会发生阻塞，而是采用循环的方式去获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p>
<h2 id="12-读写锁"><a href="#12-读写锁" class="headerlink" title="12 读写锁"></a>12 读写锁</h2><p>之前提到的mutex或者是reentrantlock都是排他性锁，同一时刻只能一个线程进行访问。读写锁同一时刻可以支持多个读线程访问，但是写线程访问的时候，所有的读线程和其他写线程均被阻塞。</p>
<p>问：读写锁的设计，如何在一个整型变量上维护多个状态？</p>
<p>​		读写锁的设计同样依赖于AQS，而读写锁的状态就是同步器的同步状态。那么如何在一个整型变量上维护多个状态呢，我们采用“按位切割使用”这个变量，这个变量的高16位表示读，低16位表示写。</p>
<p>​		<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407215123.png" alt="image-20210407215123394" style="zoom:50%;" /></p>
<h2 id="13-ThreadLocal"><a href="#13-ThreadLocal" class="headerlink" title="13 ThreadLocal"></a>13 ThreadLocal</h2><p>ThreadLocal是线程变量，是一个以ThreadLocal对象为键，任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值</p>
<h2 id="14-condition"><a href="#14-condition" class="headerlink" title="14 condition"></a>14 condition</h2><p>condition对象是依赖于lock对象创建出来的，换句话说，condition对象是依赖lock对象的。<br>获取一个condition，必须通过lock的new condition()方法</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407215809.png" alt="image-20210407215809575" style="zoom:50%;" />

<p>每一个结点都是线程获取同步信息失败的话，将这个线程的信息封装成一个结点<br>关于condition的signal()方法，进行通知操作：<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407220233.png" alt="image-20210407220233494" style="zoom:50%;" /></p>
<h2 id="15-HashMap"><a href="#15-HashMap" class="headerlink" title="15 HashMap"></a>15 HashMap</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>注意看美团的文章，已经打印出来了！<br>(1)在并发编程的过程中，使用HashMap可能导致死循环，而使用线程安全的HashTable的效率比较低下，因此我们使用ConcurrentHashMap.<br>(2)hashTable，在任意时刻只能一个线程写HashTable，并发量不如ConcurrentHashMap</p>
<p>在JDK1.7的时候</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409130536.jpeg" alt="640?wx_fmt=jpeg" style="zoom: 67%;" />

<p>在JDK1.8的时候，当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低。因此 1.8 中重点优化了这个查询效率。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409130649.jpeg" alt="640?wx_fmt=png" style="zoom:67%;" />

<h2 id="concurrentHashMap"><a href="#concurrentHashMap" class="headerlink" title="concurrentHashMap"></a>concurrentHashMap</h2><p>（1）JDK1.7之前</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409132659.jpeg" alt="640?wx_fmt=png"></p>
<p>​	是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。<br>​	原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409133303.png" alt="image-20210409133303333" style="zoom:50%;" />

<p>再结合图看看 put 的流程。</p>
<ol>
<li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li>
<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li>
<li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>
<li>最后会解除在 1 中所获取当前 Segment 的锁。</li>
</ol>
<p>（2）JDK1.8，移除 Segment，使锁的粒度更小，Synchronized + CAS</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409133555.jpeg" alt="640?wx_fmt=png" style="zoom: 67%;" />

<p>(3)总结：<br>    JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）<br>    JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了<br>    JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档<br>    JDK1.8为什么使用内置锁synchronized来代替重入锁ReentrantLock，我觉得有以下几点<br>    因为粒度降低了，在相对而言的低粒度加锁方式，synchronized并不比ReentrantLock差，在粗粒度加锁中ReentrantLock可能通过	Condition来控制各个低粒度的边界，更加的灵活，而在低粒度中，Condition的优势就没有了<br>JVM的开发团队从来都没有放弃synchronized，而且基于JVM的synchronized优化空间更大，使用内嵌的关键字比使用API更加自然<br>在大量的数据操作下，对于JVM的内存压力，基于API的ReentrantLock会开销更多的内存，虽然不是瓶颈，但是也是一个选择依据</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>谈谈你理解的 HashMap，讲讲其中的 get put 过程。</p>
</li>
<li><p>1.8 做了什么优化？</p>
</li>
<li><p>是线程安全的嘛？</p>
</li>
<li><p>不安全会导致哪些问题？</p>
</li>
<li><p>如何解决？有没有线程安全的并发容器？</p>
</li>
<li><p>ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？</p>
</li>
<li><p>table的默认长度为什么是16？负载因此为什么默认是0.75？为什么table的长度一定要是2的n次方？</p>
<p>答：（1）首先说明table的长度为什么是2的n次方。通常情况下在设计桶的大小的时候会设计为素数，因为素数发生冲突的概率要小于合数，在HashTable的长度就被设计为11，那么为什么HashMap的长度采用非常规的设计呢。因为计算hash操作的时候，我们设计到取模的运算，实际上如果length的长度是2的n次方，那么n&amp;(length-1) &#x3D; n%length，计算机计算位运算的速度要远远快于取模的运算；此外，在扩容阶段，设计为2的n次方也比较有优势，不需要重新计算Hash，只需要看hash值新增的那个bit是0还是1就可以了，是0的话不需要改变，是1的话，新的位置就是原索引+原来hashmap的容量<br>（2）如果长度是2的n次方，为什么是16？可能是为了降低hash碰撞的几率<br>（3）负载因此为什么0.75呢，这个设计是综合考虑了空间效率和时空效率的平衡，也可以自己根据业务场景进行一些调整。比如说内存空间很多，要求时间比较快，那么我们可以降低负载因子</p>
</li>
</ol>
<h2 id="16-守护线程"><a href="#16-守护线程" class="headerlink" title="16 守护线程"></a>16 守护线程</h2><p>当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。</p>
<h2 id="17-协程"><a href="#17-协程" class="headerlink" title="17 协程"></a>17 协程</h2><p>展开了史无前例的大促销，你们的用户开始爆炸增长，这时候有10000人同时在线付款，你打算启动10000个线程来处理任务。等等，问题来了，因为每个线程至少会占用4M的内存空间，10000个线程会消耗39G的内存，而服务器的内存配置只有区区8G，这时候你有2种选择，一是选择增加服务器，二是选择提高代码效率。那么是否有方法能够提高效率呢？</p>
<p>我们知道操作系统在线程等待IO的时候，会阻塞当前线程，切换到其它线程，这样在当前线程等待IO的过程中，其它线程可以继续执行。当系统线程较少的时候没有什么问题，但是当线程数量非常多的时候，却产生了问题。<strong>一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。</strong></p>
<p>协程刚好可以解决上述2个问题。协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</p>
<p>回到上面的问题，我们只需要启动100个线程，每个线程上运行100个协程，这样不仅减少了线程切换开销，而且还能够同时处理10000个读取数据库的任务，很好的解决了上述任务。</p>
<h2 id="18-原子类"><a href="#18-原子类" class="headerlink" title="18 原子类"></a>18 原子类</h2><p>Java.util.concurrent.atomic包下定义了原子操作类，总共有13个<br>AutomicInteger、AutomicBoolean、AutomicLong等等</p>
<h2 id="19-线程安全的并发容器"><a href="#19-线程安全的并发容器" class="headerlink" title="19 线程安全的并发容器"></a>19 线程安全的并发容器</h2><h2 id="20-并发工具类"><a href="#20-并发工具类" class="headerlink" title="20 并发工具类"></a>20 并发工具类</h2><h3 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h3><p>等待多线程完成，允许一个或者多个线程等待其他线程完成操作<br>countdownLatch的构造函数接受一个int类型的参数作为计数器，如果你想等待N个点，就传入N</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>内存屏障，让一组线程到达一个屏障后被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行 ，相比countdownLatch，可以用在更加复杂的业务场景</p>
<h3 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h3><p>信号量用来控制同时访问特定资源的的进程数量</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h4 id="红黑树定义和性质"><a href="#红黑树定义和性质" class="headerlink" title="红黑树定义和性质"></a>红黑树定义和性质</h4><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p>
<ul>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：根节点是黑色。</li>
<li>性质3：每个叶子节点（NIL）是黑色。</li>
<li>性质4：每个红色结点的两个子结点一定都是黑色。</li>
<li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/27/show/%E7%88%B1%E5%A5%87%E8%89%BA%E5%AE%9E%E4%B9%A0/" rel="prev" title="爱奇艺实习">
      <i class="fa fa-chevron-left"></i> 爱奇艺实习
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/29/show/community/" rel="next" title="社区论坛项目">
      社区论坛项目 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF"><span class="nav-number">1.</span> <span class="nav-text">并发编程的艺术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-volatile"><span class="nav-number">1.1.</span> <span class="nav-text">1 volatile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-synchronized"><span class="nav-number">1.2.</span> <span class="nav-text">2 synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%94%81"><span class="nav-number">1.3.</span> <span class="nav-text">3 锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-AQS"><span class="nav-number">1.4.</span> <span class="nav-text">4 AQS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-CAS"><span class="nav-number">1.5.</span> <span class="nav-text">5 CAS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-JUC"><span class="nav-number">1.6.</span> <span class="nav-text">6 JUC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.</span> <span class="nav-text">7 死锁问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.</span> <span class="nav-text">8 Java如何实现原子操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.9.</span> <span class="nav-text">9 Java内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BD%9C%E9%80%92%E5%BD%92%E9%94%81"><span class="nav-number">1.10.</span> <span class="nav-text">10 可重入锁｜递归锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">1.11.</span> <span class="nav-text">11 自旋锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">1.12.</span> <span class="nav-text">12 读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-ThreadLocal"><span class="nav-number">1.13.</span> <span class="nav-text">13 ThreadLocal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-condition"><span class="nav-number">1.14.</span> <span class="nav-text">14 condition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-HashMap"><span class="nav-number">1.15.</span> <span class="nav-text">15 HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">1.15.1.</span> <span class="nav-text">HashMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#concurrentHashMap"><span class="nav-number">1.16.</span> <span class="nav-text">concurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">1.16.1.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.17.</span> <span class="nav-text">16 守护线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E5%8D%8F%E7%A8%8B"><span class="nav-number">1.18.</span> <span class="nav-text">17 协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">1.19.</span> <span class="nav-text">18 原子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="nav-number">1.20.</span> <span class="nav-text">19 线程安全的并发容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.21.</span> <span class="nav-text">20 并发工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CountdownLatch"><span class="nav-number">1.21.1.</span> <span class="nav-text">CountdownLatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">1.21.2.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#semaphore"><span class="nav-number">1.21.3.</span> <span class="nav-text">semaphore</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">1.22.</span> <span class="nav-text">红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8"><span class="nav-number">1.22.0.1.</span> <span class="nav-text">红黑树定义和性质</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">qianguang</p>
  <div class="site-description" itemprop="description">浅光的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qianguang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='34,34,34' opacity='0.5' zIndex='-1' count='120' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
