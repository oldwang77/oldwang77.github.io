<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>广告推广系统</title>
    <url>/2022/04/07/show/ad-springcloud/</url>
    <content><![CDATA[<h1 id="ad-springcloud"><a href="#ad-springcloud" class="headerlink" title="ad-springcloud"></a>ad-springcloud</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在《<strong>美团广告实时索引的设计与实现</strong>》中写道，在线广告是互联网行业常见的商业变现方式。从工程角度看，广告索引的结构和实现方式直接决定了整个系统的服务性能。</p>
<span id="more"></span>

<h2 id="领域问题"><a href="#领域问题" class="headerlink" title="领域问题"></a>领域问题</h2><p>广告索引需具备以下基本特性：<strong>层次化的索引结构 + 实时化的索引更新</strong>。</p>
<h3 id="层次化的索引结构"><a href="#层次化的索引结构" class="headerlink" title="层次化的索引结构"></a>层次化的索引结构</h3><p>一般地，广告系统可抽象为如下投放模型，并实现检索、过滤等处理逻辑。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220314145817.png" alt="广告投放模型" style="zoom: 67%;" />

<p>​	该层次结构的上下层之间是一对多的关系。<br>​	一个广告主通常创建若干个推广计划，每个计划对应一个较长周期的KPI，比如一个月的预算和投放地域。<br>​	一个推广计划中的多个推广单元分别用于更精细的投放控制，比如一次点击的最高出价、每日预算、定向条件等。<br>​	广告创意是广告曝光使用的素材，根据业务特点，它可以从属于广告主或推广计划层级。</p>
<h3 id="实时化的索引更新"><a href="#实时化的索引更新" class="headerlink" title="实时化的索引更新"></a>实时化的索引更新</h3><p>​	层次结构可以更准确、更及时地反应广告主的投放控制需求。投放模型的每一层都会定义若干字段，用于实现各类投放控制。广告系统的大部分字段需要支持实时更新，比如审核状态、预算上下线状态等。例如，当一个推广单元由可投放状态变为暂停状态时，若该变更没有在索引中及时生效，就会造成大量的无效投放。</p>
<h2 id="生产实践"><a href="#生产实践" class="headerlink" title="生产实践"></a>生产实践</h2><p>​	早期的搜索广告是基于自然搜索的系统架构建的，随着业务的发展，需要根据广告特点进行系统改造。新的广告索引实现了纯粹的实时更新和层次化结构，已经在美团搜索广告上线。该架构也适用于各类非搜索的业务场景。</p>
<p><strong>美团搜索广告的系统架构</strong></p>
<p>​	作为整个系统的核心，基于实时索引构建的广告检索过滤服务（RS），承担了广告检索和各类业务过滤功能。日常的业务迭代，均可通过升级索引配置完成。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220314152502.png" alt="系统架构" style="zoom:67%;" />

<p>此外，为提升系统的吞吐量，多个模块已实现服务端异步化。</p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>广告投放系统是基于 springcloud 开发的项目，主要实现了广告的两个核心的系统。</p>
<ol>
<li><strong>广告投放系统，面向广告主实现了广告投放系统。</strong>重点是广告数据结构的设计，最终实现对外服务接口。</li>
<li><strong>广告检索系统，面向媒体方实现了广告的定向检索。</strong>主要实现了构建索引和广告检索的功能，其中索引数据来自广告投放系统，预加载的部分称之为全量索引，同时检索系统（ ad-search ）会伪装为 MySQL 的 Slave 监听 Binlog，构建增量索引。检索过程依赖于全量和增量索引，实现快速高效的检索。</li>
<li>区别于直接从数据库中检索数据，项目将检索数据存储在本地缓存中，引入倒排索引，构建全量索引+增量索引的组合，大幅减少了推广单元检索的时间。通过使用开源工具 Binlog-connector-java 监听 Binlog 构建增量索引，实现广告投放和检索服务解耦。通过Kafka重构广告检索服务，降低 MySQL 负担。</li>
</ol>
<h2 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h2><ol>
<li>投放系统（ ad-sponsor ）引入<strong>倒排索引</strong>存储结构，构建全量索引+增量索引的组合，大幅减少推广单元检索时间。</li>
<li>使用开源工具 Binlog-connector-java，根据 MySQL Master&#x2F;Slave 协议， 检索系统 ( ad-search )伪装成 Slave 监听 Binlog，动态构建增量索引，实现广告投放和检索服务的解耦。</li>
<li>检索系统（ad-search）多实例监听 Binlog 效率低，利用 Kafka 优化监听方式，通过 Navicat Monitor 测试，内存占用降低 35%（ 65% -&gt; 42% ），最大程度减轻 MySQL 负担。</li>
</ol>
<h2 id="项目架构图"><a href="#项目架构图" class="headerlink" title="项目架构图"></a>项目架构图</h2><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226163345.png" alt="image-20220226163345852" style="zoom:67%;" />

<h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226110933.png" alt="image-20220226110926596" style="zoom: 50%;" />

<h2 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h2><ol>
<li><p>启动 kafka</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先启动zookeeper</span></span><br><span class="line">d:</span><br><span class="line">cd D:\env\kafka_2.12-2.1.0</span><br><span class="line">D:\env\kafka_2.12-2.1.0\bin\windows\zookeeper-server-start.bat config\zookeeper.properties</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再启动kafka</span></span><br><span class="line">d:</span><br><span class="line">cd D:\env\kafka_2.12-2.1.0</span><br><span class="line">bin\windows\kafka-server-start.bat config\server.properties</span><br></pre></td></tr></table></figure>

<p>说明：kafka 启动可能会报错，修改如下配置</p>
<blockquote>
<p>解决办法：修改kafka-run-class.bat中的179行，给%CLASSPATH%加上双引号即可，结果如下：</p>
<p>set COMMAND&#x3D;%JAVA% %KAFKA_HEAP_OPTS% %KAFKA_JVM_PERFORMANCE_OPTS% %KAFKA_JMX_OPTS%<br>%KAFKA_LOG4J_OPTS% -cp “%CLASSPATH%” %KAFKA_OPTS% %*</p>
</blockquote>
</li>
<li><p>启动MySQL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure>

<p>说明：MySQL启动必须确保两个配置</p>
<ul>
<li><p>确保开启了 binlog 日志</p>
</li>
<li><p>确保 binlog 日志的格式 ROW</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226140049.png" alt="img" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>启动 Eureka，所有的服务都需要向 Eureka 注册</p>
</li>
<li><p>启动网关 zuul</p>
</li>
<li><p>启动BinLog监听模块 ad-binlog-kafka</p>
</li>
<li><p>启动广告检索模块 ad-search</p>
</li>
<li><p>最终查看 Eureka 界面，查看服务是否成功</p>
<p>默认访问路径 <a href="http://localhost:8000/">http://localhost:8000/</a></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226141246.png" alt="img"></p>
</li>
</ol>
<h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><p>1 全量导出MySQL的一份数据到本地</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220315203847.png" alt="img"></p>
<p>2 测试广告检索功能</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220315203922.png" alt="img"></p>
<p>3 项目的一个核心功能：当我们对推广单元( ad_unit )进行增、删、改时，MySQL-binlog-connector 监听到 MySQL数据库 binlog 的变化，通过 kafka 发送修改信息，广告检索模块（ ad-search ) 订阅相关信息，并进行处理更新索引，实现广告检索服务功能。</p>
<p>首先我们查看广告推广单元 ad_unit 数据</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226143308.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from ad_unit;</span><br><span class="line">update ad_unit <span class="type">set</span> <span class="variable">unit_status</span> <span class="operator">=</span> <span class="number">0</span> <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>更新一条数据</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226143311.png" alt="img"></p>
<p>我们查看ad-binlog-kafka，可以看出实现了向kafka的数据投递</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226143304.png" alt="img"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226143300.png" alt="img"></p>
<p>此时我们查看ad-search</p>
<p>接受到了kafka投递过来的消息，进行索引的变化，可以看到变化前后索引的不同</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226143255.png" alt="img"></p>
<p>具体结果截取部分如下</p>
<blockquote>
<p>com.ad.consumer.BinlogConsumer     : kafka processMysqlRowData: {“fieldValueMap”:[{“unit_status”:”0”,”id”:”10”,”position_type”:”1”,”plan_id”:”10”}],”level”:”3”,”opType”:”UPDATE”,”tableName”:”ad_unit”}</p>
<p>com.ad.index.adunit.AdUnitIndex    : before update: {10&#x3D;AdUnitObject(unitId&#x3D;10, unitStatus&#x3D;1, positionType&#x3D;1, planId&#x3D;10, adPlanObject&#x3D;AdPlanObject(planId&#x3D;10, userId&#x3D;15, planStatus&#x3D;1, startDate&#x3D;Wed Nov 28 00:00:00 CST 2018, endDate&#x3D;Wed Nov 20 00:00:00 CST 2019)), 12&#x3D;AdUnitObject(unitId&#x3D;12, unitStatus&#x3D;1, positionType&#x3D;1, planId&#x3D;10, adPlanObject&#x3D;AdPlanObject(planId&#x3D;10, userId&#x3D;15, planStatus&#x3D;1, startDate&#x3D;Wed Nov 28 00:00:00 CST 2018, endDate&#x3D;Wed Nov 20 00:00:00 CST 2019))}</p>
<p>com.ad.index.adunit.AdUnitIndex    : after update: {10&#x3D;AdUnitObject(unitId&#x3D;10, unitStatus&#x3D;0, positionType&#x3D;1, planId&#x3D;10, adPlanObject&#x3D;AdPlanObject(planId&#x3D;10, userId&#x3D;15, planStatus&#x3D;1, startDate&#x3D;Wed Nov 28 00:00:00 CST 2018, endDate&#x3D;Wed Nov 20 00:00:00 CST 2019)), 12&#x3D;AdUnitObject(unitId&#x3D;12, unitStatus&#x3D;1, positionType&#x3D;1, planId&#x3D;10, adPlanObject&#x3D;AdPlanObject(planId&#x3D;10, userId&#x3D;15, planStatus&#x3D;1, startDate&#x3D;Wed Nov 28 00:00:00 CST 2018, endDate&#x3D;Wed Nov 20 00:00:00 CST 2019))}</p>
<p> c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</p>
</blockquote>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>我们选取<strong>数据库性能监控工具 Navicat Monitor2</strong>进行测试</p>
<p>首先确保windows系统开启了<em>简单网络管理协议</em>（<em>SNMP</em>），如果不知道如何开启，请参考：<a href="https://zhongguo.eskere.club/%E5%A6%82%E4%BD%95%E5%9C%A8-windows-10-%E4%B8%8A%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE-snmp/2021-08-27/">如何在 Windows 10 上安装和配置 SNMP</a></p>
<p>本机SNMP服务已经开启</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226224746.png" alt="image-20220226224746644"></p>
<p>在配置monitor2实例的时候，注意这里的社区字段</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226224648.png" alt="image-20220226224641338" style="zoom:67%;" />

<p>当多实例连接 MySQL 服务器进行监听的时候，社区字段必须和上述SNMP配置相同</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226224821.png" alt="image-20220226224821421" style="zoom:67%;" />

<p>配置完成后的监控页面</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226230456.png" alt="image-20220226230456329"></p>
<p><strong>我们直接多实例连接 MySQL 时的负载状况</strong></p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226225137.png" alt="img" style="zoom: 67%;" />

<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226225156.png" alt="img" style="zoom:67%;" />

<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226225223.png" alt="img" style="zoom:67%;" />

<p>当我们将连接数增大到147时，由于使用第三方开源工具 binlog-connector-java 有最大连接数限制，此时DB connectors标红，日志报错 too many connections</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226225310.png" alt="img" style="zoom:67%;" />

<p>当我们采取了 <strong>Kafka 优化监听方式</strong>，此时无论是 Memory 占用，还是 CPU 都占用都有了较为明显的降低，很大程度上减少了 MySQL 的负担。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226225518.png" alt="img" style="zoom:67%;" />

<h2 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220314190959.png" alt="image-20220314190959358"></p>
<p><strong>画像系统架构</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220314192010.png" alt="画像系统架构"></p>
<ul>
<li><input disabled="" type="checkbox"> 广告投放系统的前端页面</li>
<li><input disabled="" type="checkbox"> 提供用户注册登录等功能</li>
<li><input disabled="" type="checkbox"> 引入ElasticSearch、Filebeat、Kibana 对打印日志做可视化，方便错误排查等</li>
<li><input disabled="" type="checkbox"> 构建<strong>人群画像</strong>（当前是模拟用户数据），通过构建人群信息池来实现对广告信息的过滤</li>
<li><input disabled="" type="checkbox"> 检索得到的用户创意，通过<strong>智能推荐系统</strong>（当前是对满足条件的多个创意进行随机选一个返回），返回用户最感兴趣的创意</li>
<li><input disabled="" type="checkbox"> 提供更多维度的<strong>条件限制</strong>（当前仅为地域、兴趣、关键词）</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>社区论坛项目</title>
    <url>/2022/03/29/show/community/</url>
    <content><![CDATA[<h1 id="community"><a href="#community" class="headerlink" title="community"></a>community</h1><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>论坛实现了注册登录、发帖评论、点赞、关注通知和网站数据统计等功能</p>
<span id="more"></span>

<h2 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h2><p>1 启动redis</p>
<p>redis启动路径D:\env\Redis-x64-3.0.502，点击</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227231651.png" alt="img"></p>
<p>cmd打开弹窗，输入redis-cli，启动交互窗口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 0 </span><br><span class="line">flushdb</span><br><span class="line"></span><br><span class="line">// redis中的规则，如果你有两个单词相连接，中间用冒号隔开</span><br><span class="line">set test:count 1      </span><br><span class="line">get test:count</span><br><span class="line"></span><br><span class="line">incur test:count</span><br><span class="line">decr test:count</span><br><span class="line"></span><br><span class="line">// hashmap</span><br><span class="line">hset test:user id 1 				</span><br><span class="line">hset test:user username zhangsan</span><br><span class="line"></span><br><span class="line">hget test:user id</span><br><span class="line">hget test:user username</span><br><span class="line"></span><br><span class="line">// redis对列表支持比较灵活，可以从左边加入，从右边加入</span><br><span class="line">lpush test:ids 101 102 103 </span><br><span class="line">llen test:ids 				    // 查看列表的长度</span><br><span class="line">lrange test:ids 0 2 			// 范围查看</span><br><span class="line">rpop test:ids</span><br><span class="line"></span><br><span class="line">// set集合中的元素是不能重复的</span><br><span class="line">sadd test:teachers aaa bbb ccc ddd </span><br><span class="line">spop test:teachers 			// 随机弹出一个人，可以用于抽奖</span><br><span class="line">smembers test:teachers		// 查询还有多少人</span><br><span class="line"></span><br><span class="line">// sorted_list 查看有序的集合</span><br><span class="line">zadd test:students 10 aaa 20 bbb 30 ccc 40 ddd</span><br><span class="line"></span><br><span class="line">zscore test:students ccc 30</span><br><span class="line">zrank test:students ccc 2</span><br><span class="line">zrange test:students 0 2 	// 范围内查询 aaa. bbb  ccc</span><br><span class="line"></span><br><span class="line">keys * </span><br><span class="line">keys test*</span><br><span class="line"></span><br><span class="line">type key</span><br><span class="line">exists key</span><br><span class="line">del key</span><br><span class="line"></span><br><span class="line">expire key seconds	// 指定过期时间</span><br></pre></td></tr></table></figure>

<p>2 启动kafka</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先启动zookeeper</span><br><span class="line">d:</span><br><span class="line">cd D:\env\kafka_2.12-2.3.0</span><br><span class="line">D:\env\kafka_2.12-2.3.0\bin\windows\zookeeper-server-start.bat config\zookeeper.properties</span><br><span class="line"></span><br><span class="line"># 再启动kafka</span><br><span class="line">d:</span><br><span class="line">cd D:\env\kafka_2.12-2.3.0</span><br><span class="line">bin\windows\kafka-server-start.bat config\server.properties</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd D:\env\kafka_2.12-2.3.0\bin\windows</span><br><span class="line">创建topic主题</span><br><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br><span class="line"></span><br><span class="line">新建topic</span><br><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic topic_a</span><br><span class="line"></span><br><span class="line">查看已有主题list</span><br><span class="line">kafka-topics --list --zookeeper localhost:2181</span><br><span class="line"></span><br><span class="line">修改分区数</span><br><span class="line">kafka-topics --zookeeper localhost:2181 --alter --topic topic_a  --partitions 2</span><br><span class="line"></span><br><span class="line">创建生产者</span><br><span class="line">kafka-console-producer --topic topic_a --broker-list localhost:9092</span><br><span class="line"></span><br><span class="line">创建消费者</span><br><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 -topic topic_a</span><br><span class="line"></span><br><span class="line"># 关闭kafka的顺序是，先关闭kakfa，再关闭zookeeper</span><br><span class="line"># 关闭kafka</span><br><span class="line">/usr/local/Cellar/kafka/2.7.0/bin/kafka-server-stop</span><br><span class="line"># 关闭zookeeper</span><br><span class="line">/usr/local/Cellar/kafka/2.7.0/bin/zookeeper-server-stop</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3 启动MySQL</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>我们选取压力测试工具 JMeter 进行测试</p>
<p>双击jmeter.bat进行启动</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227231537.png" alt="img"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227231541.png" alt="img"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227231545.png" alt="img"></p>
<p>100个线程同时打过来，自己的电脑肯定就瘫痪了，我们需要设置一定的随机延迟，我们这里设置延迟时间在0-1秒之间</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227231548.png" alt="img"></p>
<p>我们查看一下吞吐量</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227231551.png" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>爱奇艺实习</title>
    <url>/2022/02/27/show/%E7%88%B1%E5%A5%87%E8%89%BA%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="爱奇艺实习"><a href="#爱奇艺实习" class="headerlink" title="爱奇艺实习"></a>爱奇艺实习</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>凌虚 (LINGXU) 是计算云团队提供的基于 IAAS 的自助运维平台，该平台提供了面向用户和后台运维管理的一站式解决方案。主要负责奇境环境相关服务的开发和维护。</p>
<span id="more"></span>

<h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 开发奇境安全环境所属项目成员对对应环境下白名单的查看权限</span><br><span class="line">- 开发奇境安全环境所属项目管理员对对应白名单进行增删改的功能权限</span><br><span class="line"></span><br><span class="line">- 奇境环境自动生成环境名 &amp; 环境名不可编辑</span><br><span class="line">- 测试设备环境切换</span><br><span class="line">- 测试用户测试设备管理</span><br><span class="line"></span><br><span class="line">- 白名单工单回调逻辑优化，相同白名单更新创建时间和有效期</span><br><span class="line"></span><br><span class="line">- 开发 wifi 设备管理开放接口</span><br><span class="line">- wifi 设备管理开放接口调用完毕</span><br><span class="line">- wifi 前后台根据接口文档调整</span><br><span class="line"></span><br><span class="line">- 安全环境半自动化 wifi 接入接口开发完毕</span><br><span class="line">- VPN 白名单半自动化开发</span><br><span class="line"></span><br><span class="line">- 开放测试环境占用，开发页面入口</span><br><span class="line">- 开放测试环境创建业务，开发开放页面入口</span><br></pre></td></tr></table></figure>

<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>前端：Vue+QUI（爱奇艺组件库）<br>后端： SpringBoot + MyBatis Plus+ MySQL</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226233906.png" alt="image-20220226233906658"></p>
<h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p>注意：下面说的凌虚都是指 5.8 版本 ， 4.7 版本仅前几天进行简单了解</p>
<h3 id="凌虚首页"><a href="#凌虚首页" class="headerlink" title="凌虚首页"></a>凌虚首页</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226234131.png" alt="image-20220226234131814"></p>
<h3 id="安全环境"><a href="#安全环境" class="headerlink" title="安全环境"></a>安全环境</h3><p>访问权限</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226234208.png" alt="image-20220226234208852"></p>
<p>提供添加白名单功能</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226234245.png" alt="image-20220226234245876"></p>
<p>延长安全环境占用的有效期</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226234312.png" alt="image-20220226234312939"></p>
<p>删除权限</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226234325.png" alt="image-20220226234325556"></p>
<p>申请访问权限，跳转到爱奇艺工单系统进行申请（<a href="http://order-staging.cloud.qiyi.domain/#/createOrder/218%EF%BC%89">http://order-staging.cloud.qiyi.domain/#/createOrder/218）</a></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220226234359.png" alt="image-20220226234359321"></p>
<h3 id="wifi-设备管理"><a href="#wifi-设备管理" class="headerlink" title="wifi 设备管理"></a>wifi 设备管理</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227102109.png" alt="image-20220227102102562"></p>
<p>进行MAC地址录入</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227102140.png" alt="image-20220227102140877"></p>
<p>选择占用环境，支持批量的修改</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227102217.jpg" alt="img"></p>
<h3 id="开放测试环境管理"><a href="#开放测试环境管理" class="headerlink" title="开放测试环境管理"></a>开放测试环境管理</h3><p>负责创建业务功能的开发，原先需要先在网关skywalker上申请，或者通过接口分为两个步骤进行申请，第一步申请域名，第二步申请API。</p>
<p>网关skywalker的申请方式</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227102501.png" alt="image-20220227102501753"></p>
<p>接口申请方式</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227102555.png" alt="image-20220227102554994"></p>
<p><strong>现在通过一个创建业务按钮，将两部分的工作进行合并，直接通过创建业务按钮完成业务的申请。</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227102348.png" alt="image-20220227102348402"></p>
<p>点击创业业务按钮</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227102406.png" alt="image-20220227102406286"></p>
<h3 id="开放测试环境占用"><a href="#开放测试环境占用" class="headerlink" title="开放测试环境占用"></a>开放测试环境占用</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227102740.png" alt="image-20220227102740531"></p>
<h3 id="负责的文档"><a href="#负责的文档" class="headerlink" title="负责的文档"></a>负责的文档</h3><h4 id="开放测试环境wifi接入"><a href="#开放测试环境wifi接入" class="headerlink" title="开放测试环境wifi接入"></a>开放测试环境wifi接入</h4><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227102915.png" alt="image-20220227102915764"></p>
<p>这里的环境申请就是上述环境占用功能</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227103208.png" alt="image-20220227103208496"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227103247.png" alt="image-20220227103247653"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227103002.jpg" alt="img"></p>
<h4 id="开放测试环境-环境管理API-访问权限管理部分"><a href="#开放测试环境-环境管理API-访问权限管理部分" class="headerlink" title="开放测试环境-环境管理API-访问权限管理部分"></a>开放测试环境-环境管理API-访问权限管理部分</h4><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227103058.png" alt="image-20220227103058777"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227103346.png" alt="image-20220227103345966"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227103355.png" alt="image-20220227103355612"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227103407.png" alt="image-20220227103407611"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20220227103413.png" alt="image-20220227103413343"></p>
]]></content>
  </entry>
  <entry>
    <title>深度学习入门-基于python的理论设计与实现</title>
    <url>/2022/10/08/pytorch/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E7%90%86%E8%AE%BA%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="深度学习入门-基于python的理论设计与实现"><a href="#深度学习入门-基于python的理论设计与实现" class="headerlink" title="深度学习入门-基于python的理论设计与实现"></a>深度学习入门-基于python的理论设计与实现</h1><h2 id="p0-序言"><a href="#p0-序言" class="headerlink" title="p0 序言"></a>p0 序言</h2><p>本书主要介绍numpy、matploitlib、python3.x版本</p>
<p> 代码路径：E:\python\deep-learning-from-scratch</p>
<h2 id="p1-python入门"><a href="#p1-python入门" class="headerlink" title="p1 python入门"></a>p1 python入门</h2><p><strong>numpy</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221008184340860.png" alt="image-20221008184340860"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221008184746412.png" alt="image-20221008184746412"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221008184954393.png" alt="image-20221008184954393"></p>
<p><strong>数组的维度可以通过np.ndim()获得</strong></p>
<p><strong>matplotlib</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># 生成数据</span><br><span class="line">x = np.arange(0, 6, 0.1) # 以0.1为单位，生成0到6的数据</span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line"></span><br><span class="line"># 绘制图形</span><br><span class="line">plt.plot(x, y1, label=&quot;sin&quot;)</span><br><span class="line">plt.plot(x, y2, linestyle = &quot;--&quot;, label=&quot;cos&quot;)</span><br><span class="line">plt.xlabel(&quot;x&quot;) # x轴的标签</span><br><span class="line">plt.ylabel(&quot;y&quot;) # y轴的标签</span><br><span class="line">plt.title(&#x27;sin &amp; cos&#x27;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="p3神经网络"><a href="#p3神经网络" class="headerlink" title="p3神经网络"></a>p3神经网络</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221008191250158.png" alt="image-20221008191250158"></p>
<p><strong>softmax函数的含义</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221008192700865.png" alt="image-20221008192700865"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221008192715780.png" alt="image-20221008192715780"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221008192755836.png" alt="image-20221008192755836"></p>
<h2 id="p4神经网络的学习"><a href="#p4神经网络的学习" class="headerlink" title="p4神经网络的学习"></a>p4神经网络的学习</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221008195717351.png" alt="image-20221008195717351"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221008200715868.png" alt="image-20221008200715868"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221008200904158.png" alt="image-20221008200904158"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221008221017368.png" alt="image-20221008221017368"></p>
<h2 id="p6学习相关的技巧"><a href="#p6学习相关的技巧" class="headerlink" title="p6学习相关的技巧"></a>p6学习相关的技巧</h2><p><strong>参数的更新</strong></p>
<ul>
<li>SGD<ul>
<li><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221009105610238.png" alt="image-20221009105610238"></li>
</ul>
</li>
<li>Momentum<ul>
<li><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221009105726346.png" alt="image-20221009105726346"></li>
</ul>
</li>
<li>AdaGrad<ul>
<li><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221009105749599.png" alt="image-20221009105749599"></li>
</ul>
</li>
<li>Adam</li>
</ul>
<p><strong>权重的初始值</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221009110508264.png" alt="image-20221009110508264"></p>
<p><strong>BatchNormalization</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221009144004291.png" alt="image-20221009144004291"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221009144035472.png" alt="image-20221009144035472"></p>
<p><strong>正则化</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221009144802460.png" alt="image-20221009144802460"></p>
<p><strong>全连接层</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/95dc3576c3bc83c81a2ab46f5c1beb2a.jpg" alt="img"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221009150852328.png" alt="image-20221009150852328"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221009151105329.png" alt="image-20221009151105329"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20221009151746126.png" alt="image-20221009151746126"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/v2-ce38cd537dfe6deb9e96dac385d84969_720w.webp" alt="img"></p>
<p><img src="E:\house\typora\img2\image-20221009151935618.png" alt="image-20221009151935618"></p>
<p><strong>CNN的实现</strong></p>
]]></content>
  </entry>
  <entry>
    <title>pytorch 总结</title>
    <url>/2022/09/24/pytorch/pytorch/</url>
    <content><![CDATA[<h1 id="Pytorch总结"><a href="#Pytorch总结" class="headerlink" title="Pytorch总结"></a>Pytorch总结</h1><p>参考B站小土堆：<a href="https://www.bilibili.com/video/BV1hE411t7RN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ec8158f9c5639641ada55d1a5998f03b">https://www.bilibili.com/video/BV1hE411t7RN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ec8158f9c5639641ada55d1a5998f03b</a></p>
<h2 id="p1环境配置和安装"><a href="#p1环境配置和安装" class="headerlink" title="p1环境配置和安装"></a>p1环境配置和安装</h2><p>先配置anaconda，官网去安装pytorch(1.3之后)</p>
<p>3090服务器密码：111111</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n pytorch_name python=3.6</span><br><span class="line"></span><br><span class="line">conda activate pytorch_name</span><br><span class="line"></span><br><span class="line">nvidia-smi</span><br><span class="line"></span><br><span class="line">pip list</span><br></pre></td></tr></table></figure>

<p>windows下推荐conda安装，linux推荐pip</p>
<h2 id="p4重要函数"><a href="#p4重要函数" class="headerlink" title="p4重要函数"></a>p4重要函数</h2><p>dir(torch)</p>
<p>help(torch.cuda.is_available)</p>
<h2 id="p5-加载数据"><a href="#p5-加载数据" class="headerlink" title="p5 加载数据"></a>p5 加载数据</h2>]]></content>
  </entry>
  <entry>
    <title>并发编程的艺术-读书笔记</title>
    <url>/2022/03/02/note/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="并发编程的艺术"><a href="#并发编程的艺术" class="headerlink" title="并发编程的艺术"></a>并发编程的艺术</h1><h2 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1 volatile"></a>1 volatile</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">汇编角度lock+操作系统角度分析原理</span><br><span class="line">保证可见性，不保证原子性，从JMM内存模型的角度分析</span><br><span class="line">禁止指令重排</span><br><span class="line">优化，volatile修饰的变量追加到64字节，从操作系统角度分析，高速缓存行的长度为64位，每次读取会锁定当前的高速缓存行</span><br></pre></td></tr></table></figure>

<p>（1）关键字volatile是Java虚拟机提供的最轻量级的同步机制，它的执行成本更低<br>（2）如何保证可见性？<br>    关键字volatile可以用来修饰字段（成员变量），也就是告诉程序任何对该变量的访问都需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量的可见性</p>
<p>​	不妨从汇编码角度看看volatile修饰之后发生了什么？我们知道Java代码被编译器编译生成字节码，字节码被类加载器加载到JVM里，JVM执行字节码转换成汇编指令在CPU上运行，比方说下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instance = new instance();   instance有volatile修饰，转换成汇编码</span><br><span class="line">=&gt; lock add $0*0(%esp)</span><br></pre></td></tr></table></figure>

<p>​		转换成汇编码可以看到，JVM会向处理器发送前缀是lock的指令，这个变量所在的缓存行的数据写入主内存，其他处理器会通过嗅探在总线传来的数据，判断自己的缓存值是否过期（当我们写入主内存后，其他处理器的缓存失效），当处理器对这个数据修改的时候，会重新从系统内存读取数据到处理器的缓存<br>​		总结来说，加上volatile前缀主要实现了，lock前缀指令会让处理器缓存写回主内存；一个处理器缓存写回主内存会让其他处理器缓存失效；保证了所有线程对volatile修饰变量的可见性</p>
<p>（3）volatile的优化<br>jdk7的并发包增加了一个队列集合类，会自动将volatile修饰的变量追加到64位<br>因为英特尔i7处理器的高速缓存行是64字节带宽，不支持部分填充缓存行，如果队列的头尾结点不足64个字节，那么处理器会读到同一个缓存行里，当一个处理器试图修改缓存行的时候，会将整个缓存行锁定，那么其他处理器此时不能访问缓存行的尾部结点！</p>
<p>（4）volatile的读和写的内存语义<br>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新回主内存<br>当读一个volatile变量时，JMM会把该线程的本地内存设置为无效，从主内存中读取共享变量</p>
<p>问：你在哪些地方使用volatile?<br>答：多线程的单例模式情况下</p>
<h2 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2 synchronized"></a>2 synchronized</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">汇编角度monitor监视器的获取，moitorenter和moitorexit，monitor的获取是排他性的，分析原理</span><br><span class="line">Java对象头，synchronized用的锁是存在Java头中的</span><br></pre></td></tr></table></figure>

<p>（1）synchronized在并发编程的时候也广泛使用，很多人称作是重量级锁。但其实从java SE1.6对synchronized进行优化后，已经不是很重了。为减少获取锁和释放锁带来的性能开销，引入了偏向锁和轻量级锁。<br>（2）底层实现：<br>    synchronized基于进入和退出monitor对象实现同步，monitor enter指令插入在同步代码块开始的位置，monitor exit插入在同步代码块结束或者发生异常的位置。任何一个对象都要有一个montor对象相关联，当一个monitor被持有的时候，就处在锁定状态。当线程执行到monitor enter的时候，就尝试获取monitor的所有权，即尝试获取锁，当运行到monitor exit就释放锁。<br>    synchronized的锁一般存在Java对象头中<br>    关键字synchronized保证线程对变量访问的可见性和排他性</p>
<h2 id="3-锁"><a href="#3-锁" class="headerlink" title="3 锁"></a>3 锁</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无锁、偏向锁、轻量级锁、重量级锁、可重入锁、读写锁</span><br><span class="line">每个锁的概念，实现方法，获取每个锁的方法</span><br></pre></td></tr></table></figure>

<p>在Java SE1.6的时候，锁一共有4个状态，从低到高是无锁状态，偏向锁状态，轻量锁状态和重量锁状态</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406221211.png" alt="image-20210406221211482" style="zoom:50%;" />

<p>（1）偏向锁<br>    研究的时候发现，大多数情况下都不存在锁的竞争，锁总是由同一个线程多次获得，为了让线程以更低的代价获得锁，引入了偏向锁的概念。<br>    当一个线程获取到锁的时候，会在对象头里面写入锁偏向的线程ID，以后该线程进入和退出同步块的时候不需要CAS操作来进行加锁和解锁，只需要简单的看一下对象头是否存储了指向当前线程的偏向锁。测试成功，表明获得了偏向锁；测试失败，查看当前是否是偏向锁。如果是偏向锁，那么CAS将对象头的偏向锁指向当前线程，如果不是，那么CAS竞争锁<br>    偏向锁使用了一种等待竞争出现才释放锁的方法<br>（2）轻量级锁<br>    使用轻量级锁时，不需要申请互斥量，仅仅将对象头中的Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁<br>    轻量级解锁的时候，会用cas操作将mark word的部分字节替换回对象头，如果成功，表明没有竞争，如果失败，表示当前存在竞争。导致锁膨胀，升级为重量级锁<br>（3）重量级锁<br>锁被持有时，其他线程进行等待</p>
<h2 id="4-AQS"><a href="#4-AQS" class="headerlink" title="4 AQS"></a>4 AQS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以参考《并发编程的艺术》P121</span><br><span class="line">Java同步器框架，可以构建锁和其他同步组件的基础框架</span><br><span class="line">同步组件ReentrantLock、CountDownLatch、ReentrantReadWriteLock实现都依赖于AQS</span><br><span class="line">实现机制：volatile修饰的state+FIFO队列</span><br></pre></td></tr></table></figure>

<p>问：什么是AQS？<br>答：AQS是队列同步器，这个类在java.util.concurrent.locks包下面。AQS是一个用来构建锁和同步器的框架，比如ReentrantLock，Semaphore，SynchronousQueue等等皆是基于AQS的。</p>
<p>问：AQS的核心思想是什么？它是怎么实现的？<br><strong>答：AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong> AQS使用一个voliate int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。<strong>AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</strong></p>
<p>​	AQS定义了两种资源获取方式：独占（只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如ReentrantLock） 和共享（多个线程可同时访问执行，如Semaphore&#x2F;CountDownLatch，Semaphore、CountDownLatCh、 CyclicBarrier ）。ReentrantReadWriteLock 可以看成是组合式，允许多个线程同时对某一资源进行读。</p>
<p>​	AQS底层使用了模板方法模式， 自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在上层已经帮我们实现好了。</p>
<p>问：AQS独占式同步状态的获取和释放｜同步队列FIFO?<br>答：图中画虚线的结点在通过循环CAS去获取同步状态state(volatile)</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407212754.png" alt="image-20210407212754756" style="zoom:50%;" />

<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407212920.png" alt="image-20210407212919973" style="zoom: 33%;" />

<p>​	分析了独占式同步状态获取和释放过程后，适当做个总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用 tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。</p>
<h2 id="5-CAS"><a href="#5-CAS" class="headerlink" title="5 CAS"></a>5 CAS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compare and swap</span><br><span class="line">除了偏向锁，其他锁的实现方法都采用了CAS</span><br><span class="line">CAS是一种基于锁的操作，而且是乐观锁。</span><br><span class="line">CAS的三个问题+解决方式</span><br><span class="line">	ABA问题=》版本号；</span><br><span class="line">	长时间自旋CAS，消耗资源=》引入pause机制；</span><br><span class="line">	只能保证一个共享变量的院子操作=》封装对象</span><br></pre></td></tr></table></figure>

<p>（1）CAS：cas需要两个数值，一个是改变前的旧值，一个是希望改变后的新值，在操作期间比较旧值有没有发生变化，如果没有发生变化，才变换成新值，否则不发生改变<br>（2）ABA问题：通过加上版本号，比方说现在A-&gt;B-&gt;A,那么我们可以加上版本号，变化成1A-&gt;2B-&gt;3A<br>        只能保证一个共享变量的院子操作，JDK提供了AtomicReference，就可以把多个变量放在一个对象里面，保证原子性</p>
<h2 id="6-JUC"><a href="#6-JUC" class="headerlink" title="6 JUC"></a>6 JUC</h2><p>JUC全称：java.util.concurrent，是JDK提供的一个处理并发的工具包。</p>
<p>atomic包里面存放的是支持原子操作的、处理基本数据类型的类。该包下大量使用到了CAS技术</p>
<p>locks里面存放的是实现处理并发的类。该包下大量使用到了AQS技术</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407203140.jpg" alt="preview"></p>
<h2 id="7-死锁问题"><a href="#7-死锁问题" class="headerlink" title="7 死锁问题"></a>7 死锁问题</h2><p>（1）所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局。<br>（2）产生的原因：<br>互斥使用：所占有的资源具有排他性控制，同一时刻只能给一个进程使用<br>不可剥夺：进程获得的资源不可以强行被剥夺<br>占有和保持：进程获取其他资源获取不到，并不会释放自己占有的资源<br>循环等待：发生死锁的时候，必然会形成一个循环等待的环形链<br>（3）如何防止死锁：<br>    首先写代码前，对于并发的编程，强烈建议使用JDK并发包提供的并发容器和工具类，因为这些都是经过充分优化<br>    当形成了死锁，我们就破坏死锁形成的条件，比如一个进程获得的资源可以强行的进行剥夺；一个进程必须获得了全部的资源，才可以占用资源；<br>    我在看《MySQL技术内幕-深入理解InnoDB引擎》这本书的时候，看到关于解决数据库死锁的方案。一个是设置等待超时的时间限制；一个是在innodb引擎中发生死锁，会有形成一个等待图，innodb存储引擎就是用这个方式进行死锁检测。innodb存储引擎选择回滚undo量最小的事务来解决死锁问题。</p>
<h2 id="8-Java如何实现原子操作"><a href="#8-Java如何实现原子操作" class="headerlink" title="8 Java如何实现原子操作"></a>8 Java如何实现原子操作</h2><p>在Java中，可以通过锁或者循环CAS来实现原子操作；Java提供了一些支持院子操作的类，AtomicBoolean,AtomicInteger,AtomicLong等等</p>
<h2 id="9-Java内存模型"><a href="#9-Java内存模型" class="headerlink" title="9 Java内存模型"></a>9 Java内存模型</h2><p>问：解释一下JMM<br>答：首先JMM本身就是一个抽象的概念，本身并不存在。由于JVM运行的实体时线程，每个线程创建时JVM都会为他创建一个工作内存，工作内存时每个线程的私有空间，而Java内存模型中规定的所有变量都存储在主内存，主内存是共享区域，所有线程都可以访问。<br>如果一个线程A要和线程B通信的话，需要进行下面的操作：<br>1 线程A把本地内存的A中更新过的共享变量刷新到主内存中<br>2 线程B从主内存中读取线程A之前更新过的数据</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407200109.png" alt="image-20210407200109037" style="zoom: 33%;" />

<p>（1）happens-before<br>在JMM中，如果一个操作要对另一个操作可见，那么两个操作就必须要有happens-before的关系。<br>happens-before并不要求前一个操作必须在后一个操作之前执行！仅要求前一个操作对后一个操作可见，且前一个操作的执行顺序在后一个操作之前。</p>
<p>（2）重排序<br>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p>
<h2 id="10-可重入锁｜递归锁"><a href="#10-可重入锁｜递归锁" class="headerlink" title="10 可重入锁｜递归锁"></a>10 可重入锁｜递归锁</h2><p>可重入锁是指同一个线程可以多次获取同一把锁。除此之外，还可以选择设置为公平锁或者是非公平锁<br>默认情况下是非公平锁；非公平锁虽然可能导致线程的“饥饿“，但是可以进行较少的线程切换，保证了较大的吞吐量</p>
<p>实现原理：volatile 变量 + CAS设置值 + AQS，ReentrantLock锁的实现步骤总结为三点</p>
<pre><code> 1、未竞争到锁的线程将会被CAS为一个链表结构并且被挂起。
 2、竞争到锁的线程执行完后释放锁并且将唤醒链表中的下一个节点。
 3、被唤醒的节点将从被挂起的地方继续执行逻辑
</code></pre>
<p><strong>【AQS】</strong></p>
<p>是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。AQS解决了在实现同步容器时设计的大量细节问题。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407205722.png" alt="img" style="zoom: 50%;" />

<p>AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus</p>
<p>ReentrantLock的基本实现可以概括为：先通过CAS尝试获取锁。如果此时已经有线程占据了锁，那就加入AQS队列并且被挂起。当锁被释放之后，排在CLH队列（CLH同步队列是一个FIFO双向队列）队首的线程会被唤醒，然后CAS再次尝试获取锁。在这个时候，如果：</p>
<p>非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；<br>公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁。</p>
<h2 id="11-自旋锁"><a href="#11-自旋锁" class="headerlink" title="11 自旋锁"></a>11 自旋锁</h2><p>尝试获取锁的进程不会发生阻塞，而是采用循环的方式去获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p>
<h2 id="12-读写锁"><a href="#12-读写锁" class="headerlink" title="12 读写锁"></a>12 读写锁</h2><p>之前提到的mutex或者是reentrantlock都是排他性锁，同一时刻只能一个线程进行访问。读写锁同一时刻可以支持多个读线程访问，但是写线程访问的时候，所有的读线程和其他写线程均被阻塞。</p>
<p>问：读写锁的设计，如何在一个整型变量上维护多个状态？</p>
<p>​		读写锁的设计同样依赖于AQS，而读写锁的状态就是同步器的同步状态。那么如何在一个整型变量上维护多个状态呢，我们采用“按位切割使用”这个变量，这个变量的高16位表示读，低16位表示写。</p>
<p>​		<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407215123.png" alt="image-20210407215123394" style="zoom:50%;" /></p>
<h2 id="13-ThreadLocal"><a href="#13-ThreadLocal" class="headerlink" title="13 ThreadLocal"></a>13 ThreadLocal</h2><p>ThreadLocal是线程变量，是一个以ThreadLocal对象为键，任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值</p>
<h2 id="14-condition"><a href="#14-condition" class="headerlink" title="14 condition"></a>14 condition</h2><p>condition对象是依赖于lock对象创建出来的，换句话说，condition对象是依赖lock对象的。<br>获取一个condition，必须通过lock的new condition()方法</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407215809.png" alt="image-20210407215809575" style="zoom:50%;" />

<p>每一个结点都是线程获取同步信息失败的话，将这个线程的信息封装成一个结点<br>关于condition的signal()方法，进行通知操作：<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210407220233.png" alt="image-20210407220233494" style="zoom:50%;" /></p>
<h2 id="15-HashMap"><a href="#15-HashMap" class="headerlink" title="15 HashMap"></a>15 HashMap</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>注意看美团的文章，已经打印出来了！<br>(1)在并发编程的过程中，使用HashMap可能导致死循环，而使用线程安全的HashTable的效率比较低下，因此我们使用ConcurrentHashMap.<br>(2)hashTable，在任意时刻只能一个线程写HashTable，并发量不如ConcurrentHashMap</p>
<p>在JDK1.7的时候</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409130536.jpeg" alt="640?wx_fmt=jpeg" style="zoom: 67%;" />

<p>在JDK1.8的时候，当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低。因此 1.8 中重点优化了这个查询效率。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409130649.jpeg" alt="640?wx_fmt=png" style="zoom:67%;" />

<h2 id="concurrentHashMap"><a href="#concurrentHashMap" class="headerlink" title="concurrentHashMap"></a>concurrentHashMap</h2><p>（1）JDK1.7之前</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409132659.jpeg" alt="640?wx_fmt=png"></p>
<p>​	是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。<br>​	原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409133303.png" alt="image-20210409133303333" style="zoom:50%;" />

<p>再结合图看看 put 的流程。</p>
<ol>
<li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li>
<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li>
<li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>
<li>最后会解除在 1 中所获取当前 Segment 的锁。</li>
</ol>
<p>（2）JDK1.8，移除 Segment，使锁的粒度更小，Synchronized + CAS</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409133555.jpeg" alt="640?wx_fmt=png" style="zoom: 67%;" />

<p>(3)总结：<br>    JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）<br>    JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了<br>    JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档<br>    JDK1.8为什么使用内置锁synchronized来代替重入锁ReentrantLock，我觉得有以下几点<br>    因为粒度降低了，在相对而言的低粒度加锁方式，synchronized并不比ReentrantLock差，在粗粒度加锁中ReentrantLock可能通过	Condition来控制各个低粒度的边界，更加的灵活，而在低粒度中，Condition的优势就没有了<br>JVM的开发团队从来都没有放弃synchronized，而且基于JVM的synchronized优化空间更大，使用内嵌的关键字比使用API更加自然<br>在大量的数据操作下，对于JVM的内存压力，基于API的ReentrantLock会开销更多的内存，虽然不是瓶颈，但是也是一个选择依据</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>谈谈你理解的 HashMap，讲讲其中的 get put 过程。</p>
</li>
<li><p>1.8 做了什么优化？</p>
</li>
<li><p>是线程安全的嘛？</p>
</li>
<li><p>不安全会导致哪些问题？</p>
</li>
<li><p>如何解决？有没有线程安全的并发容器？</p>
</li>
<li><p>ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？</p>
</li>
<li><p>table的默认长度为什么是16？负载因此为什么默认是0.75？为什么table的长度一定要是2的n次方？</p>
<p>答：（1）首先说明table的长度为什么是2的n次方。通常情况下在设计桶的大小的时候会设计为素数，因为素数发生冲突的概率要小于合数，在HashTable的长度就被设计为11，那么为什么HashMap的长度采用非常规的设计呢。因为计算hash操作的时候，我们设计到取模的运算，实际上如果length的长度是2的n次方，那么n&amp;(length-1) &#x3D; n%length，计算机计算位运算的速度要远远快于取模的运算；此外，在扩容阶段，设计为2的n次方也比较有优势，不需要重新计算Hash，只需要看hash值新增的那个bit是0还是1就可以了，是0的话不需要改变，是1的话，新的位置就是原索引+原来hashmap的容量<br>（2）如果长度是2的n次方，为什么是16？可能是为了降低hash碰撞的几率<br>（3）负载因此为什么0.75呢，这个设计是综合考虑了空间效率和时空效率的平衡，也可以自己根据业务场景进行一些调整。比如说内存空间很多，要求时间比较快，那么我们可以降低负载因子</p>
</li>
</ol>
<h2 id="16-守护线程"><a href="#16-守护线程" class="headerlink" title="16 守护线程"></a>16 守护线程</h2><p>当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。</p>
<h2 id="17-协程"><a href="#17-协程" class="headerlink" title="17 协程"></a>17 协程</h2><p>展开了史无前例的大促销，你们的用户开始爆炸增长，这时候有10000人同时在线付款，你打算启动10000个线程来处理任务。等等，问题来了，因为每个线程至少会占用4M的内存空间，10000个线程会消耗39G的内存，而服务器的内存配置只有区区8G，这时候你有2种选择，一是选择增加服务器，二是选择提高代码效率。那么是否有方法能够提高效率呢？</p>
<p>我们知道操作系统在线程等待IO的时候，会阻塞当前线程，切换到其它线程，这样在当前线程等待IO的过程中，其它线程可以继续执行。当系统线程较少的时候没有什么问题，但是当线程数量非常多的时候，却产生了问题。<strong>一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。</strong></p>
<p>协程刚好可以解决上述2个问题。协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</p>
<p>回到上面的问题，我们只需要启动100个线程，每个线程上运行100个协程，这样不仅减少了线程切换开销，而且还能够同时处理10000个读取数据库的任务，很好的解决了上述任务。</p>
<h2 id="18-原子类"><a href="#18-原子类" class="headerlink" title="18 原子类"></a>18 原子类</h2><p>Java.util.concurrent.atomic包下定义了原子操作类，总共有13个<br>AutomicInteger、AutomicBoolean、AutomicLong等等</p>
<h2 id="19-线程安全的并发容器"><a href="#19-线程安全的并发容器" class="headerlink" title="19 线程安全的并发容器"></a>19 线程安全的并发容器</h2><h2 id="20-并发工具类"><a href="#20-并发工具类" class="headerlink" title="20 并发工具类"></a>20 并发工具类</h2><h3 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h3><p>等待多线程完成，允许一个或者多个线程等待其他线程完成操作<br>countdownLatch的构造函数接受一个int类型的参数作为计数器，如果你想等待N个点，就传入N</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>内存屏障，让一组线程到达一个屏障后被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行 ，相比countdownLatch，可以用在更加复杂的业务场景</p>
<h3 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h3><p>信号量用来控制同时访问特定资源的的进程数量</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h4 id="红黑树定义和性质"><a href="#红黑树定义和性质" class="headerlink" title="红黑树定义和性质"></a>红黑树定义和性质</h4><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p>
<ul>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：根节点是黑色。</li>
<li>性质3：每个叶子节点（NIL）是黑色。</li>
<li>性质4：每个红色结点的两个子结点一定都是黑色。</li>
<li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li>
</ul>
]]></content>
      <categories>
        <category>web后端</category>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL体系和存储引擎-读书笔记</title>
    <url>/2022/02/22/note/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="MySQL体系和存储引擎"><a href="#MySQL体系和存储引擎" class="headerlink" title="MySQL体系和存储引擎"></a>MySQL体系和存储引擎</h2><p>1 MySQL被设计为一个单进程多线程的数据库，mysql数据库在系统表现就是一个进程</p>
<p>2 mysql会读取配置文件，根据配置文件来启动数据库实例。&#x2F;etc&#x2F;my.cnf</p>
<p>3 mysql的体系结构</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403171939.png" alt="image-20210403171939423" style="zoom:50%;" />

<p>mysql数据库区别其他数据库的一大特点就是插件式的存储引擎，我们应该认识到mysql的核心在于存储引擎</p>
<p>4 innodb存储引擎<br>innodb存储引擎支持事务，mysql从5.5.8开始，使用innodb作为默认的存储引擎<br>innodb使用MVCC（多版本并发控制）来获得高并发性，并且实现了4中默认级别，默认是repeatable级别（可重复读），并且使用next-key locking的方式避免了幻读现象的产生<br>innodb存储引擎采用了聚集的方式，每张表的存储都是按照主键的顺序存放，如果没有显式的在表中指定主键，innodb会为每行生成一个6个字节的rowid，并作为主键</p>
<p>5 myisam存储引擎<br>不支持事务，因为并不是所有的场景都需要支持事务<br>它的缓冲池只缓存索引文件，而不缓冲数据文件，这点和大多数数据库不同</p>
<p>6 我们可以通过show engines查看当前使用的mysql数据库支持的存储引擎</p>
<h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p>1 innodb是针对OLTP（针对事务处理）应用中的首选存储引擎</p>
<p>2 其特点是行锁设计，支持MVCC，支持外键，提供一致性非锁定读，同时被设计最有效的利用内存和CPU</p>
<p>3 体系结构<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403193856.png" alt="image-20210403193856598" style="zoom: 33%;" /></p>
<p>内存池的作用：缓存磁盘上的文件，方便快速读取；重做日志缓存</p>
<p>4 缓冲池<br>（1）对于数据库中页的修改操作，首先修改在 缓冲池中的页，然后再以一定的频率刷新到磁盘上。这里注意的是页从缓冲池刷新回磁盘的操作并不是在每次页发生更新的时候触发，而是通过一种checkPoint的机制<br>（2）体系结构<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403194713.png" alt="image-20210403194713088" style="zoom:50%;" /></p>
<p>​	缓冲索引是通过LRU的方式进行管理的，最频繁使用的页放在LRU列表的前端。当缓冲池不能存放最新读取到的页时，首先释放LRU尾端的页。LRU中还引入了midpoint的机制，就是说新读取到的页，并不是放在LRU的前端，而是插入到midpoint的位置。<br>​	重做日志缓冲，innodb存储引擎先把重做日志放到这个缓冲区，然后一定的频率刷回缓存。</p>
<p>5 checkpoint技术<br>目的是为了缩短数据库的恢复时间；<br>当数据库发生了宕机的时候，数据库不需要重做所有的日志，只需要对checkpoint点之后的日志进行重做，大大缩短了恢复时间</p>
<p>6 master thread的工作方式<br>（1）innodb存储引擎的主要工作都是在一个单独的后台线程master thread中完成的<br>（2）每一秒钟的操作<br>日志缓存刷新到磁盘，即使这个事务还没有提交<br>合并到插入缓冲（可能）<br>至多刷新100个innodb的缓冲池脏页到磁盘<br>loop<br>这里插入100个，是一个硬编码，在后面的版本进行了修改升级</p>
<p><strong>7 innodb的关键特征</strong><br>插入缓冲、两次写、子适应哈希索引、异步IO、刷新临接页<br>（1）插入缓冲<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403200721.png" alt="image-20210403200721383" style="zoom:50%;" /></p>
<p>当插入聚集索引的列时，是按照主键的顺序进行插入的，不需要进行页的切换，所以不需要插入索引<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403200857.png" alt="image-20210403200857731" style="zoom:50%;" /></p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403200927.png" alt="image-20210403200927607" style="zoom:50%;" />

<p>​	innodb存储引擎开创性的设计了插入缓存，对于非聚集索引的插入或者更新，并不是直接更新到索引页中，而是先判断插入的非聚集缩影是否在缓冲池中，如果在就直接插入，如果不在，就先放在一个INSERT BUFFER对象中，好似欺骗，然后再以一定频率进行insert buffer和辅助索引叶子节点的merge操作，这个时候通过将多个插入合并到一个插入中，大大提高了对非聚集索引的插入性能。<br>​	比如INSERT BUFFER中1，99，2，100非聚集索引，合并前需要四次插入，合并之后，1和2是同一个数据页内的，99和100是同一个数据页的，减少了插入的时间花费</p>
<p>（2）两次写<br>插入缓冲给INNODB带来了存储引擎上的提升，double write带来了数据页的可靠性<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403201945.png" alt="image-20210403201945765" style="zoom:50%;" /></p>
<p>（3）自适应的哈希索引<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210405161100.png" alt="image-20210403202139140"></p>
<p>（4）异步IO<br>用户可以在发出一次IO请求后，立即再次发一次IO请求</p>
<p>（5）刷新临接页<br>当刷新一个脏页时，Innodb会自动检测该页所在的区，如果是脏页，那么将一起刷新（脏页就是页面数据发生了更新，磁盘还没更新，数据不同步的页面）</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>1 日志文件<br>错误日志：错误信息<br>二进制日志(binary log)<br>记录了所有对数据库的更改操作，但是不包括SELECT和SHOW的操作</p>
<p>慢查询日志</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403202811.png" alt="image-20210403202811311" style="zoom:50%;" />

<p>重做日志文件<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403203120.png" alt="image-20210403203120452" style="zoom: 50%;" /></p>
<h2 id="索引和算法"><a href="#索引和算法" class="headerlink" title="索引和算法"></a>索引和算法</h2><p>1 索引太多，应用程序的性能可能受到影响；索引太少，对查询性能又会产生影响</p>
<p>2 innodb支持的索引<br>B+树索引，全文索引，自适应哈希索引<br>自适应哈希索引不能人为的建立，会自动根据表的情况进行建立<br>B+树索引并不能找到键值对应的行，而是找到键值所在的页，然后把页加载到内存中进行查找对应的数据</p>
<p>3 B+树</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403203932.png" alt="image-20210403203932428" style="zoom:50%;" />

<p>4 B+树索引<br>    B+树索引分为聚集索引和非聚集索引（辅助索引），无论哪种，都是B+树结构，都是高度平衡的。<br>    B+树的每个节点都是一个页，大小固定位16KB</p>
<p>（1）聚集索引<br>        聚集索引就是按照每张表的主键构造一个B+树，同时叶子节点存放的就是整张表的行记录，也将聚集索引的叶子节点称之为数据页<br>        聚集索引支持范围查找，哈希索引不支持范围查找</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403204925.png" alt="image-20210403204925846" style="zoom: 33%;" />

<p>（2）辅助索引<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403205111.png" alt="image-20210403205111811" style="zoom:33%;" /></p>
<p>5 什么时候需要用索引<br>    并不是什么时候都需要用索引，如果某个字段选择性较少，比如说性别，男女，这个时候使用B+树索引完全没有必要。相反，当某个字段取值范围非常广，几乎没有重复，具有高选择性，那么此时是最合适的。比如说姓名字段。如何判断是否具有高选择性呢？我们可以通过show index查看cardinality列，当这个值越靠近1，说明有必要建立这个索引</p>
<p>6 联合索引<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403211006.png" alt="image-20210403211006678" style="zoom: 33%;" /></p>
<p>最左前缀匹配原则<br>联合索引的第二个好处是已经对第二个键值进行了排序处理，这样在某些情况我们用联合索引可以避免一次排序操作，因为索引本身在叶子节点已经排序了</p>
<p>7 覆盖索引<br>innodb支持覆盖索引，即从辅助索引就可以拿到查询的记录，不需要查询索引中的记录（不用再回表查询 ）</p>
<p>8 全文索引<br>是将存储在数据库中的整本书或整篇文章中的任意内容信息查找出来的技术</p>
<h2 id="innodb存储引擎中的锁"><a href="#innodb存储引擎中的锁" class="headerlink" title="innodb存储引擎中的锁"></a>innodb存储引擎中的锁</h2><p>1 锁的类型</p>
<p>作者：发条地精<br>链接：<a href="https://www.zhihu.com/question/51513268/answer/127777478">https://www.zhihu.com/question/51513268/answer/127777478</a><br>来源：知乎</p>
<p>①在mysql中有表锁，</p>
<p>LOCK TABLE my_tabl_name READ;  用读锁锁表，会阻塞其他事务修改表数据。<br>LOCK TABLE my_table_name WRITe; 用写锁锁表，会阻塞其他事务读和写。</p>
<p>②Innodb引擎又支持行锁，行锁分为<br>共享锁，一个事务对一行的共享只读锁。<br>排它锁，一个事务对一行的排他读写锁。</p>
<p>③这两中类型的锁共存的问题</p>
<p>考虑这个例子：<br>事务A锁住了表中的<strong>一行</strong>，让这一行只能读，不能写。<br>之后，事务B申请<strong>整个表</strong>的写锁。</p>
<p>如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。<br>数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。<br>数据库要怎么判断这个冲突呢？</p>
<p>step1：判断表是否已被其他事务用表锁锁表<br>step2：判断表中的每一行是否已被行锁锁住。</p>
<p>注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。<br>于是就有了意向锁。</p>
<p>在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。<br>在意向锁存在的情况下，上面的判断可以改成</p>
<p>step1：不变<br>step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。<br>注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。</p>
<p>2 一致性非锁定读和MVCC多版本控制<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403215750.png" alt="image-20210403215750274" style="zoom:50%;" /></p>
<p>快照数据是该行的之前版本的数据，该实现是通过undo段来完成的。而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为我们没有必要对历史版本数据进行修改</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210403220229.png" alt="image-20210403220229743" style="zoom:50%;" />

<p>3 锁的算法</p>
<p>innodb有三种行锁的算法，分别是</p>
<p>record lock：行锁，锁定单个行记录的内容<br>gap lock：间隙锁，锁定一个范围，但是不包含记录本身<br>next-key lock：record lock+ gap lock，锁定一个范围并且锁定记录本身</p>
<p>Q:知乎上关于间隙锁的疑问</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210405135936.png" alt="image-20210405135936723" style="zoom: 33%;" />

<p>回答：</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210405140011.png" alt="image-20210405140011758" style="zoom:33%;" />

<p>间隙锁(Gap Lock)<br>当我们在查询语句时，条件为范围查询时，InnoDB不管这个区间是否有数据，都会将其锁住，向这个区间的“间隙”（不存在的行）插入或删除数据都会阻塞。</p>
<p>间隙锁的作用会阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</p>
<p>Next-Key Lock<br>Next-Key Lock &#x3D; Record Lock + Gap Lock InnoDB在默认隔离级别（Repeated Read）下，使用Next-Key Lock的方案解决了幻读的问题。<br>即在进行范围性的SELECT时，我们先对已经存在的Records加上Record Lock，再对此区间的间隙加上Gap<br>Lock，从而解决了幻读的问题。</p>
<p>当查询的索引有唯一的属性时（聚集索引），innodb引擎会对next-key lock进行优化，将其降级为record lock，即锁住索引本身，而不是范围</p>
<p>4 幻读<br>    幻读是指在同一事务下，连续两次同样的SQL语句会导致不同的结果，第二次SQL语句可能返回之前不存在的行</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210405143501.png" alt="image-20210405143501881" style="zoom: 33%;" />

<p>5 锁问题<br>脏读：一个事务读取到另外一个事务没有提交的数据<br>不可重复读：一个事务中读取同一个数据，相同的SQL，两次读取的结果不一样<br>幻读：在一个事务中用同一个SQL两次读取，第二次读到了其他事务插入的行</p>
<p>不可重复读解决：在innodb中，用repeatable read隔离下的mvcc来解决，因为历史版本的数据不会被修改<br>幻读：对当前读用next-key lock，解决幻读问题</p>
<p>6 死锁<br>    死锁是指两个或者两个以上的事务在执行过程中，因争夺资源而造成的一种相互等待的现象<br>    解决死锁的办法之一就是设置超时时间，两个资源相互等待时，设置一个阈值，当超过时间后，其中一个事务进行回滚。<br>    除了超时，当前数据库普遍采用等待图的方法来进行死锁检测，这个是一种更为主动的死锁检测方案，innodb存储引擎就是用这个方式进行死锁检测。innodb存储引擎选择回滚undo量最小的事务</p>
<p>7 锁升级<br>    锁升级是指当前锁的粒度降低，举例可以把页锁升级为表锁</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>1 ACID<br>    原子性：要么全做，要么全不做<br>    隔离性：事务提交前，对其他事务都不可见。通常通过锁来实现<br>    一致性：在事务开始和事务结束以后，数据库的完整性约束没有被破坏。例如一个字段比如身份证ID，是唯一约束。当前有一个事物对身份证ID进行了修改，事务提交失败进行回滚，如果此时身份证ID变成非唯一了，就破坏了事务的一致性要求<br>    持久性：事务提交之后，所有的变化都是永久的</p>
<ul>
<li>数据库事务的一致性是指：保证事务只能把数据库从一个有效（正确）的状态“转移”到另一个有效（正确）的状态。那么，什么是数据库的有效(正确）的状态？满足给这个数据库pred-defined的一些规则的状态都是 valid 的。这些规则有哪些呢，比如说<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Integrity_constraints">constraints</a>, <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Cascading_rollback">cascades</a>,<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Database_trigger">triggers</a> 及它们的组合等。具体到某个表的某个字段，比如你在定义表的时候，给这个字段的类型是number类型，并且它的值不能小于0，那么你在某个 transaction 中给这个字段插入（更改）为一个 String 值或者是负值是不可以的，这不是一个“合法”的transaction，也就是说它不满足我们给数据库定义的一些规则（约束条件）。</li>
</ul>
<p>2 事务的实现<br>事务的隔离性通过之前说的锁来实现，原子性和 持久性通过redo log来保证，一致性通过undo log来保证<br>redo恢复事务提交的页操作，undo用来回滚行记录到某个特定的版本。redo通常是物理日志，记录的是页的物流修改信息。undo是逻辑日志，根据每行记录进行记录，保证事务的回滚和MVCC功能，<br>（1）redo<br>    innodb是事务的存储引擎，其通过force log at commit机制实现事务的持久化，即事务提交时，必须先将事务的所有日志写入重做日志进行持久化，待事务commit操作完成才算完成。innodb中重做日志由两个部分组成，也就是redo log和undo log<br>（2）undo<br>    redo记录了事务的行为，可以很好地通过对页进行重做操作。但是有的时候需要进行回滚操作，这个时候就需要undo。因此在对数据库进行修改的时候，不仅会产生redo日志，还会产生一定量的undo日志</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210405155009.png" alt="image-20210405155009287" style="zoom:33%;" />

<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210405155127.png" alt="image-20210405155127423" style="zoom:33%;" />

<p>3 事务的隔离级别</p>
<ul>
<li><strong>未提交读Read Uncommitted</strong>：最低级别，只能避免不读到物理修改数据过程的数据，数据的逻辑修改的中间态依然存在，破坏了数据一致性，上述问题同时存在。</li>
<li><strong>已提交读Read Committed</strong>：语句级，保证了语句的原子性，只能读到已经提交的内容，但是在修改数据过程中并没有加锁，为什么只会读到已经提交的数据内容呢？，这是使用了“快照读”的方式优化了，使得我们在修改数据的同时，查询不会被阻塞，可以完成高并发的查询，大大提高了效率；但是因为修改的过程中没有加锁，则会出现两次查询数据的过程中，数据中间被其他事务修改或者增添数据了，造成不可重复读和幻读。</li>
<li><strong>可重复读Repeated Read</strong>：事务级，MySQL默认隔离级别，从名字看就知道了，避免了不可重复读的问题。普通的查询同样是通过“快照读”的方式，来避免脏读的出现，在此基础上又加入了一个在事务开启的同时，不能对涉及到的数据行进行修改，从而避免了“同一次事务中读到的数据不一致”的不可重复读的问题，但是没有避免幻读。</li>
<li><strong>可序列号Serializable</strong>：最高级别，事务级，串行执行事务，即一个一个排队执行事务，这种级别下，所有的并发事务问题都会被避免，但是由于从并行操作变成了串行排队操作，效率大大降低。</li>
</ul>
<p>已提交读与可重复读是实际开发中最经常使用到的两种事务隔离级别</p>
<ul>
<li><code>Read Commited</code>的做法是在事务的每一条SQL语句执行前生成一个快照，此时其他并发事务去读取这个数据时，避免了脏读的出现。</li>
<li><code>Repeated Read</code>的做法是在事务的第一次查询前生成一个快照，之后在这一次事务的读取过程中，都去读取这一次快照，从而避免了脏读和不可重复读。</li>
</ul>
<h3 id="面试官：你说熟悉MySQL，那来谈谈InnoDB怎么解决幻读的？"><a href="#面试官：你说熟悉MySQL，那来谈谈InnoDB怎么解决幻读的？" class="headerlink" title="面试官：你说熟悉MySQL，那来谈谈InnoDB怎么解决幻读的？"></a>面试官：你说熟悉MySQL，那来谈谈InnoDB怎么解决幻读的？</h3><p>​	首先说结论，在RR的隔离级别下，Innodb使用MVCC和next-key locks解决幻读，MVCC解决的是普通读（快照读）的幻读，next-key locks解决的是当前读情况下的幻读。</p>
<p>当前读</p>
<p>​	所谓当前读，指的是加锁的select(S或者X), update, delete等语句。在RR的事务隔离级别下，数据库会使用next-key locks来锁住本条记录以及索引区间。</p>
<p>​	拿上面那个例子来说，在RR的情况下，假设使用的是当前读，加锁了的读</p>
<p><code>select * from table where id&gt;3</code> 锁住的就是id&#x3D;3这条记录以及id&gt;3这个区间范围，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻影行记录。</p>
<p>普通读</p>
<p>​	因为普通读是不会加锁的读，故不会有next-key locks的使用，解决幻读的手段是MVCC<br>​	MVCC会给每行元组加一些辅助字段，记录创建版本号和删除版本号。<br>​	而每一个事务在启动的时候，都有一个唯一的递增的版本号。每开启一个新事务，事务的版本号就会递增。<br>​	默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：</p>
<p>SELECT</p>
<ul>
<li>读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的</li>
</ul>
<p>INSERT</p>
<ul>
<li>将当前事务的版本号保存至行的创建版本号</li>
</ul>
<p>UPDATE</p>
<ul>
<li>新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号</li>
</ul>
<p>DELETE</p>
<ul>
<li>将当前事务的版本号保存至行的删除版本号</li>
</ul>
<p>比如我插入一条记录, 事务id 假设是1 ，那么记录如下：也就是说，创建版本号就是事务版本号。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210405161648.jpg" alt="img" style="zoom: 67%;" />

<p>如果我更新的话，事务id假设是2</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210405161648.jpg" alt="img" style="zoom: 67%;" />

<p>这里是把name更新为taotao，原来的元组deleteversion版本号为这个事务的id，并且新增一条<br>如果我删除的话，假设事务是id&#x3D;3</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210405161648.jpg" alt="img" style="zoom:67%;" />
就变成现在这个样子

<p>现在我读取的话，必须同时满足两个条件的</p>
<ul>
<li>读取创建版本小于或等于当前事务版本号 这意味着数据在这个事务之前被创建</li>
<li>删除版本为空或大于当前事务版本号的记录。 这意味着删除操作在这个事务之后发生</li>
</ul>
<p>在RC的模式下，MVCC解决不了幻读和不可重复读，因为每次读都会读它自己刷新的快照版本，简单来说就是另一个事务提交，他就刷新一次，去读最新的</p>
<p>多数数据库都实现了多版本并发控制，并且都是靠保存数据快照来实现的。<br>以 <code>InnoDB</code> 为例，每一行中都冗余了两个字段。一个是行的创建版本，一个是行的删除（过期）版本。<br>具体的版本号（trx_id）存在 <code>information_schema.INNODB_TRX</code> 表中。<br>版本号（trx_id）随着每次事务的开启自增。<br>事务每次取数据的时候都会取创建版本小于当前事务版本的数据，以及过期版本大于当前版本的数据。<br>普通的 select 就是快照读。</p>
<p>4 在serialiable隔离级别的条件下，innodb引擎会给每个select语句后自动加上lock in share mode，即为每一个读取操作加上一个共享锁，在这种隔离情况下，读占用了锁，对一致性的非锁定读不再支持</p>
<p>5 分布式事务<br>在使用分布式事务时，innodb引擎的事务隔离级别必须设置为serializable</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210405163948.png" alt="image-20210405163948339" style="zoom:50%;" />

<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><p>1 根据方法的不同可以分为<br>热备份：数据库运行中直接备份<br>冷备份：备份操作是在数据库停止的情况下<br>温备份：同样是数据库运行的时候备份，但是对当前数据库的操作会有影响，如加一个全局读锁保证备份数据的一致性</p>
]]></content>
      <categories>
        <category>web后端</category>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMq-狂神说Java</title>
    <url>/2022/02/02/note/RabbitMq-%E7%8B%82%E7%A5%9E%E8%AF%B4Java/</url>
    <content><![CDATA[<h1 id="RabbitMq-狂神说Java"><a href="#RabbitMq-狂神说Java" class="headerlink" title="RabbitMq-狂神说Java"></a>RabbitMq-狂神说Java</h1><h2 id="1-什么是中间件"><a href="#1-什么是中间件" class="headerlink" title="1 什么是中间件"></a>1 什么是中间件</h2><p>​	中间件需要有通讯功能、高可用、遵循某种规范、持久性<br>​	RMI：远程系统调用<br>​	屏蔽底层操作系统复杂性，我们不需要关注底层是如何互联互通的，我们只需要使用就可以<br>使用了中间件技术可以让我们系统更加灵活方便，如果是单体架构，那么用户系统，订单系统，支付系统都必须使用Java进行开发，使用了中间件可以使用php开发支付，go开发订单</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210315214723.png" alt="image-20210315214716366" style="zoom:67%;" />

<h2 id="2-中间件以及架构技术"><a href="#2-中间件以及架构技术" class="headerlink" title="2 中间件以及架构技术"></a>2 中间件以及架构技术</h2><h3 id="分布式中间件"><a href="#分布式中间件" class="headerlink" title="分布式中间件"></a>分布式中间件</h3><p>ActiveMQ目前以及不再流行了<br><strong>RabbitMQ</strong>目前美团、滴滴都在使用，并且和SpringBoot是同一家族开发的，支持更完善<br>Kafka性能最高的，大数据领域<br>RocketMQ是阿里，滴滴国产开发的，开源和半开源，不稳定，不推荐</p>
<h3 id="负载均衡中间件"><a href="#负载均衡中间件" class="headerlink" title="负载均衡中间件"></a>负载均衡中间件</h3><p>Nginx<br>CDN一定要去了解！<br>LVS负载均衡软件<br>KeepAlive</p>
<h3 id="缓存中间件"><a href="#缓存中间件" class="headerlink" title="缓存中间件"></a>缓存中间件</h3><p>MemCache较小项目中可以使用缓存，类似一个Map，数据写入JVM中<br>Redis</p>
<h3 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h3><p>Mycat<br>ShardingJdbc</p>
<h2 id="3-基于消息中间件的分布式系统的架构"><a href="#3-基于消息中间件的分布式系统的架构" class="headerlink" title="3 基于消息中间件的分布式系统的架构"></a>3 基于消息中间件的分布式系统的架构</h2><h2 id="4-消息队列协议"><a href="#4-消息队列协议" class="headerlink" title="4 消息队列协议"></a>4 消息队列协议</h2><p>AMQP协议，是在TCP&#x2F;IP协议的基础上，是RabbitMQ采用的方式<br>消息中间件不用http协议，常见的消息中间件协议有OpenWire，AMQP、MQTT、Kafka</p>
<p>Q:为什么不直接用http协议<br>因为消息中间件追求性能的极致，简单，快速。http协议的报文头和响应是相对比较复杂的，包含了cookie,数据的加密解密，响应码等附加的功能，实际上我们不需要这么复杂的功能<br>此外，大部分http都是短连接，实际的交互过程中，一个请求到响应很可能会中断，中断后就不会维持持久化，不利于数据的传输</p>
<h3 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h3><p>AMQP是高级消息队列协议，支持者RabbitMQ和ACTIVEMQ</p>
<h2 id="5-消息队列持久化"><a href="#5-消息队列持久化" class="headerlink" title="5 消息队列持久化"></a>5 消息队列持久化</h2><h2 id="6-消息的分发策略"><a href="#6-消息的分发策略" class="headerlink" title="6 消息的分发策略"></a>6 消息的分发策略</h2><p>发布订阅<br>轮询分发：无论你的服务器的性能怎么样，都是公平的<br>公平分发：数据会倾斜，消费能力高的，就会多消费<br>重发<br>消息拉取</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320123013.png" alt="image-20210320123006738"></p>
<h2 id="7-消息的高可用和高可靠"><a href="#7-消息的高可用和高可靠" class="headerlink" title="7 消息的高可用和高可靠"></a>7 消息的高可用和高可靠</h2><p>高可用，在足够长的时间里，比如一年的时间里，一个服务可用的时间，服务可用时间越长越好。一般用可服务时间除于总时间算出一个百分比，用百分比作为度量。比如一个服务如果有5个9的可用性，指的就是一年里99.999%时间里服务都是可用的。<br>高可靠，无论服务器处于什么故障，比如一个系统突然崩溃，报错，异常，都不能影响线上业务的正常运行，出错率极低，称之为高可靠</p>
<p>有两个极端的例子可以很好的说明这两个概念的区别:</p>
<ol>
<li>假想一个服务，可靠性很高，平均来说可以稳定运行10年，但是一旦服务中断，要用一年的时间来恢复，那么它的可用性只有90%。</li>
<li>假想另一个服务，可靠性很差，运行10秒就会宕机，但是恢复服务只需要1ms, 那么它的可用性是99.99%</li>
</ol>
<p>如何保证可靠性呢？<br>1 消息的传输：通过协议保证系统间数据解析的正确性<br>2 消息的存储可靠：通过持久化来保证消息的可靠性</p>
<p>对于集群模式，归根到底三句话：<br>1：要么消息共享，<br>2：要么消息同步<br>3：要么元数据共享</p>
<h2 id="8-RabbitMQ入门和安装"><a href="#8-RabbitMQ入门和安装" class="headerlink" title="8 RabbitMQ入门和安装"></a>8 RabbitMQ入门和安装</h2><p>官网：<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a><br>简单概述：<br>RabbitMQ是一个开源的遵循AMQP协议实现的基于Erlang语言编写，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。</p>
<h3 id="安装rabbitMQ"><a href="#安装rabbitMQ" class="headerlink" title="安装rabbitMQ"></a>安装rabbitMQ</h3><p>1：下载地址：<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a><br>2：环境准备：CentOS7.x+ &#x2F; Erlang<br>RabbitMQ是采用Erlang语言开发的，所以系统环境必须提供Erlang环境，第一步就是安装Erlang。</p>
<h2 id="9-web图像化安装"><a href="#9-web图像化安装" class="headerlink" title="9 web图像化安装"></a>9 web图像化安装</h2><h2 id="10-docker安装rabbitMQ"><a href="#10-docker安装rabbitMQ" class="headerlink" title="10 docker安装rabbitMQ"></a>10 docker安装rabbitMQ</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320143840.png" alt="image-20210320143840501"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -di --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>创建docker容器并运行<br>此时会自动帮我们安装好rabbitmq和rabbitmq的图形化界面，同时开放端口和账号和密码<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320144337.png" alt="image-20210320144337580"></p>
<p>我们去浏览器访问一下图形管理界面<a href="http://47.116.131.130:15672/">http://47.116.131.130:15672/</a><br>登录的账号和密码都是admin</p>
<p>我们可以查看一下我们当前RabbitMQ的运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status rabbitmq</span><br></pre></td></tr></table></figure>

<h2 id="11-RabbitMQ角色分类"><a href="#11-RabbitMQ角色分类" class="headerlink" title="11 RabbitMQ角色分类"></a>11 RabbitMQ角色分类</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320144829.png" alt="image-20210320144829350"></p>
<h2 id="12-rabbitMQ入门案例-simple简单模式"><a href="#12-rabbitMQ入门案例-simple简单模式" class="headerlink" title="12 rabbitMQ入门案例 -simple简单模式"></a>12 rabbitMQ入门案例 -simple简单模式</h2><p>持久化消息会存盘；非持久化信息也会存盘，但是会随着服务器重启而丢失</p>
<h2 id="13-什么是AMQP"><a href="#13-什么是AMQP" class="headerlink" title="13 什么是AMQP"></a>13 什么是AMQP</h2><p>Q：rabbitmq为什么是基于通道处理的，而不是通过连接处理的呢？<br>因为连接需要经过三次握手，每次都通过连接很慢。<br>我们连接采用长连接，一次连接过程有多次通道，高并发的时候很快</p>
<p>AMQP全称：Advanced Message Queuing Protocol(高级消息队列协议)。是应用层协议的一个开发标准，为面向消息的中间件设计。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320163852.png" alt="image-20210320163852739"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320163914.png" alt="image-20210320163914915"></p>
<h2 id="14-RabibitMQ的核心组成"><a href="#14-RabibitMQ的核心组成" class="headerlink" title="14 RabibitMQ的核心组成"></a>14 RabibitMQ的核心组成</h2><p>Q：可以存在没有交换机的队列嘛？<br>不可能<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320164533.png" alt="image-20210320164533148"></p>
<p>队列接收到的消息都是通过交换机得到的，如果我们在程序中没有指定交换机，那么这个队列就会绑定在默认的交换机上<br>Routing key:作为一个消息发送的条件，消息队列中的消息我只想发给course，就增加条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where routing key = course</span><br></pre></td></tr></table></figure>

<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320170420.png" alt="image-20210320170420744" style="zoom:50%;" />

<p>核心概念：<br><strong>Server</strong>：又称<strong>Broker</strong> ,接受客户端的连接，实现AMQP实体服务。 安装rabbitmq-server<br><strong>Connection</strong>：连接，应用程序与Broker的网络连接 TCP&#x2F;IP&#x2F; 三次握手和四次挥手<br><strong>Channel</strong>：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。<br><strong>Message</strong> :消息：服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。<br><strong>Virtual Host</strong> 虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机理由可以有若干个Exhange和Queueu，同一个虚拟主机里面不能有相同名字的Exchange<br><strong>Exchange</strong>：交换机，接受消息，根据路由键发送消息到绑定的队列。(不具备消息存储的能力)<br><strong>Bindings</strong>：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key.<br><strong>Routing key</strong>：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。<br><strong>Queue</strong>：队列：也成为Message Queue,消息队列，保存消息并将它们转发给消费者。</p>
<h3 id="RabbitMQ整体架构"><a href="#RabbitMQ整体架构" class="headerlink" title="RabbitMQ整体架构"></a>RabbitMQ整体架构</h3><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320164852.png" alt="img" style="zoom: 50%;" />

<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320170831.png" alt="img" style="zoom:67%;" />

<p><strong>任何队列都要绑定交换机</strong>，没有指定的话就会绑定默认的交换机，一定要有交换机。消息是通过交换机放到队列里的</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320201634.png" alt="image-20210320201634815"></p>
<h2 id="15-发布订阅模式-fanout模式"><a href="#15-发布订阅模式-fanout模式" class="headerlink" title="15 发布订阅模式-fanout模式"></a>15 发布订阅模式-fanout模式</h2><p>​		飞哥代码里并没有去绑定交换机和队列，是因为飞哥是在web控制页面进行了队列和交换机的绑定！我们可以发现通过web控制页面绑定可以减少代码<br>​		只要队列有人进行订阅，那么交换机投递消息到所有队列</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320204116.png" alt="image-20210320204116710"></p>
<h2 id="16-路由模式-direct模式"><a href="#16-路由模式-direct模式" class="headerlink" title="16 路由模式-direct模式"></a>16 路由模式-direct模式</h2><p>每个队列绑定一个路由名，当交换机发送信息的时候，必须指定发送的路由信息才可以发送出去</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320204157.png" alt="image-20210320204157307"></p>
<h2 id="17-主题模式-topic模式"><a href="#17-主题模式-topic模式" class="headerlink" title="17 主题模式-topic模式"></a>17 主题模式-topic模式</h2><p>支持模糊匹配的路由key<br>消息队列首先设置交换机和队列的关系（routingKey），然后交换机定义模糊查询的key,通过模糊查询，进行消息的插入</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320204912.png" alt="image-20210320204912919"></p>
<h2 id="18-work模式-轮训模式"><a href="#18-work模式-轮训模式" class="headerlink" title="18 work模式-轮训模式"></a>18 work模式-轮训模式</h2><h2 id="19-work模式-公平分发模式"><a href="#19-work模式-公平分发模式" class="headerlink" title="19 work模式-公平分发模式"></a>19 work模式-公平分发模式</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320214218.png" alt="img"></p>
<p>当有多个消费者时，我们的消息会被哪个消费者消费呢，我们又该如何均衡消费者消费信息的多少呢?<br>主要有两种模式：<br>1、轮询模式的分发：一个消费者一条，按均分配；<br>2、公平分发：根据消费者的消费能力进行公平分发，处理快的处理的多，处理慢的处理的少；按劳分配；</p>
<p>总结：<br>（1）当队列里消息较多时，我们通常会开启多个消费者处理消息；公平分发和轮询分发都是我们经常使用的模式。<br>（2）轮询分发的主要思想是“按均分配”，不考虑消费者的处理能力，所有消费者均分；这种情况下，处理能力弱的服务器，一直都在处理消息，而处理能力强的服务器，在处理完消息后，处于空闲状态；<br>(3) 公平分发的主要思想是”能者多劳”，按需分配，能力强的干的多。</p>
<h2 id="20-RabbitMQ使用场景"><a href="#20-RabbitMQ使用场景" class="headerlink" title="20 RabbitMQ使用场景"></a>20 RabbitMQ使用场景</h2><p>rabbitmq主要是通过erlang语言实现的，erlang语言是开发电信设备的，所以rabbitmq中很重要的概念就是交换机</p>
<p><strong>Q：面试官问你为什么使用RabbitMQ</strong><br>我在2020年在某个公司实习，公司项目开始采用的是单体架构，但是随着发展，架构师迭代开发版本，设计分布式的架构，此时不同模块间需要进行通信，因此采用了rabbitmq作为消息中间件。</p>
<p>自己使用RabbitMQ的感觉话，最核心的是它是一个异步的，因为它是一个分发，多线程的机制，可以让我们的网站性能成倍的提升，因为有了异步，可以让性能得到极大的提升</p>
<h3 id="解耦、削峰、异步"><a href="#解耦、削峰、异步" class="headerlink" title="解耦、削峰、异步"></a>解耦、削峰、异步</h3><p>同步执行的代码</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320220922.png" alt="image-20210320220922340"></p>
<p>异步消息队列的方式</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210320221811.png" alt="image-20210320221811509"></p>
<p>什么是削峰</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210321092951.png" alt="image-20210321092951035"></p>
<h3 id="高内聚、低耦合"><a href="#高内聚、低耦合" class="headerlink" title="高内聚、低耦合"></a>高内聚、低耦合</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210321093040.png" alt="img"></p>
<p>04、分布式事务的可靠消费和可靠生产<br>05、索引、缓存、静态化处理的数据同步<br>06、流量监控<br>07、日志监控（ELK）<br>08、下单、订单分发、抢票</p>
<h2 id="21-SpringBoot案例-fanout模式"><a href="#21-SpringBoot案例-fanout模式" class="headerlink" title="21 SpringBoot案例- fanout模式"></a>21 SpringBoot案例- fanout模式</h2><p>短信服务、邮件服务、sms服务如何和消息队列进行绑定呢？这里我们通过<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210321104320.png" alt="image-20210321104320801"></p>
<p>@RabbitListener这个注解来实现</p>
<h2 id="22-springboot案例-direct模式"><a href="#22-springboot案例-direct模式" class="headerlink" title="22 springboot案例-direct模式"></a>22 springboot案例-direct模式</h2><p>Q：京东的问题，我们在开发的过程中，配置的申明是配置在生产者这里好一点还是配置在消费者这里好一点？</p>
<p>理论上来说，对于配置来说都可以，或者两边都配置也可以<br>不过，在消费者这端配置认为相对更好一点，因为队列如果没有声明，启动消费者这边的服务会报错</p>
<h2 id="23-SpringBoot案例-topic模式"><a href="#23-SpringBoot案例-topic模式" class="headerlink" title="23 SpringBoot案例-topic模式"></a>23 SpringBoot案例-topic模式</h2><p>之前的绑定我们都是写的配置类，其实通过注解的方式也可以实现配置类</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210321112301.png" alt="image-20210321112301901"></p>
<p>作者推荐还是通过配置类来完成</p>
<h2 id="24-高级-过期时间TTL"><a href="#24-高级-过期时间TTL" class="headerlink" title="24 高级-过期时间TTL"></a>24 高级-过期时间TTL</h2><p>过期时间TTL表示可以对消息设置预期的时间，在这个时间内都可以被消费者接收获取；过了之后消息将自动被删除。RabbitMQ可以对<strong>消息和队列</strong>设置TTL。目前有两种方法可以设置。</p>
<ul>
<li><p>第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间。</p>
</li>
<li><p>第二种方法是对消息进行单独设置，每条消息TTL可以不同。</p>
<p>如果上述两种方法同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。消息在队列的生存时间一旦超过设置的TTL值，<strong>就称为dead message被投递到死信队列</strong>， 消费者将无法再收到该消息。</p>
</li>
</ul>
<h2 id="25-高级-消息确认机制的配置"><a href="#25-高级-消息确认机制的配置" class="headerlink" title="25 高级-消息确认机制的配置"></a>25 高级-消息确认机制的配置</h2><p>NONE值是禁用发布确认模式，是默认值<br>CORRELATED值是发布消息成功到交换器后会触发回调方法，如1示例<br>SIMPLE值经测试有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果返回false则会关闭channel，则接下来无法发送消息到broker;</p>
<h2 id="26-死信队列"><a href="#26-死信队列" class="headerlink" title="26 死信队列"></a>26 死信队列</h2><p>DLX，全称为Dead-Letter-Exchange , 可以称之为死信交换机，也有人称之为死信邮箱。当消息在一个队列中变成死信(dead message)之后，它能被重新发送到另一个交换机中，这个交换机就是DLX ，绑定DLX的队列就称之为<strong>死信队列</strong>。<br>消息变成死信，可能是由于以下的原因</p>
<ul>
<li>消息被拒绝</li>
<li>消息过期</li>
<li>队列达到最大长度</li>
</ul>
<p>DLX也是一个正常的交换机，和一般的交换机没有区别，它能在任何的队列上被指定，实际上就是设置某一个队列的属性。当这个队列中存在死信时，Rabbitmq就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。<br>要想使用死信队列，只需要在定义队列的时候设置队列参数 <code>x-dead-letter-exchange</code> 指定交换机即可。</p>
<h2 id="27-持久化机制和内存磁盘的监控"><a href="#27-持久化机制和内存磁盘的监控" class="headerlink" title="27 持久化机制和内存磁盘的监控"></a>27 持久化机制和内存磁盘的监控</h2><h3 id="内存警告"><a href="#内存警告" class="headerlink" title="内存警告"></a>内存警告</h3><p>当内存使用超过配置的阈值或者磁盘空间剩余空间对于配置的阈值时，RabbitMQ会暂时阻塞客户端的连接，并且停止接收从客户端发来的消息，以此避免服务器的崩溃，客户端与服务端的心态检测机制也会失效。<br>如下图：</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210323200758.png" alt="img"></p>
<h3 id="02、RabbitMQ的内存控制"><a href="#02、RabbitMQ的内存控制" class="headerlink" title="02、RabbitMQ的内存控制"></a>02、RabbitMQ的内存控制</h3><p>参考帮助文档：<a href="https://www.rabbitmq.com/configure.html">https://www.rabbitmq.com/configure.html</a><br>当出现警告的时候，可以通过配置去修改和调整</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_vm_memory_high_watermark &lt;fraction&gt;rabbitmqctl set_vm_memory_high_watermark absolute 50MB</span><br></pre></td></tr></table></figure>

<p>fraction&#x2F;value 为内存阈值。默认情况是：0.4&#x2F;2GB，代表的含义是：当RabbitMQ的内存超过40%时，就会产生警告并且阻塞所有生产者的连接。通过此命令修改阈值在Broker重启以后将会失效，通过修改配置文件方式设置的阈值则不会随着重启而消失，但修改了配置文件一样要重启broker才会生效。</p>
<h2 id="28-内存磁盘的监控"><a href="#28-内存磁盘的监控" class="headerlink" title="28 内存磁盘的监控"></a>28 内存磁盘的监控</h2><h3 id="rabbitmq的内存换页"><a href="#rabbitmq的内存换页" class="headerlink" title="rabbitmq的内存换页"></a>rabbitmq的内存换页</h3><p>在某个Broker节点及内存阻塞生产者之前，它会尝试将队列中的消息换页到磁盘以释放内存空间，持久化和非持久化的消息都会写入磁盘中，其中持久化的消息本身就在磁盘中有一个副本，所以在转移的过程中持久化的消息会先从内存中清除掉。</p>
<p>比如有1000MB内存，当内存的使用率达到了400MB,已经达到了极限，但是因为配置的换页内存0.5，这个时候会在达到极限400mb之前，会把内存中的200MB进行转移到磁盘中。从而达到稳健的运行。</p>
<h2 id="29-集群"><a href="#29-集群" class="headerlink" title="29 集群"></a>29 集群</h2><p>RabbitMQ这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的magic cookie来实现）。因此，RabbitMQ天然支持Clustering。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。<br>在实际使用过程中多采取多机多实例部署方式，为了便于同学们练习搭建，有时候你不得不在一台机器上去搭建一个rabbitmq集群，本章主要针对单机多实例这种方式来进行开展。<br>主要参考官方文档：<a href="https://www.rabbitmq.com/clustering.html">https://www.rabbitmq.com/clustering.html</a></p>
<h2 id="30-分布式事务"><a href="#30-分布式事务" class="headerlink" title="30 分布式事务"></a>30 分布式事务</h2><p>分布式事务指事务的操作位于不同的节点上，需要保证事务的 AICD 特性。<br>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p>
<p>两个事务都有各自的JVM，都有各自独立的数据库，如何保证两个事务数据的一致性，这就是分布式事务的问题</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210323204334.png" alt="image-20210323204334170"></p>
<p><strong>一、两阶段提交（2PC）需要数据库产商的支持，java组件有atomikos</strong></p>
<p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<ul>
<li><p>2.1 同步阻塞 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p>
</li>
<li><p>2.2 单点问题 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</p>
</li>
<li><p>2.3 数据不一致 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p>
</li>
<li><p>2.4 太过保守 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p>
<p>1.1准备阶段</p>
<p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210323204908.png" alt="img"></p>
<p>1.2 提交阶段<br>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。<br>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210323204915.png" alt="img"></p>
</li>
</ul>
<p><strong>二、补偿事务（TCC） 严选，阿里，蚂蚁金服</strong></p>
<p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p>
<ul>
<li>Try 阶段主要是对业务系统做检测及资源预留</li>
<li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 - - - Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li>
</ul>
<blockquote>
<p>举个例子，假入 Bob 要向 Smith 转账，思路大概是： 我们有一个本地方法，里面依次调用<br>1：首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。<br>2：在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。<br>3：如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</p>
</blockquote>
<p><strong>四、MQ 事务消息 异步场景，通用性较强，拓展性较高。</strong></p>
<p>有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 Kafka 不支持。<br>以阿里的 RabbitMQ 中间件为例，其思路大致为：</p>
<ul>
<li><p>第一阶段Prepared消息，会拿到消息的地址。 第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。</p>
</li>
<li><p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RabbitMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RabbitMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
</li>
</ul>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210323205324.png" alt="img"></p>
<p>优点： 实现了最终一致性，不需要依赖本地数据库事务。<br>缺点： 实现难度大，主流MQ不支持，RocketMQ事务消息部分代码也未开源。</p>
<h3 id="分布式事务的完整架构图"><a href="#分布式事务的完整架构图" class="headerlink" title="分布式事务的完整架构图"></a>分布式事务的完整架构图</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210323205544.png" alt="img"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210323205635.png" alt="img"></p>
<p>上面这种消息传送机制，如果订单服务出现了问题，订单服务进行回滚，但是配送业务不会进行回滚，可能带来数据不一致的问题，我们采用RabbitMQ来解决分布式事务</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210323212142.png" alt="img"></p>
<p>消息的生产问题和消费问题<br>生产可靠性的解决，增加一个冗余记录表，如果消息状态没有变为1，那么就进行重发操作</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210323212721.png" alt="img"></p>
<p>我们可以设置重适次数，默认重试次数为3</p>
<p><strong>基于MQ的分布式事务消息的消息重发</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210323221928.png" alt="img"></p>
<p><strong>基于MQ的分布式事务消息的死信队列消息转移 + 人工处理</strong></p>
<p>重试机制存在一个问题，如果消费者在消费的时候出现了异常状况，比如说1&#x2F;0，此时会不间断的进行重试，可能导致死循环。<br>解决重试的方案：<br>1 控制重试次数+死信队列<br>2 写try-catch块，调用baseNack，不进行重试,也就是count&lt;&#x3D;3的时候就重试。此时重试次数的配置就失效了，全局配置的重试次数就失效了</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210323222006.png" alt="img"></p>
<p>在死信队列发生了异常，我们就进行人工干预<br>幂等性：考虑数据的一致性</p>
<p>使用MQ保证消息数据的一致性，是业内比较认可的方法</p>
<p><strong>基于MQ的分布式事务解决方案优点：</strong></p>
<p>1、通用性强<br>2、拓展方便<br>3、耦合度低，方案也比较成熟</p>
<p><strong>基于MQ的分布式事务解决方案缺点：</strong></p>
<p>1、基于消息中间件，只适合异步场景<br>2、消息会延迟处理，需要业务上能够容忍</p>
<p>建议</p>
<p>1、尽量去避免分布式事务<br>2、尽量将非核心业务做成异步</p>
<h2 id="31-SpringBoot整合RabbitMQ集群配置详解"><a href="#31-SpringBoot整合RabbitMQ集群配置详解" class="headerlink" title="31 SpringBoot整合RabbitMQ集群配置详解"></a>31 SpringBoot整合RabbitMQ集群配置详解</h2><h2 id="32-集群监控"><a href="#32-集群监控" class="headerlink" title="32 集群监控"></a>32 集群监控</h2><h2 id="33-面试题分析"><a href="#33-面试题分析" class="headerlink" title="33 面试题分析"></a>33 面试题分析</h2><p><strong>面试题：1、Rabbitmq 为什么需要信道，为什么不是TCP直接通信</strong></p>
<blockquote>
<p>1、TCP的创建和销毁，开销大，创建要三次握手，销毁要4次分手。</p>
<p>2、如果不用信道，那应用程序就会TCP连接到Rabbit服务器，高峰时每秒成千上万连接就会造成资源的巨大浪费，而且底层操作系统每秒处理tcp连接数也是有限制的，必定造成性能瓶颈。</p>
<p>3、信道的原理是一条线程一条信道，多条线程多条信道同用一条TCP连接，一条TCP连接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能瓶颈。</p>
</blockquote>
<p><strong>2：queue队列到底在消费者创建还是生产者创建？</strong></p>
<blockquote>
<p>1： 一般建议是在rabbitmq操作面板创建。这是一种稳妥的做法。<br>2：按照常理来说，确实应该消费者这边创建是最好，消息的消费是在这边。这样你承受一个后果，可能我生产在生产消息可能会丢失消息。<br>3：在生产者创建队列也是可以，这样稳妥的方法，消息是不会出现丢失。<br>4：如果你生产者和消费都创建的队列，谁先启动谁先创建，后面启动就覆盖前面的</p>
</blockquote>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>go语言入门</title>
    <url>/2022/01/19/note/go%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="go语言入门"><a href="#go语言入门" class="headerlink" title="go语言入门"></a>go语言入门</h1><p>课程来自于：<a href="https://www.bilibili.com/video/BV1gf4y1r79E?from=search&amp;seid=13460338411688795952">https://www.bilibili.com/video/BV1gf4y1r79E?from=search&amp;seid=13460338411688795952</a></p>
<h2 id="1-课程提纲"><a href="#1-课程提纲" class="headerlink" title="1 课程提纲"></a>1 课程提纲</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210422181901.png" alt="image-20210422181854722"></p>
<h2 id="2-Golang开发环境"><a href="#2-Golang开发环境" class="headerlink" title="2 Golang开发环境"></a>2 Golang开发环境</h2><p><a href="https://www.runoob.com/go/go-environment.html">https://www.runoob.com/go/go-environment.html</a></p>
<p>下载golang源码：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a><br>go的bin添加到环境目录里：&#x2F;home&#x2F;oldwong&#x2F;env&#x2F;go&#x2F;bin</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210422185457.png" alt="image-20210422185457965"></p>
<p>我们选取的是go1.14.4-linux-amd64.tar.gz</p>
<h2 id="3-golang分析"><a href="#3-golang分析" class="headerlink" title="3 golang分析"></a>3 golang分析</h2><p>1 优势：可直接编译成机器码；不依赖于其他库；可以直接运行即可部署<br>2 静态语言：编译的时候可以检查出隐藏的问题<br>3 语言层面的并发：天生的基因支持并发；充分的利用多核<br>4 强大的标准库：<br>runtime系统调度机制；高效的gc垃圾回收；丰富的标准库</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210422192008.png" alt="image-20210422192008286" style="zoom: 50%;" />

<h2 id="4-第一个go语言程序"><a href="#4-第一个go语言程序" class="headerlink" title="4 第一个go语言程序"></a>4 第一个go语言程序</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span>  main   </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello Go!&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-声明变量"><a href="#5-声明变量" class="headerlink" title="5 声明变量"></a>5 声明变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gloal_a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// default a = 0</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> b <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;b=&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">100</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// type of c</span></span><br><span class="line">	fmt.Println(reflect.TypeOf(c)) </span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> bb <span class="type">string</span> = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">	fmt.Println(reflect.TypeOf(bb))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最常用的写法</span></span><br><span class="line">  <span class="comment">// 这种方式不支持全局写法</span></span><br><span class="line">	e :=<span class="number">100</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;e=&quot;</span>,e)</span><br><span class="line">	</span><br><span class="line">	fmt.Println(<span class="string">&quot;ga = &quot;</span>,gloal_a)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// many var</span></span><br><span class="line">	<span class="keyword">var</span> xx,yy <span class="type">int</span> = <span class="number">100</span>,<span class="number">200</span></span><br><span class="line">	fmt.Println(xx,yy)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-常量和iota"><a href="#6-常量和iota" class="headerlink" title="6 常量和iota"></a>6 常量和iota</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210422203308.png" alt="image-20210422203308644"></p>
<h2 id="7-函数多返回值"><a href="#7-函数多返回值" class="headerlink" title="7 函数多返回值"></a>7 函数多返回值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fool</span><span class="params">(a <span class="type">int</span>,b <span class="type">int</span>)</span></span>  (<span class="type">int</span>,<span class="type">int</span>)&#123;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	<span class="keyword">return</span> a+b,a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo2</span><span class="params">(a <span class="type">int</span>,b <span class="type">int</span>)</span></span>  (r1 <span class="type">int</span>,r2 <span class="type">int</span>)&#123;</span><br><span class="line">	r1 = <span class="number">100</span></span><br><span class="line">	r2 = a+b</span><br><span class="line">	<span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo3</span><span class="params">(a <span class="type">int</span>,b <span class="type">int</span>)</span></span> (r1,r2 <span class="type">int</span>)&#123;</span><br><span class="line">	r1 = <span class="number">1000</span></span><br><span class="line">	r2 = <span class="number">2000</span></span><br><span class="line">	<span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	</span><br><span class="line">	ret1,ret2 :=fool(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line">	fmt.Println(ret1,ret2)</span><br><span class="line"></span><br><span class="line">	ret3,ret4 :=fool(<span class="number">200</span>,<span class="number">300</span>)</span><br><span class="line">	fmt.Println(ret3,ret4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-init函数"><a href="#8-init函数" class="headerlink" title="8 init函数"></a>8 init函数</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210422204947.png" alt="image-20210422204947328"></p>
<p>在Go中，如果一个函数开头字母是大写，表明是一个公有方法，可以提供给其他类进行使用；如果开头字母是小写，表明是一个私有方法</p>
<h2 id="9-import导包"><a href="#9-import导包" class="headerlink" title="9 import导包"></a>9 import导包</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210422210224.png" alt="image-20210422210224469"></p>
<h2 id="11-defer"><a href="#11-defer" class="headerlink" title="11 defer"></a>11 defer</h2><p>defer关键字类似java中的finally，就是最终一定会执行<br>它是当前程序生命周期到最后才会执行！</p>
<ul>
<li>defer和return谁先执行？<br>return先执行，然后才是defer执行</li>
</ul>
<h2 id="12-数组和切片slice"><a href="#12-数组和切片slice" class="headerlink" title="12 数组和切片slice"></a>12 数组和切片slice</h2><p>动态数组传递的是数组的地址</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printarr</span><span class="params">(arr []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> index,value := <span class="keyword">range</span> arr&#123;</span><br><span class="line">		fmt.Println(index,value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">	printarr(arr)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态数组传递并没有传递地址，因此函数不会对数组造成修改</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> slice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printarr</span><span class="params">(arr [4]<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> index,value :=<span class="keyword">range</span> arr&#123;</span><br><span class="line">		fmt.Println(index,value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> arr1 [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	arr2 := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(arr1);i++&#123;</span><br><span class="line">		fmt.Println(arr1[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> index,value :=<span class="keyword">range</span> arr2&#123;</span><br><span class="line">		fmt.Println(index,value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printarr(arr2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-slice声明的方式"><a href="#13-slice声明的方式" class="headerlink" title="13 slice声明的方式"></a>13 slice声明的方式</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210422213550.png" alt="image-20210422213550744"></p>
<h2 id="14-slice切片的追加和截取"><a href="#14-slice切片的追加和截取" class="headerlink" title="14 slice切片的追加和截取"></a>14 slice切片的追加和截取</h2><p>追加</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210422214718.png" alt="image-20210422214718341"></p>
<p>扩容<br>如果切片在追加后，容量超过了原来的长度，那么会扩容为之前的两倍</p>
<p>切片类似于python中的截取</p>
<h2 id="15-map定义"><a href="#15-map定义" class="headerlink" title="15 map定义"></a>15 map定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> map1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> map1 <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;map is null&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	map1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">	map1[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;java&quot;</span></span><br><span class="line">	map1[<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;py&quot;</span></span><br><span class="line">	map1[<span class="string">&quot;three&quot;</span>] = <span class="string">&quot;go&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(map1)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> key,value := <span class="keyword">range</span> map1&#123;</span><br><span class="line">		fmt.Println(key,value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-map使用方式"><a href="#16-map使用方式" class="headerlink" title="16 map使用方式"></a>16 map使用方式</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210422215810.png" alt="image-20210422215809966"></p>
<h2 id="17-struct定义和使用"><a href="#17-struct定义和使用" class="headerlink" title="17 struct定义和使用"></a>17 struct定义和使用</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">type</span> myint <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span>&#123;</span><br><span class="line">	title <span class="type">string</span></span><br><span class="line">	auth <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeBook</span><span class="params">(book *Book)</span></span> &#123;</span><br><span class="line">	book.auth = <span class="string">&quot;666&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> book1 Book</span><br><span class="line">	book1.title = <span class="string">&quot;Golang&quot;</span></span><br><span class="line">	book1.auth = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">	changeBook(&amp;book1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-go中面向对象的表示和封装"><a href="#18-go中面向对象的表示和封装" class="headerlink" title="18 go中面向对象的表示和封装"></a>18 go中面向对象的表示和封装</h2><p>如果类名是字母大写，表示其他包也能访问<br>如果类的首字母大写，表示该属性对外也能够访问，否则只能在类的内部访问</p>
<p>定义对象的时候，我们绑定方法，括号里面一定要使用指针！<br>开头字母需要设置为大写，这样外部的类才可以使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Hero <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Ad <span class="type">int</span></span><br><span class="line">	Level <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Hero)</span></span> Show()  &#123;</span><br><span class="line">	fmt.Println(this.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Hero)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Hero)</span></span> SetName(newName <span class="type">string</span>)  &#123;</span><br><span class="line">	this.Name = newName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	hero := Hero&#123;Name:<span class="string">&quot;zhangsan&quot;</span>,Ad:<span class="number">100</span>,Level:<span class="number">1</span>&#125;</span><br><span class="line">	hero.Show()</span><br><span class="line">	hero.SetName(<span class="string">&quot;lisi&quot;</span>)</span><br><span class="line">	hero.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-golang中面向对象"><a href="#19-golang中面向对象" class="headerlink" title="19 golang中面向对象"></a>19 golang中面向对象</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SuperMan <span class="keyword">struct</span>&#123;</span><br><span class="line">	Human</span><br><span class="line">	level <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	h := SuperMan&#123;Human&#123;<span class="string">&quot;superman&quot;</span>,<span class="number">18</span>&#125;,<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-面向对象多态的实现"><a href="#20-面向对象多态的实现" class="headerlink" title="20 面向对象多态的实现"></a>20 面向对象多态的实现</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210423103843.png" alt="image-20210423103842953"></p>
<h2 id="21-interface空接口万能类型和类的断言机制"><a href="#21-interface空接口万能类型和类的断言机制" class="headerlink" title="21 interface空接口万能类型和类的断言机制"></a>21 interface空接口万能类型和类的断言机制</h2><p>interface{}是万能类型，可以接受各种不同类型参数的传参</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;myfunc is called&quot;</span>)</span><br><span class="line">	fmt.Println(arg)</span><br><span class="line"></span><br><span class="line">	value,ok := arg.(<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">if</span> !ok&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;arg is not string type&quot;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;arg is string type,value = &quot;</span>,value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span>&#123;</span><br><span class="line">	auth <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	book :=Book&#123;<span class="string">&quot;Golang&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	myfunc(book)</span><br><span class="line">	myfunc(<span class="number">100</span>)</span><br><span class="line">	myfunc(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-变量内置的pair结构"><a href="#22-变量内置的pair结构" class="headerlink" title="22 变量内置的pair结构"></a>22 变量内置的pair结构</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210423110812.png" alt="image-20210423110812807"></p>
<h2 id="23-golang的反射机制"><a href="#23-golang的反射机制" class="headerlink" title="23 golang的反射机制"></a>23 golang的反射机制</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210423111522.png" alt="image-20210423111522092"></p>
<h2 id="26-goroutine"><a href="#26-goroutine" class="headerlink" title="26 goroutine"></a>26 goroutine</h2><p>进程&#x2F;线程的数量越多，切换成本就越大，也就是越浪费<br>多线程开发越来越复杂，如锁、竞争</p>
<p>线程的切换需要花费过多的时间，那么我们定义一个协程，这样对CPU来说不用再次进行线程切换，可以减少开销；我们现在关注的重点就是优化协程调度器</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210423113930.png" alt="image-20210423113930911"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210423115050.png" alt="image-20210423115050531"></p>
<p>go的调度器策略</p>
<p>1 复用线程</p>
<p>working stealing机制，其他的P如果没有绑定G，会从其他地方拿一些G过来<br>hand off机制，某个协程处于阻塞状态，绑定的本地队列会被切换到其他线程上</p>
<p>2 利用并行<br>Gomaxprocs可以指定最大的线程数</p>
<p>3 抢占<br>每一个协程最多占用10ms，结束后其他协程会进行抢占</p>
<h2 id="27-创建goroutine"><a href="#27-创建goroutine" class="headerlink" title="27 创建goroutine"></a>27 创建goroutine</h2><p>Go语言最大的特色就是从语言层面支持并发（Goroutine），Goroutine是Go中最基本的执行单元。事实上每一个Go程序至少有一个Goroutine：主Goroutine。当程序启动时，它会自动创建。<br>go创建一个协程是非常方便的</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210424132945.png" alt="image-20210424132945658"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTask</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	i :=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">&quot;new task i = &quot;</span>,i)</span><br><span class="line">		time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">go</span> newTask()</span><br><span class="line"></span><br><span class="line">	i :=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">&quot;new goroutine i = &quot;</span>,i)</span><br><span class="line">		time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-channel定义和使用"><a href="#28-channel定义和使用" class="headerlink" title="28 channel定义和使用"></a>28 channel定义和使用</h2><p>两个goroutine之间如何通信交流呢？go中提供了channel来进行通信<br>我们这个距离的channel是无缓冲的</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210423160227.png" alt="image-20210423160227874"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//  define a channel</span></span><br><span class="line">	c :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;goroutine is over...&quot;</span>)</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">&quot;goroutine is running...&quot;</span>)</span><br><span class="line"></span><br><span class="line">		c &lt;- <span class="number">666</span>	<span class="comment">// 666 send to c</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	num := &lt;-c   <span class="comment">// read from c</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;num&quot;</span> , num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;main goroutine is over...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="29-channel有缓冲和无缓冲同步问题"><a href="#29-channel有缓冲和无缓冲同步问题" class="headerlink" title="29 channel有缓冲和无缓冲同步问题"></a>29 channel有缓冲和无缓冲同步问题</h2><p>无缓冲的情况</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210423161947.png" alt="image-20210423161946993"></p>
<p>有缓冲的情况</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210423161916.png" alt="image-20210423161916485"></p>
<h2 id="30-channel的关闭特点"><a href="#30-channel的关闭特点" class="headerlink" title="30 channel的关闭特点"></a>30 channel的关闭特点</h2><h2 id="31-channel与range"><a href="#31-channel与range" class="headerlink" title="31 channel与range"></a><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210423162900.png" alt="image-20210423162900952">31 channel与range</h2><p>可以用range去channel中拿数据</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210423163111.png" alt="image-20210423163111742"></p>
<h2 id="32-channel与select"><a href="#32-channel与select" class="headerlink" title="32 channel与select"></a>32 channel与select</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210423163933.png" alt="image-20210423163933040"></p>
<p>select可以监控多个channel的状态，如果chan1现在可以读取数据，那么执行第一个case；如果chan2现在可以写数据，那么执行第二个channel；如果都没有，那么执行default</p>
<p>select具有多路channel的监控功能</p>
<p>我们可以看channel写fabonacli</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacli</span><span class="params">(c ,quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	x , y :=<span class="number">1</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="keyword">select</span>&#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;-x:</span><br><span class="line">			x=y;</span><br><span class="line">			y=x+y;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++&#123;</span><br><span class="line">			fmt.Println(&lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">		quit &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	fibonacli(c,quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="33-GOPATH工作模式的弊端"><a href="#33-GOPATH工作模式的弊端" class="headerlink" title="33 GOPATH工作模式的弊端"></a>33 GOPATH工作模式的弊端</h2><p>gopath工作代码路径</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210424100841.png" alt="image-20210424100841845"></p>
<p>没有版本控制概念<br>无法同步一致第三方的版本号<br>无法指定当前项目引用的第三方版本号</p>
<h2 id="34-GoModules模式基础环境说明"><a href="#34-GoModules模式基础环境说明" class="headerlink" title="34 GoModules模式基础环境说明"></a>34 GoModules模式基础环境说明</h2><p>首先完成几个配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br></pre></td></tr></table></figure>

<p>我们要指定代理包从哪里下载,这里指定七牛云，如果我们从github上下载，会先去源进行查找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go env -w GOPROXY=http://goproxy.cn,direct</span><br></pre></td></tr></table></figure>

<p>如果这个项目是私有项目，我们导入GOPRIVATE，表明是私有仓库，不会进行proxy下载校验</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go env -w GOPRIVATE=&quot;git.example.com,github.com/aceld/zinx&quot;</span><br></pre></td></tr></table></figure>

<h2 id="35-GoModules初始化项目"><a href="#35-GoModules初始化项目" class="headerlink" title="35 GoModules初始化项目"></a>35 GoModules初始化项目</h2><p>首先开启module模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br></pre></td></tr></table></figure>

<p>首先初始化模块，后面部分是别人如果导入我们模块的名称</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210424135957.png" alt="image-20210424135957279"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210424143211.png" alt="image-20210424143211834"></p>
<h2 id="36-改变模块依赖关系"><a href="#36-改变模块依赖关系" class="headerlink" title="36 改变模块依赖关系"></a>36 改变模块依赖关系</h2>]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>topk 问题</title>
    <url>/2022/01/14/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E9%A2%98-topK/</url>
    <content><![CDATA[<h2 id="topk-问题"><a href="#topk-问题" class="headerlink" title="topk 问题"></a>topk 问题</h2><h2 id="求最大"><a href="#求最大" class="headerlink" title="求最大"></a>求最大</h2><p>快排的方式解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">kk</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] quickSortTopK(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        kk = k;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(nums, nums.length - k, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivot) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivot) i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = nums[i];</span><br><span class="line">        nums[i] = pivot;</span><br><span class="line">        <span class="keyword">if</span> (kk &gt; i) quickSort(nums, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (kk &lt; i) quickSort(nums, l, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] t = m.quickSortTopK(a, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> tt : t) &#123;</span><br><span class="line">            System.out.println(tt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆排序解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        adjustHeap(nums, i, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end == nums.length - k) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (end == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    swap(nums, <span class="number">0</span>, end - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 最大的交换到末尾了</span></span><br><span class="line">    heapSort(nums, begin, end - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; end &amp;&amp; nums[left] &gt; nums[i]) swap(nums, left, i);</span><br><span class="line">    <span class="keyword">if</span> (right &lt; end &amp;&amp; nums[right] &gt; nums[i]) swap(nums, right, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="求最小"><a href="#求最小" class="headerlink" title="求最小"></a>求最小</h2><p>快排</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">return</span> quickSortTopK(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] quickSortTopK(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> Arrays.copyOfRange(arr, <span class="number">0</span>, k);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[l];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[l] = arr[i];</span><br><span class="line">        arr[i] = pivot;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; i) <span class="keyword">return</span> quickSortTopK(arr, l, i - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; i) <span class="keyword">return</span> quickSortTopK(arr, i + <span class="number">1</span>, r, k);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(arr, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">9</span>, <span class="number">33</span>, <span class="number">73</span>, <span class="number">10</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] x = t.getLeastNumbers(a, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : x) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>Redis设计与实现-读书笔记</title>
    <url>/2022/01/12/note/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Redis设计与实现-读书笔记"><a href="#Redis设计与实现-读书笔记" class="headerlink" title="Redis设计与实现-读书笔记"></a>Redis设计与实现-读书笔记</h1><h2 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h2><p>​	字符串对象、列表对象、哈希对象、集合对象、有序集合对象这五个基本类型的对象<br>​	前面我们介绍了简单动态字符串(SDS)、双端链表、字典、压缩列表、整数集合，对象都是由这些基本数据结构构成的<br>​	Redis的对象系统实现了基于引用计数的内存回收机制，当程序不使用某个对象的时候，这个对象占用的内存就会被自动释放<br>​	Redis使用对象表示数据库中的键和值，每当我们创建一个键值对象的时候，我们至少创建两个对象，一个是键对象，一个是值对象</p>
<h3 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h3><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406102137.png" alt="image-20210406102130376" style="zoom: 33%;" />

<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406102331.png" alt="image-20210406102331192"></p>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码可以使用ziplist或者是linkedlist<br>ziplist对象底层使用压缩列表作为底层实现</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406102838.png" alt="image-20210406102838386"></p>
<p>linkedlist编码的列表对象使用双端队列作为底层实现，每个双端链表的节点都保存了一个字符串对象，而每个字符串对象都保存了一个列元素。</p>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是ziplist或者是hashtable<br>使用hashtable编码的哈希对象底层是通过字典作为实现</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406103421.png" alt="image-20210406103421012" style="zoom:33%;" />

<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象的底层实现可以是字典或者intset</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406103613.png" alt="image-20210406103613000" style="zoom: 33%;" />

<h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406103808.png" alt="image-20210406103808015"></p>
<p>redis的跳跃表底层实现是综合了字典和跳跃表两个结构实现的</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406103909.png" alt="image-20210406103909024" style="zoom: 33%;" />

<h2 id="跳表的底层实现"><a href="#跳表的底层实现" class="headerlink" title="跳表的底层实现"></a>跳表的底层实现</h2><p>跳跃表是一种有序的数据结构，通过在每个结点维持多个指向其他结点的指针，从而达到快速访问结点的目的<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406111807.png" alt="image-20210406111807410"></p>
<p>关于层的高度</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406111939.png" alt="image-20210406111939089"></p>
<h2 id="字典｜hash的底层实现"><a href="#字典｜hash的底层实现" class="headerlink" title="字典｜hash的底层实现"></a>字典｜hash的底层实现</h2><p>字典的底层实现</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406104357.png" alt="image-20210406104357369" style="zoom:50%;" />

<p>ht是一个包含两项的数组，每一项都是一个哈希表，一般情况下字典只使用h[0]哈希表，h[1]哈希表只会进行rehash的时候使用</p>
<p>哈希算法</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406110741.png" alt="image-20210406110741833" style="zoom: 50%;" />

<p>采用链表法解决了hash冲突</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>​		随着不断的向哈希表中加入元素，为了减轻哈希表的负载因子维持在合理的区间内，当保存的键值对太多或者太少的时候，需要对哈希表的大小进行扩展或者收缩。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210406111126.png" alt="image-20210406111126852"></p>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临的时候，立即对键执行删除操作<br>惰性删除：放任过期的键不管，但每次从键空间获取键时，就判断是否过期，过期了就删除，不过期就返回<br>定期删除：每隔一段时间，就对数据库进行一遍检查，删除过期的键</p>
<p>我们考虑两个方面，CPU友好还是对内存空间友好</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>1 redis服务器将所有的数据都保存在服务器状态的redisServer结构的db数组中，默认情况下redis有16个数据库</p>
]]></content>
      <categories>
        <category>web后端</category>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络-小林coding读书笔记</title>
    <url>/2022/01/05/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络-小林coding读书笔记"><a href="#计算机网络-小林coding读书笔记" class="headerlink" title="计算机网络-小林coding读书笔记"></a>计算机网络-小林coding读书笔记</h1><p>小林coding微信公众号可以下载pdf</p>
<h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220703113007143.png" alt="image-20220703113007143"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</span><br><span class="line"></span><br><span class="line">2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</span><br><span class="line">「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</span><br><span class="line">「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</span><br><span class="line">「206 Partial Content」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</span><br><span class="line"></span><br><span class="line">3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。</span><br><span class="line">「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</span><br><span class="line">「302 Moved Permanently」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</span><br><span class="line">301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</span><br><span class="line">「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</span><br><span class="line"></span><br><span class="line">4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</span><br><span class="line">「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</span><br><span class="line">「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</span><br><span class="line">「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</span><br><span class="line"></span><br><span class="line">5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</span><br><span class="line">「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</span><br><span class="line">「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</span><br><span class="line">「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</span><br><span class="line">「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</span><br></pre></td></tr></table></figure>

<h3 id="http常见的字段"><a href="#http常见的字段" class="headerlink" title="http常见的字段"></a>http常见的字段</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409143422.jpg" alt="wKiom1MphduAsu6XAAM_loPLbc0713.jpg"></p>
<p>get|post、host、keep-alive、user-agent、accept-encoding、accept-language、accept</p>
<h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h3><p><code>Get</code> 方法的含义是请求<strong>从服务器获取资源</strong>，这个资源可以是静态的文本、页面、图片视频等。而<code>POST</code> 方法则是相反操作，它向 <code>URI</code> 指定的资源提交数据，数据就放在报文的 body 里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先说明下安全和幂等的概念：</span><br><span class="line"></span><br><span class="line">在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</span><br><span class="line"></span><br><span class="line">所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</span><br><span class="line"></span><br><span class="line">那么很明显 GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</span><br><span class="line"></span><br><span class="line">POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</span><br></pre></td></tr></table></figure>

<h3 id="http的缺点"><a href="#http的缺点" class="headerlink" title="http的缺点"></a>http的缺点</h3><p>1 无状态协议，比如说网上购物，解决方法就是采用cookie技术，记录用户登录的状态<br>2 明文传输并不安全，不验证通信方的身份，因此有可能遭遇伪装。无法证明报文的完整性，所以有可能已遭篡改。HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL&#x2F;TLS 层，使得在安全上达到了极致。</p>
<h3 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h3><h3 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h3><ol>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ol>
<h3 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h3><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220703113021691.png" alt="image-20220703113021691"></p>
<h3 id="HTTPS-是如何解决上面的三个风险的？"><a href="#HTTPS-是如何解决上面的三个风险的？" class="headerlink" title="HTTPS 是如何解决上面的三个风险的？"></a>HTTPS 是如何解决上面的三个风险的？</h3><ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：</span><br><span class="line">在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</span><br><span class="line">在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</span><br><span class="line"></span><br><span class="line">采用「混合加密」的方式的原因：</span><br><span class="line">对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</span><br><span class="line">非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</span><br></pre></td></tr></table></figure>

<h3 id="数字证书CA"><a href="#数字证书CA" class="headerlink" title="数字证书CA"></a>数字证书CA</h3><p>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。<br>这就存在些问题，如何保证公钥不被篡改和信任度？<br>所以这里就需要借助第三方权威机构 <code>CA</code> （数字证书认证机构），将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409145754.png" alt="image-20210409145754732"></p>
<p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</p>
<p>其实说白了，就是CA可信第三方用自己的私钥给服务器的公钥进行加密，然后颁发一个数字证书，而每个人都可以获取CA的公钥（因为CA的公钥内置在浏览器或者服务器中）</p>
<h3 id="HTTPS-是如何建立连接的？"><a href="#HTTPS-是如何建立连接的？" class="headerlink" title="HTTPS  是如何建立连接的？"></a>HTTPS  是如何建立连接的？</h3><p>SSL&#x2F;TLS 协议基本流程：</p>
<ul>
<li>客户端向服务器索要并验证服务器的公钥。</li>
<li>双方协商生产「会话秘钥」。</li>
<li>双方采用「会话秘钥」进行加密通信。</li>
</ul>
<p>前两步也就是 SSL&#x2F;TLS 的建立过程，也就是握手阶段。</p>
<p>SSL&#x2F;TLS 协议建立的详细流程：</p>
<p><em>1. ClientHello</em></p>
<p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。</p>
<p>在这一步，客户端主要向服务器发送以下信息：</p>
<p>（1）客户端支持的 SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本。</p>
<p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生产「会话秘钥」。</p>
<p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p>
<p><em>2. SeverHello</em></p>
<p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code>。服务器回应的内容有如下内容：</p>
<p>（1）确认 SSL&#x2F; TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p>
<p>（2）服务器生产的随机数（<code>Server Random</code>），后面用于生产「会话秘钥」。</p>
<p>（3）确认的密码套件列表，如 RSA 加密算法。</p>
<p>（4）服务器的数字证书。</p>
<p><em>3.客户端回应</em></p>
<p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p>
<p>如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</p>
<p>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p>
<p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p>
<p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p>
<p>上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，<strong>各自生成</strong>本次通信的「会话秘钥」。</p>
<p><em>4. 服务器的最后回应</em></p>
<p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：</p>
<p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p>
<p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p>
<p>至此，整个 SSL&#x2F;TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p>
<h2 id="浏览器输入地址后，发生了什么？"><a href="#浏览器输入地址后，发生了什么？" class="headerlink" title="浏览器输入地址后，发生了什么？"></a>浏览器输入地址后，发生了什么？</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409154829.png" alt="image-20210409154829511"></p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>1 浏览器第一步做的事解析URL，对URL进行解析，从而生成发送给Web服务器的请求信息</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409155048.png" alt="image-20210409155048795"></p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>2 浏览器解析URL生成HTTP消息后，需要委托操作系统将消息发送给web服务器<br>但发送前，我们还需要获取域名对应的IP地址，这个时候我们需要请求DNS服务器<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409155519.png" alt="image-20210409155519698"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409155553.png" alt="image-20210409155553399"></p>
<h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><p>3 DNS解析得到IP后，我们就可以把HTTP传输工作交给操作系统中的协议栈。</p>
<p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409155942.png" alt="image-20210409155942881" style="zoom:50%;" />

<p>​		应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，它们两会接受应用层的委托执行收发数据的操作。</p>
<p>​		协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p>
<p>​		此外 IP 中还包括 ICMP 协议和 ARP 协议。ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。</p>
<p>​		IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>4 HTTP 是基于 TCP 协议传输的，那么根据上面的图，先进行TCP的三次握手连接，进行在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。</p>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>5 远程定位IP，TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。此时生成了IP报文</p>
<h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><p>6 生成MAC头部。生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC</strong> <strong>头部</strong>。 </p>
<p><strong>发送方</strong>的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p>
<p><strong>接收方</strong>的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。</p>
<p>那么如何获取mac地址呢？<br>此时就需要 ARP 协议帮我们找到路由器的 MAC 地址。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409161033.png" alt="image-20210409161033045" style="zoom:50%;" />

<p>ARP 协议会在以太网中以<strong>广播</strong>的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的MAC 地址告诉我”。</p>
<p>然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。</p>
<p>显然，为了防止每次都需要发送广播，我们设置了ARP缓存机制<br>此时这个报文的组成MAC头部 &#x3D;&gt; IP头部 &#x3D;&gt; TCP头部 &#x3D;&gt; HTTP报文</p>
<h3 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h3><p>IP 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p>
<p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。网卡驱动从 IP 模块获取到包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。最后网卡会将包转为电信号，通过网线发送出去。</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>下面来看一下包是如何通过交换机的。交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在MAC 层，也称为<strong>二层网络设备</strong>。<strong>交换机根据</strong> <strong>MAC</strong> <strong>地址表查找</strong> <strong>MAC</strong> <strong>地址，然后将信号发送到相应的端口</strong>。</p>
<blockquote>
<p>如果此时mac地址表找不到指定的mac地址怎么办？</p>
</blockquote>
<p>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p>
<p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>​		网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p>
<p>​		检查 MAC 头部中的<strong>接收方</strong> <strong>MAC</strong> 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</p>
<p>​		完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。<strong>MAC</strong> <strong>头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409162446.png" alt="image-20210409162446673" style="zoom:50%;" />

<p>知道对方的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p>
<p>下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p>
<p>不知你发现了没有，在网络包传输的过程中，<strong>源</strong> <strong>IP</strong> <strong>和目标</strong> <strong>IP</strong> <strong>始终是不会变的，一直变化的是</strong> <strong>MAC</strong> <strong>地</strong> 址<strong>，因为需要 MAC 地址在以太网内进行</strong>两个设备之间的包传输。</p>
<h3 id="互相扒皮"><a href="#互相扒皮" class="headerlink" title="互相扒皮"></a>互相扒皮</h3><p>数据包抵达了服务器，服务器肯定高兴呀，正所谓有朋自远方来，不亦乐乎？服务器高兴的不得了，于是开始扒数据包的皮！就好像你收到快递，能不兴奋吗？</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409163403.png" alt="image-20210409163403047"></p>
<p>数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。<br>接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。<br>。。。。<br>于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。</p>
<h3 id="路由转发的说明"><a href="#路由转发的说明" class="headerlink" title="路由转发的说明"></a>路由转发的说明</h3><p>mac地址经过路由或路由主机是都是发生改变的，源发送主机是不知道目的主机的MAC地址的，但是知道IP。而Ｐ地址一般是不会发生变化的。网上有一幅图很好的表明了这个规则</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409163850.png" alt="image-20210409163850107"></p>
<h2 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h2><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><p>面向连接：一定是一对一才能连接，不像UDP可以一对多进行连接<br>可靠：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；<br>基于字节流的传输协议</p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>1 连接：TCP是面向连接的传输协议，传输数据前需要建立连接；UDP不需要建立连接<br>2 服务对象：TCP是一对一的两点服务，UDP是一对多的服务<br>3 可靠性：TCP保证连接的可靠性，UDP尽最大可能进行交付<br>4 拥塞控制和流量控制：TCP具有拥塞控制，UDP没有<br>5 分片大小不同：TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：<br>FTP 文件传输；HTTP &#x2F; HTTPS</p>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：包总量较少的通信，如 DNS 、 SNMP 等；视频、音频等多媒体通信；广播通信</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>tcp是面向连接的协议，所以使用TCP连接的时候必须先建立连接</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409204015.png" alt="image-20210409204015706" style="zoom:50%;" />

<p>从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的，这也是面试常问的题。</p>
<p>1 客户端和服务器都处于close状态，显示服务器主动监听某个端口，处于listen状态<br>2 客户端向服务器发送序列号client_num，SYN &#x3D; 1的TCP报文，此时客户端处于SYN_SENT状态，服务器端接受报文处于SYN_RECEIVE状态<br>3 服务器向客户端发送SYN&#x3D;1，ACK&#x3D;1，ack &#x3D; client_num+1,seq &#x3D; server_num的报文<br>4 客户端处于established状态，发送ACK&#x3D;1,ack &#x3D; server_num+1的报文，客户端服务器端连接建立</p>
<h3 id="为什么三次握手，不是两次或者四次"><a href="#为什么三次握手，不是两次或者四次" class="headerlink" title="为什么三次握手，不是两次或者四次"></a>为什么三次握手，不是两次或者四次</h3><p>比较常见的回答是因为三次握手才能保证双方具有接受和发送的能力<br>这个回答是片面的，其实参考一些官方文档上写的，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409210401.png" alt="image-20210409210401147"></p>
<p>客户端连续发送多次 SYN 建立连接的报文，在<strong>网络拥堵</strong>情况下：<br>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</p>
<p>那么此时服务端就会回一个 SYN + ACK 报文给客户端；<br>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</p>
<p>我个人的理解是服务器没法通过两次握手确定客户端是否收到正确的报文</p>
<h3 id="什么是SYN攻击，如何避免"><a href="#什么是SYN攻击，如何避免" class="headerlink" title="什么是SYN攻击，如何避免"></a>什么是SYN攻击，如何避免</h3><p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入 SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会<strong>占满服务端的</strong> <strong>SYN</strong> <strong>接收队列（未连接队列）</strong>，使得服务器不能为正常用户服务。</p>
<p>解决方案：</p>
<p>1 超出处理能时，对新的 SYN 直接回报 RST，丢弃连接<br>2 采用syn_cookie的方法，如果此时队列还没有满，就正常的进行三次握手，如果队列满了，启动syn cookie方法</p>
<p>当 SYN 队列满之后，后续服务器收到 SYN 包，不进入SYN 队列；<br>计算出一个 cookie 值，再以 SYN + ACK 中的序列号返回客户端，<br>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到<br>Accept 队列。<br>最后应用通过调用 accpet() socket 接口，从Accept 队列取出的连接。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409212454.png" alt="image-20210409212454674" style="zoom: 33%;" />

<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409212639.png" alt="image-20210409212639466" style="zoom:50%;" />

<h3 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409212807.png" alt="image-20210409212807364"></p>
<h3 id="为什么需要等待2MSL"><a href="#为什么需要等待2MSL" class="headerlink" title="为什么需要等待2MSL"></a>为什么需要等待2MSL</h3><p>MSL 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。<br>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待</strong> <strong>2</strong> <strong>倍的时间</strong>。</p>
<p>比如如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。 </p>
<p>等待MSL的作用就是可以保证连接的关闭</p>
<h3 id="Time-wait过多的危害"><a href="#Time-wait过多的危害" class="headerlink" title="Time_wait过多的危害"></a>Time_wait过多的危害</h3><p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<p>第一是内存资源占用；<br>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；</p>
<p>第二个危害是会造成严重的后果的，要知道，端口资源也是有限的，一般可以开启的端口为 32768～ 61000 ，也可以通过如下参数设置指定</p>
<h3 id="TCP重传"><a href="#TCP重传" class="headerlink" title="TCP重传"></a>TCP重传</h3><p>超时重传机制：重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409214313.png" alt="image-20210409214313644"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409214341.png" alt="image-20210409214341133"></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，<strong>TCP</strong> 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>​		在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大</p>
<p>​		其实只要发送方没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了用拥塞。</p>
<p>​		<strong>拥塞窗口</strong> <strong>cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p><img src="E:/house/typora/img/20210409215604.png" alt="image-20210409215604842"></p>
<p>​		拥塞控制主要有四个算法：慢启动、拥塞避免、拥塞发生、快速恢复<br>​		进入拥塞避免算法后，它的规则是：每当收到一个ACK 时，cwnd 增加1&#x2F;cwnd。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210409215103.png" alt="image-20210409215103522"></p>
<h3 id="TCP沾包"><a href="#TCP沾包" class="headerlink" title="TCP沾包"></a>TCP沾包</h3><p>发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</p>
<p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p>
<p>（1）发送方原因</p>
<p>TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：</p>
<p>只有上一个分组得到确认，才会发送下一个分组<br>收集多个小分组，在一个确认到来时一起发送<br>Nagle算法造成了发送方可能会出现粘包问题</p>
<p>（2）接收方原因</p>
<p>TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p>
<p>接受方没有办法解决沾包问题，需要交给上层的应用层进行解决，<br>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。</p>
]]></content>
      <categories>
        <category>web后端</category>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx-狂神说Java</title>
    <url>/2021/12/29/note/Nginx%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Nginx-狂神说Java"><a href="#Nginx-狂神说Java" class="headerlink" title="Nginx-狂神说Java"></a>Nginx-狂神说Java</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/hellokuangshen/p/14334300.html">https://www.cnblogs.com/hellokuangshen/p/14334300.html</a></p>
<p><a href="https://www.bilibili.com/video/BV1F5411J7vK?p=7">https://www.bilibili.com/video/BV1F5411J7vK?p=7</a></p>
<p>nginx反向代理、负载均衡（不同的服务器根据负载能力进行不同的权重分配）</p>
<p>于是我们横向扩展，又增加了服务器。这个时候几个项目启动在不同的服务器上，用户要访问，就需要增加一个代理服务器了，通过代理服务器来帮我们转发和处理请求。</p>
 <img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210217145726.png" alt="img" style="zoom:67%;" />

<p>​	我们希望这个代理服务器可以帮助我们接收用户的请求，然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的，用户并不知道是哪个服务器返回的结果，我们还希望他可以按照服务器的性能提供不同的权重选择。保证最佳体验！所以我们使用了Nginx。</p>
<p>​	Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7<em>24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。*<em>Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。</em></em></p>
<h2 id="Nginx作用"><a href="#Nginx作用" class="headerlink" title="Nginx作用"></a>Nginx作用</h2><p>正向代理是代理客户端的，比如挂vpn访问外网<br>反向代理是代理服务器的，客户对服务器的扩容没有感知</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的。</p>
<p>iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210217150407.png" alt="img"></p>
<blockquote>
<p>动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。</p>
</blockquote>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210217150417.png" alt="img"></p>
<p>目前，通过使用Nginx大大提高了我们网站的响应速度，优化了用户体验，让网站的健壮性更上一层楼！</p>
<h2 id="Linux环境下安装"><a href="#Linux环境下安装" class="headerlink" title="Linux环境下安装"></a>Linux环境下安装</h2><p>我们可以看nginx开发的默认端口80</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210217151620.png" alt="image-20210217151620644"></p>
<h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/sbin/</span><br><span class="line">./nginx  启动</span><br><span class="line">./nginx -s stop  停止</span><br><span class="line">./nginx -s quit  安全退出</span><br><span class="line">./nginx -s reload  重新加载配置文件</span><br><span class="line">ps aux|grep nginx  查看nginx进程</span><br></pre></td></tr></table></figure>

<p>启动成功访问 服务器ip:80 </p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210217151713.png" alt="img"></p>
<p>注意：如何连接不上，检查阿里云安全组是否开放端口，或者服务器防火墙是否开放端口！<br>相关命令：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 开启</span></span><br><span class="line">service firewalld start</span><br><span class="line"><span class="meta"># 重启</span></span><br><span class="line">service firewalld restart</span><br><span class="line"><span class="meta"># 关闭</span></span><br><span class="line">service firewalld stop</span><br><span class="line"><span class="meta"># 查看防火墙规则</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="meta"># 查询端口是否开放</span></span><br><span class="line">firewall-cmd --query-port=<span class="number">8080</span>/tcp</span><br><span class="line"><span class="meta"># 开放80端口</span></span><br><span class="line">firewall-cmd --permanent --<span class="keyword">add</span>-port=<span class="number">80</span>/tcp</span><br><span class="line"><span class="meta"># 移除端口</span></span><br><span class="line">firewall-cmd --permanent --<span class="keyword">remove</span>-port=<span class="number">8080</span>/tcp</span><br><span class="line"></span><br><span class="line"><span class="meta">#重启防火墙(修改配置后要重启防火墙)</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="meta"># 参数解释</span></span><br><span class="line"><span class="number">1</span>、firwall-cmd：是Linux提供的操作firewall的一个工具；</span><br><span class="line"><span class="number">2</span>、--permanent：表示设置为持久；</span><br><span class="line"><span class="number">3</span>、--<span class="keyword">add</span>-port：标识添加的端口；</span><br></pre></td></tr></table></figure>

<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>我们进入nginx.conf进入配置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 负载均衡配置</span></span><br><span class="line">upstream kuangstudy&#123;</span><br><span class="line">    server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> weight=<span class="number">1</span>;</span><br><span class="line">    server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8081</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问根目录下/的请求，代理到lb去</span></span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http:<span class="comment">//kuangstudy;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>ElasticSearch教程</title>
    <url>/2021/12/15/note/ElasticSearch%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="ElasticSearch教程"><a href="#ElasticSearch教程" class="headerlink" title="ElasticSearch教程"></a>ElasticSearch教程</h1><p><a href="https://blog.csdn.net/lisen01070107/article/details/108288037">https://blog.csdn.net/lisen01070107/article/details/108288037</a></p>
<p>版本：ElasticSearch7.6.1（全网最新）<br>6.x和7.x的区别十分大，6.x的API（原生API、restful高级）</p>
<blockquote>
<p>我们要讲解什么</p>
</blockquote>
<p>SQL： like %狂神说%，如果是大数据就非常慢！索引！<br>ElasticSearch：搜索（百度，淘宝，电商）</p>
<p>1、聊一个人<br>2、货比三家<br>3、安装<br>4、生态圈<br>5、分词器IK<br>6、restful操作ES<br>7、CRUD<br>8、SpringBoot集成ES<br>9、爬虫爬取数据<br>10、实战，模拟全文检索</p>
<p>以后项用到搜索，就可以使用ES（大数据情况）</p>
<p><strong>ELK(ElasticSearch, Logstash, Kibana)是一个综合平台</strong></p>
<p>Elasticsearch：实时全文搜索和分析引擎，提供搜集、分析、存储数据三大功能Logstash：日志收集，分析，过滤并转化到对应的存储库<br>Kibana：一个基于Web的图形界面，用于搜索、分析和可视化存储在 Elasticsearch指标中的日志数据</p>
<h2 id="ElasticSearch概述"><a href="#ElasticSearch概述" class="headerlink" title="ElasticSearch概述"></a>ElasticSearch概述</h2><p>ES是一个开源的高扩展的分布式全文检索引擎，近乎实时的搜索，检索数据<br>ElasticSearch是基于<strong>Lucene</strong>作为核心，做了一些分装和增强<br>它的目的是通过简单的<strong>RESTFUL</strong>风格的API来隐藏Lucence的复杂性，使得全文搜索变得简单<br><strong>全文搜索、结构化搜索、分析</strong></p>
<h2 id="ES和Solr的差别"><a href="#ES和Solr的差别" class="headerlink" title="ES和Solr的差别"></a>ES和Solr的差别</h2><p>单纯的对已有的数据进行搜索的话，Solr速度更快</p>
<p>一旦建立了索引，solr会进行IO阻塞，此时ES速度更快</p>
<p>随着数据的增加，solr效率变低，ES速度还是很快</p>
<p>ES开箱即用，非常简单（解压就可以使用了），solr速度比较慢</p>
<h2 id="ES安装"><a href="#ES安装" class="headerlink" title="ES安装"></a>ES安装</h2><p>JDK1.8，最低要求！ElasticSearch客户端，界面工具！</p>
<p>Java开发，ES的版本和我们之后对应的Java的核心jar包！版本对应！JDK环境正常</p>
<p>官网：<a href="https://www.elastic.co/cn/">https://www.elastic.co/cn/</a></p>
<p>下载：<a href="https://www.elastic.co/cn/downloads/">https://www.elastic.co/cn/downloads/</a></p>
<p>我们这里现在windows下学习<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210119112631.png" alt="image-20210119112631647" style="zoom:67%;" /></p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210119112732.png" alt="image-20210119112732645" style="zoom:67%;" />

<h2 id="可视化界面ES-head"><a href="#可视化界面ES-head" class="headerlink" title="可视化界面ES head"></a>可视化界面ES head</h2><p>没有前端基础的，先去看我的vue</p>
<p>现将ES head解压，然后启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure>

<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210119114006.png" alt="image-20210119114006895"></p>
<p>连接测试，发现存在跨域问题，配置es</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210119142145.png" alt="image-20210119142145476" style="zoom:67%;" />

<p>重启es服务器，测试连接访问</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210119142241.png" alt="image-20210119142241418" style="zoom:67%;" />

<p>你就把索引当做一个数据库！（表：文档）</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210119142653.png" alt="image-20210119142653810"></p>
<blockquote>
<p>这个head我们就把他当做数据展示工具！我们后面所有的查询，Kibana来做</p>
</blockquote>
<h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p><a href="https://www.elastic.co/cn/kibana">https://www.elastic.co/cn/kibana</a></p>
<p>ELK(ElasticSearch, Logstash, Kibana)是一个综合平台</p>
<p>Kibana 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行可视化，并让您在 Elastic Stack 中进行导航。您可以进行各种操作，从跟踪查询负载，到理解请求如何流经您的整个应用，都能轻松完成。</p>
<p>ELK基本上都是拆箱及用</p>
<p>1、解压后端的目录</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210119144628.png" alt="image-20210119144628275"></p>
<p>2、开启运行</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210119150450.png" alt="image-20210119150450206" style="zoom:67%;" />

<p>3、打开网页<a href="http://localhost:5601/">http://localhost:5601/</a></p>
<p>4、打开开发工具</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210119150848.png" alt="image-20210119150848682" style="zoom:67%;" />

<h2 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">集群，节点，索引，类型，文档，分片，映射是什么？</span><br></pre></td></tr></table></figure>

<p>索引、类型(Mapping)、文档(documents)</p>
<blockquote>
<p>elasticsearch是面向文档，关系型数据库和elasticsearch客观的对比！一切都是json</p>
</blockquote>
<table>
<thead>
<tr>
<th>Relational DB</th>
<th>Elasticsearch</th>
</tr>
</thead>
<tbody><tr>
<td>数据库（database）</td>
<td>索引（indices）</td>
</tr>
<tr>
<td>表（tables）</td>
<td>types</td>
</tr>
<tr>
<td>行（rows）</td>
<td>documents</td>
</tr>
<tr>
<td>字段（columns）</td>
<td>fields</td>
</tr>
</tbody></table>
<p>物理设计：</p>
<p>elasticsearch在后台把每个索引划分成多个分片。每个分片可以在集群中的不同服务器间迁移</p>
<p>逻辑设计：</p>
<p>一个索引类型中，包含多个文档，当我们索引一篇文档时，可以通过这样的一个顺序找到它：索引-》类型-》文档id，通过这个组合我们就能索引到某个具体的文档。注意：<code>ID不必是整数，实际上它是一个字符串。</code></p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>一个document就是index中的一条记录，它是JSON格式的，就是我们的一条条的记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user</span><br><span class="line">1 zhangsan 18</span><br><span class="line">2 kuangshen 3</span><br></pre></td></tr></table></figure>

<p>之前说elasticsearch是面向文档的,那么就意味着索弓和搜索数据的最小单位是文档, elasticsearch中,文档有几个重要属性:</p>
<ul>
<li>自我包含, - -篇文档同时包含字段和对应的值,也就是同时包含key:value !</li>
<li>可以是层次型的，一个文档中包含自文档,复杂的逻辑实体就是这么来的! {就是一 个json对象! fastjson进行自动转换!}</li>
<li>灵活的结构,文档不依赖预先定义的模式,我们知道关系型数据库中,要提前定义字段才能使用,在elasticsearch中,对于字段是非常灵活的,有时候,我们可以忽略该字段,或者动态的添加一个新的字段。</li>
</ul>
<p>尽管我们可以随意的新增或者忽略某个字段,但是,每个字段的类型非常重要,比如一一个年龄字段类型,可以是字符串也可以是整形。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型,这也是为什么在elasticsearch中,类型有时候也称为映射类型。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>类型是文档的逻辑容器,就像关系型数据库一样,表格是行的容器。类型中对于字段的定 义称为映射,比如name映射为字符串类型。我们说文档是无模式的 ,它们不需要拥有映射中所定义的所有字段,比如新增一个字段,那么elasticsearch是怎么做的呢?elasticsearch会自动的将新字段加入映射,但是这个字段的不确定它是什么类型, elasticsearch就开始猜,如果这个值是18 ,那么elasticsearch会认为它是整形。但是elasticsearch也可能猜不对 ，所以最安全的方式就是提前定义好所需要的映射,这点跟关系型数据库殊途同归了,先定义好字段,然后再使用,别整什么幺蛾子。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>就是数据库!</p>
<p>索引是映射类型的容器, elasticsearch中的索引是一个非常大的文档集合。索|存储了映射类型的字段和其他设置。然后它们被存储到了各个分片上了。我们来研究下分片是如何工作的。</p>
<p><strong>物理设计:节点和分片如何工作</strong></p>
<p>一个集群至少有一个节点,而一个节点就是一个ElasticSearch进程 ,节点可以有多个索引默认的,如果你创建索引,那么索引将会有个5个分片( primary shard ,又称主分片)构成的,每一个主分片会有一个副本( replica shard ,又称复制分片）</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20200828224136138.png" alt="在这里插入图片描述" style="zoom:67%;" />

<p>上图是一个有3个节点的集群,可以看到主分片和对应的复制分片都不会在同一个节点内,这样有利于某个节点挂掉了,数据也不至于丢失。&#x3D;&#x3D;实际上, 一个分片是一个Lucene索引,一个包含倒排索引的文件目录,倒排索引的结构使得elasticsearch在不扫描全部文档的情况下,就能告诉你哪些文档包含特定的关键字。&#x3D;&#x3D;不过,等等,倒排索引是什么鬼?</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>elasticsearch使用的是一种称为倒排索引的结构,采用Lucene倒排索作为底层。这种结构适用于快速的全文搜索，一个索引由文档中所有不重复的列表构成,对于每一个词,都有一个包含它的文档列表。 例如,现在有两个文档，每个文档包含如下内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Study every day， good good up to forever  # 文档1包含的内容</span><br><span class="line">To forever, study every day，good good up  # 文档2包含的内容</span><br></pre></td></tr></table></figure>

<p>为为创建倒排索引,我们首先要将每个文档拆分成独立的词(或称为词条或者tokens) ,然后创建一一个包含所有不重复的词条的排序列表,然后列出每个词条出现在哪个文档:</p>
<table>
<thead>
<tr>
<th>term</th>
<th>doc_1</th>
<th>doc_2</th>
</tr>
</thead>
<tbody><tr>
<td>Study</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>To</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>every</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>forever</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>day</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>study</td>
<td>x</td>
<td>√</td>
</tr>
<tr>
<td>good</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>every</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>to</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>up</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>现在，我们试图搜索 to forever，只需要查看包含每个词条的文档</p>
<table>
<thead>
<tr>
<th>term</th>
<th>doc_1</th>
<th>doc_2</th>
</tr>
</thead>
<tbody><tr>
<td>to</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>forever</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>total</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>两个文档都匹配,但是第一个文档比第二个匹配程度更高。如果没有别的条件,现在,这两个包含关键字的文档都将返回。<br>再来看一个示例,比如我们通过博客标签来搜索博客文章。那么倒排索引列表就是这样的一个结构:</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210120153525.png" alt="image-20210120153525139"></p>
<p>如果要搜索含有python标签的文章,那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要查看标签这一栏,然后获取相关的文章ID即可。完全过滤掉无关的所有数据,提高效率!</p>
<ul>
<li>elasticsearch的索引和Lucene的索引对比</li>
</ul>
<p>在elasticsearch中，索引(库)这个词被频繁使用,这就是术语的使用。在elasticsearch中 ,索引被分为多个分片,每份分片是一个Lucene的索引。<strong>所以一个elasticsearch索引是由多个Lucene索引组成的</strong>。别问为什么,谁让elasticsearch使用Lucene作为底层呢!如无特指，说起索引都是指elasticsearch的索引。</p>
<p>接下来的一切操作都在kibana中Dev Tools下的Console里完成。基础操作!</p>
<h2 id="ik分词器"><a href="#ik分词器" class="headerlink" title="ik分词器"></a>ik分词器</h2><blockquote>
<p>什么是IK分词器 ?</p>
</blockquote>
<p>分词:即把一段中文或者别的划分成一个个的关键字,我们在搜索时候会把自己的信息进行分词,会把数据库中或者索引库中的数据进行分词,然后进行一个匹配操作,默认的中文分词是将每个字看成一个词,比如“我爱狂神”会被分为”我”,“爱”,“狂”,“神” ,这显然是不符合要求的,所以我们需要安装中文分词器ik来解决这个问题。</p>
<p>如果要使用中文,建议使用ik分词器!这个是一个标准的中文分词器</p>
<p>IK提供了两个分词算法: <strong>ik_ smart和ik_ max_ word</strong> ,其中ik_ smart为最少切分, ik_ max_ _word为最细粒度划分!一会我们测试!</p>
<p>什么是IK分词器：</p>
<ul>
<li>把一句话分词</li>
<li>如果使用中文：推荐IK分词器</li>
<li>两个分词算法：ik_smart（最少切分），ik_max_word（最细粒度划分）</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>放到plugins这个位置</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210120160128.png" alt="image-20210120160127983" style="zoom:67%;" />

<p>重启观察ES，可以看到ik分词器被加载了</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210120160104.png" alt="image-20210120160104904"></p>
<p>最细粒度划分</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210120161112.png" alt="image-20210120161112155"></p>
<p>穷尽拆分</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210120161134.png"></p>
<p>发现问题：狂神说被拆开了</p>
<p>这种自己需要的词，需要自己加到我们的分词器的字典中！<br>分词器字典需要我们自己配置</p>
<p>新建一个自己的字典<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210120161748.png" alt="image-20210120161748488" style="zoom:67%;" /></p>
<p>在配置文件中添加</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210120161918.png" alt="image-20210120161912761" style="zoom:67%;" />

<p>重启es，再次测试狂神说</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210120162208.png" alt="image-20210120162208143"></p>
<p>以后的话我们需要自己配置分词文件</p>
<h2 id="Rest风格说明"><a href="#Rest风格说明" class="headerlink" title="Rest风格说明"></a>Rest风格说明</h2><p>一种软件架构风格，而不是标准。更易于实现缓存等机制</p>
<table>
<thead>
<tr>
<th>method</th>
<th>url地址</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PUT</td>
<td>localhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档id</td>
<td>创建文档(指定文档id)</td>
</tr>
<tr>
<td>POST</td>
<td>localhost:9200&#x2F;索引名称&#x2F;类型名称</td>
<td>创建文档（随机文档id）</td>
</tr>
<tr>
<td>POST</td>
<td>localhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档id&#x2F;_update</td>
<td>修改文档</td>
</tr>
<tr>
<td>DELETE</td>
<td>localhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档id</td>
<td>删除文档</td>
</tr>
<tr>
<td>GET</td>
<td>localhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档id</td>
<td>通过文档id查询文档</td>
</tr>
<tr>
<td>POST</td>
<td>localhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;_search</td>
<td>查询所有的数据</td>
</tr>
</tbody></table>
<blockquote>
<p>基础测试</p>
</blockquote>
<p>1.创建一个索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT /索引名/类型名(高版本都不写了，都是_doc)/文档id</span><br><span class="line"></span><br><span class="line">&#123;请求体&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102211.png" alt="在这里插入图片描述"></p>
<p>完成了自动添加了索引！数据也成功的添加了。这也是初期阶段说ES可以当做数据库来学习的原因</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102200.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LdUc6t8b-1598625546984)(C:\Users\53984\AppData\Roaming\Typora\typora-user-images\1598532887497.png)]"></p>
<p>那么name这个字段用不用指定类型呢</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102156.png" alt="在这里插入图片描述" style="zoom:67%;" />

<p>指定字段的类型properties 就比如sql创表</p>
<p>获得这个规则！可以通过GET请求获得具体的信息<br>mapping来设置规则</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102152.png" alt="在这里插入图片描述" style="zoom:67%;" />

<p>如果自己不设置文档字段类型，那么es会自动给默认类型</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102149.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CNGgrrjI-1598625546996)(C:\Users\53984\AppData\Roaming\Typora\typora-user-images\1598533818617.png)]"></p>
<h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>获取健康值</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102145.png" alt="在这里插入图片描述"></p>
<p>获取所有的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET _cat/indices?v</span><br></pre></td></tr></table></figure>

<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102141.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1ZKzwXyB-1598625547001)(C:\Users\53984\AppData\Roaming\Typora\typora-user-images\1598534090085.png)]"></p>
<p>还有很多 可以自动展示 都试试</p>
<blockquote>
<h4 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h4></blockquote>
<p>1.修改我们可以还是用原来的PUT的命令，根据id来修改</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102137.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-J5lCYCsQ-1598625547003)(C:\Users\53984\Desktop\文件\md学习文件\1598534298931.png)]"></p>
<p>但是如果没有填写的字段 会重置为空了 ，相当于java接口传对象修改，如果只是传id的某些字段，那其他没传的值都为空了。</p>
<p>2.还有一种update方法 这种不设置某些值 数据不会丢失</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /test3/_doc/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;:&#123;</span><br><span class="line">    &quot;name&quot;:&quot;212121&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面两种都是会将不修改的值清空的</span><br><span class="line"></span><br><span class="line">POST /test3/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;212121&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /test3/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;:&#123;</span><br><span class="line">    &quot;name&quot;:&quot;212121&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102131.png" alt="在这里插入图片描述"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102125.png" alt="在这里插入图片描述"></p>
<p>带doc修改 查询也是带doc的（document）</p>
<blockquote>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4></blockquote>
<p>关于删除索引或者文档的操作</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102118.png" alt="在这里插入图片描述"></p>
<p>通过DELETE命令实现删除，根据你的请求来判断是删除索引还是删除文档记录</p>
<p><strong>使用RESTFUL的风格是我们ES推荐大家使用的！</strong></p>
<h2 id="关于文档的基本操作-重点"><a href="#关于文档的基本操作-重点" class="headerlink" title="关于文档的基本操作(重点)"></a>关于文档的基本操作(重点)</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>最简单的搜索是GET<br>搜索功能search</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102050.png" alt="在这里插入图片描述"></p>
<p>这边name是text 所以做了分词的查询 如果是keyword就不会分词搜索了</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210121111318.png" alt="image-20210121111318402"></p>
<p>如果是用PUT方式进行更新，如果PUT里面字段不全，会造成不全字段的丢失<br>所以我们推荐采用POST _update方式进行更新</p>
<h2 id="复杂操作"><a href="#复杂操作" class="headerlink" title="复杂操作"></a>复杂操作</h2><p>select（分页，排序，高亮）</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210121143336.png" alt="image-20210121143336516" style="zoom:67%;" />

<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210121144333.png" alt="在这里插入图片描述"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试只能一个字段查询</span></span><br><span class="line">GET lisen/user/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李森&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>结果过滤，就是<strong>只展示列表中某些字段</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210121151135.png" alt="在这里插入图片描述"></p>
<p>包含</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122101942.png" alt="在这里插入图片描述"></p>
<p>不包含</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122101949.png" alt="在这里插入图片描述"></p>
<p>排序</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20200828224929501.png" alt="在这里插入图片描述"></p>
<p>分页</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122101953.png" alt="在这里插入图片描述"></p>
<p>代码</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET lisen/user/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李森&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span><span class="string">&quot;asc&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h4><blockquote>
<p>布尔值查询</p>
</blockquote>
<p>must（and），所有的条件都要符合</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122101957.png" alt="在这里插入图片描述"></p>
<p>should（or）或者的 跟数据库一样</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102006.png" alt="在这里插入图片描述"></p>
<p>must_not（not）<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102010.png" alt="在这里插入图片描述"></p>
<p>条件区间<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102013.png" alt="在这里插入图片描述"></p>
<ul>
<li>gt大于</li>
<li>gte大于等于</li>
<li>lte小于</li>
<li>lte小于等于</li>
</ul>
<blockquote>
<p>匹配多个条件（数组）</p>
</blockquote>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102017.png" alt="在这里插入图片描述"></p>
<p>match没用倒排索引 这边改正一下</p>
<blockquote>
<p>精确查找</p>
</blockquote>
<p>term查询是直接通过倒排索引指定的词条进程精确查找的</p>
<h4 id="关于分词"><a href="#关于分词" class="headerlink" title="关于分词"></a>关于分词</h4><ul>
<li>term，直接查询精确的</li>
<li>match，会使用分词器解析！（先分析文档，然后通过分析的文档进行查询）</li>
</ul>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102021.png" alt="在这里插入图片描述"></p>
<p>默认的是被分词了</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102025.png" alt="在这里插入图片描述"></p>
<p>keyword没有被分词</p>
<p>精确查询多个值</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102029.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>高亮</p>
</blockquote>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102032.png" alt="在这里插入图片描述"></p>
<p>还能自定义高亮的样式<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210122102035.png" alt="在这里插入图片描述"></p>
<h2 id="集成Springboot"><a href="#集成Springboot" class="headerlink" title="集成Springboot"></a>集成Springboot</h2><h3 id="引入依赖包"><a href="#引入依赖包" class="headerlink" title="引入依赖包"></a>引入依赖包</h3><p>创建一个springboot的项目 同时勾选上<code>springboot-web</code>的包以及<code>Nosql的elasticsearch</code>的包</p>
<p>如果没有就手动引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--es客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--springboot的elasticsearch服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意下spring-boot的parent包内的依赖的es的版本是不是你对应的版本</p>
<p>不是的话就在pom文件下写个properties的版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这边配置下自己对应的版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.6.2<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="注入RestHighLevelClient-客户端"><a href="#注入RestHighLevelClient-客户端" class="headerlink" title="注入RestHighLevelClient 客户端"></a>注入RestHighLevelClient 客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticSearchClientConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">restHighLevelClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">                RestClient.builder(<span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9200</span>,<span class="string">&quot;http&quot;</span>))</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="索引的增、删、是否存在"><a href="#索引的增、删、是否存在" class="headerlink" title="索引的增、删、是否存在"></a>索引的增、删、是否存在</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试索引的创建</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.创建索引的请求</span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;lisen_index&quot;</span>);</span><br><span class="line">    <span class="comment">//2客户端执行请求，请求后获得响应</span></span><br><span class="line">    <span class="type">CreateIndexResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试索引是否存在</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExistIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.创建索引的请求</span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;lisen_index&quot;</span>);</span><br><span class="line">    <span class="comment">//2客户端执行请求，请求后获得响应</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exist</span> <span class="operator">=</span>  client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(<span class="string">&quot;测试索引是否存在-----&quot;</span>+exist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除索引</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;lisen_index&quot;</span>);</span><br><span class="line">    <span class="type">AcknowledgedResponse</span> <span class="variable">delete</span> <span class="operator">=</span> client.indices().delete(request,RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除索引--------&quot;</span>+delete.isAcknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文档的操作"><a href="#文档的操作" class="headerlink" title="文档的操作"></a>文档的操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试添加文档</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lisen&quot;</span>,<span class="number">27</span>);</span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;lisen_index&quot;</span>);</span><br><span class="line">        request.id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//设置超时时间</span></span><br><span class="line">        request.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line">        <span class="comment">//将数据放到json字符串</span></span><br><span class="line">        request.source(JSON.toJSONString(user), XContentType.JSON);</span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        <span class="type">IndexResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.index(request,RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加文档-------&quot;</span>+response.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;添加文档-------&quot;</span>+response.status());</span><br><span class="line"><span class="comment">//        结果</span></span><br><span class="line"><span class="comment">//        添加文档-------IndexResponse[index=lisen_index,type=_doc,id=1,version=1,result=created,seqNo=0,primaryTerm=1,shards=&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;]</span></span><br><span class="line"><span class="comment">//        添加文档-------CREATED</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试文档是否存在</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testExistDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//测试文档的 没有index</span></span><br><span class="line">        GetRequest request= <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;lisen_index&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//没有indices()了</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exist</span> <span class="operator">=</span> client.exists(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试文档是否存在-----&quot;</span>+exist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试获取文档</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        GetRequest request= <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;lisen_index&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试获取文档-----&quot;</span>+response.getSourceAsString());</span><br><span class="line">        System.out.println(<span class="string">&quot;测试获取文档-----&quot;</span>+response);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        结果</span></span><br><span class="line"><span class="comment">//        测试获取文档-----&#123;&quot;age&quot;:27,&quot;name&quot;:&quot;lisen&quot;&#125;</span></span><br><span class="line"><span class="comment">//        测试获取文档-----&#123;&quot;_index&quot;:&quot;lisen_index&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1&quot;,&quot;_version&quot;:1,&quot;_seq_no&quot;:0,&quot;_primary_term&quot;:1,&quot;found&quot;:true,&quot;_source&quot;:&#123;&quot;age&quot;:27,&quot;name&quot;:&quot;lisen&quot;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试修改文档</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李逍遥&quot;</span>, <span class="number">55</span>);</span><br><span class="line">        <span class="comment">//修改是id为1的</span></span><br><span class="line">        UpdateRequest request= <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;lisen_index&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        request.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line">        request.doc(JSON.toJSONString(user),XContentType.JSON);</span><br><span class="line"></span><br><span class="line">        <span class="type">UpdateResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试修改文档-----&quot;</span>+response);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试修改文档-----&quot;</span>+response.status());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        结果</span></span><br><span class="line"><span class="comment">//        测试修改文档-----UpdateResponse[index=lisen_index,type=_doc,id=1,version=2,seqNo=1,primaryTerm=1,result=updated,shards=ShardInfo&#123;total=2, successful=1, failures=[]&#125;]</span></span><br><span class="line"><span class="comment">//        测试修改文档-----OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        被删除的</span></span><br><span class="line"><span class="comment">//        测试获取文档-----null</span></span><br><span class="line"><span class="comment">//        测试获取文档-----&#123;&quot;_index&quot;:&quot;lisen_index&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1&quot;,&quot;found&quot;:false&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试删除文档</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        DeleteRequest request= <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;lisen_index&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        request.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line">        <span class="type">DeleteResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试删除文档------&quot;</span>+response.status());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试批量添加文档</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testBulkAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ArrayList&lt;User&gt; userlist=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        userlist.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;cyx1&quot;</span>,<span class="number">5</span>));</span><br><span class="line">        userlist.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;cyx2&quot;</span>,<span class="number">6</span>));</span><br><span class="line">        userlist.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;cyx3&quot;</span>,<span class="number">40</span>));</span><br><span class="line">        userlist.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;cyx4&quot;</span>,<span class="number">25</span>));</span><br><span class="line">        userlist.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;cyx5&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        userlist.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;cyx6&quot;</span>,<span class="number">35</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//批量操作的Request</span></span><br><span class="line">        <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">        request.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//批量处理请求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; userlist.size(); i++) &#123;</span><br><span class="line">            request.add(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;lisen_index&quot;</span>)</span><br><span class="line">                            .id(<span class="string">&quot;&quot;</span>+(i+<span class="number">1</span>))</span><br><span class="line">                            .source(JSON.toJSONString(userlist.get(i)),XContentType.JSON)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BulkResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//response.hasFailures()是否是失败的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;测试批量添加文档-----&quot;</span>+response.hasFailures());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        结果:false为成功 true为失败</span></span><br><span class="line"><span class="comment">//        测试批量添加文档-----false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试查询文档</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSearchDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;lisen_index&quot;</span>);</span><br><span class="line">        <span class="comment">//构建搜索条件</span></span><br><span class="line">        <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">        <span class="comment">//设置了高亮</span></span><br><span class="line">        sourceBuilder.highlighter();</span><br><span class="line">        <span class="comment">//term name为cyx1的</span></span><br><span class="line">        <span class="type">TermQueryBuilder</span> <span class="variable">termQueryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;cyx1&quot;</span>);</span><br><span class="line">        sourceBuilder.query(termQueryBuilder);</span><br><span class="line">        sourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        request.source(sourceBuilder);</span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;测试查询文档-----&quot;</span>+JSON.toJSONString(response.getHits()));</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SearchHit documentFields : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;测试查询文档--遍历参数--&quot;</span>+documentFields.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试查询文档-----&#123;&quot;fragment&quot;:true,&quot;hits&quot;:[&#123;&quot;fields&quot;:&#123;&#125;,&quot;fragment&quot;:false,&quot;highlightFields&quot;:&#123;&#125;,&quot;id&quot;:&quot;1&quot;,&quot;matchedQueries&quot;:[],&quot;primaryTerm&quot;:0,&quot;rawSortValues&quot;:[],&quot;score&quot;:1.8413742,&quot;seqNo&quot;:-2,&quot;sortValues&quot;:[],&quot;sourceAsMap&quot;:&#123;&quot;name&quot;:&quot;cyx1&quot;,&quot;age&quot;:5&#125;,&quot;sourceAsString&quot;:&quot;&#123;\&quot;age\&quot;:5,\&quot;name\&quot;:\&quot;cyx1\&quot;&#125;&quot;,&quot;sourceRef&quot;:&#123;&quot;fragment&quot;:true&#125;,&quot;type&quot;:&quot;_doc&quot;,&quot;version&quot;:-1&#125;],&quot;maxScore&quot;:1.8413742,&quot;totalHits&quot;:&#123;&quot;relation&quot;:&quot;EQUAL_TO&quot;,&quot;value&quot;:1&#125;&#125;</span></span><br><span class="line"><span class="comment">//        =====================</span></span><br><span class="line"><span class="comment">//        测试查询文档--遍历参数--&#123;name=cyx1, age=5&#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>vue.js学习笔记</title>
    <url>/2021/12/02/note/vue%E6%95%99%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><p>参考视频：<a href="https://www.bilibili.com/video/BV18E411a7mC?spm_id_from=333.337.search-card.all.click&amp;vd_source=ec8158f9c5639641ada55d1a5998f03b">https://www.bilibili.com/video/BV18E411a7mC?spm_id_from=333.337.search-card.all.click&amp;vd_source=ec8158f9c5639641ada55d1a5998f03b</a></p>
<p>Soc原则：关注点分离原则</p>
<p>网络通信 ： axios<br>页面跳转 ： vue-router<br>状态管理：vuex<br>Vue-UI : ICE , Element UI</p>
<p>webpack打包，我们开发用常用的是ES6（可以通过打包，变成ES5支持）</p>
<ul>
<li>vue支持模块化（Angular）+虚拟DOM(React)</li>
<li>Axios：vue不具备通信能力，vue推荐使用axios进行通信，也可以采用jequry进行提供的ajax进行推广</li>
</ul>
<h2 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h2><p>●Ant-Design:阿里巴巴出品，基于React的UI框架<br>●ElementUI、 iview、 ice: 饿了么出品，基于Vue的UI框架<br>●Bootstrap: Twitter推出的一个用于前端开发的开源工具包<br>●AmazeUI:又叫”妹子UI”，一款HTML5跨屏前端框架.<br>JavaScript 构建工具<br>●Babel: JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript<br>●WebPack: 模块打包器，主要作用是打包、压缩、合并及按序加载<br>注：以上知识点将WebApp开发所需技能全部梳理完毕</p>
<h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><p>​	前端人员为了方便开发也需要掌握一定的后端技术， 但我们Java后台人员知道后台知识体系极其庞大复杂，所以为了方便前端人员开发后台应用，就出现了NodeJS这样的技术。nodeJs可以仿照controller发送消息<br> NodeJS的作者已经声称放弃NodeJS (说是架构做的不好再加上笨重的node_ modules，可能让作者不爽了吧)，开始开发全新架构的Deno<br> 既然是后台技术，那肯定也需要框架和项目管理工具，NodeJS 框架及项目管理工具如下:<br>●Express: NodeJS框架<br>●Koa: Express简化版<br>●NPM:项目综合管理工具，类似于Maven<br>●YARN: NPM的替代方案，类似于Maven和Gradle的关系</p>
<h2 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h2><p><a href="https://element.eleme.cn/#/zh-CN">https://element.eleme.cn/#/zh-CN</a></p>
<p>Element是饿了么前端开源维护的Vue UI组件库， 组件齐全， 基本涵盖后台所需的所有组件，文档讲解详细， 例子也很丰富。主要用于开发PC端的页面， 是一个质量比较高的Vue UI组件库。</p>
<p><strong>备注：属于前端主流框架，选型时可考虑使用，主要特点是桌面端支持较多</strong></p>
<h2 id="大前端"><a href="#大前端" class="headerlink" title="大前端"></a>大前端</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20200612223107534.png" alt="在这里插入图片描述"></p>
<p>前后端完全分离了，前端开发可以脱离后端</p>
<h2 id="MVVM模式的实现者"><a href="#MVVM模式的实现者" class="headerlink" title="MVVM模式的实现者"></a>MVVM模式的实现者</h2><p>viewModel能够观察到数据的变化，并对视图对应的内容进行更新</p>
<p>vue很重要的在于实现了model和view的解耦</p>
<p>vue.js就是一个MVVM的实现者，核心就是实现了DOM监听和数据绑定</p>
<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--view层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--判断--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>NO<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;type=&#x27;A&#x27;&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type=&#x27;B&#x27;&quot;</span>&gt;</span>B<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>C<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// el是元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// model，model就是数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">ok</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&#x27;A&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--view层--&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123;item.message&#125;&#125;--&#123;&#123;index&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--导入vue.js--&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        // el是元素</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        // model，model就是数据</span><br><span class="line">        data:&#123;</span><br><span class="line">            items: [</span><br><span class="line">                &#123;message: &#x27;java&#x27;&#125;,</span><br><span class="line">                &#123;message: &#x27;python&#x27;&#125;,</span><br><span class="line">                &#123;message: &#x27;go&#x27;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="methods属性"><a href="#methods属性" class="headerlink" title="methods属性"></a>methods属性</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--view层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;sayHi&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// el是元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// model，model就是数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="string">&quot;java&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 方法必须定义在vue的Method对象中</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// v-on绑定事件</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">message</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="双向绑定v-model"><a href="#双向绑定v-model" class="headerlink" title="双向绑定v-model"></a>双向绑定v-model</h2><p>主要是用在表单元素中，它实现了<em>双向绑定</em></p>
<p>v-model建立的双向绑定对输入型元素input, textarea, select等具有优先权，会强制实行<strong>双向绑定</strong>。很多时候v-model使用在表单的<code>&lt;input&gt;</code>中实现双向绑定。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--view层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--判断--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据的双向绑定--&gt;</span></span><br><span class="line">    输入的文本: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span> &#123;&#123;message&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    输入的文本框: <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span> &#123;&#123;message&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    性别：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span>&gt;</span> 男</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span>&gt;</span> 女</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>选中的人 &#123;&#123;sex&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    下拉框：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;wong&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>选中的人 &#123;&#123;wong&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// el是元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// model，model就是数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="number">123</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">sex</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">wong</span>: <span class="string">&#x27;B&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="vue组件详解"><a href="#vue组件详解" class="headerlink" title="vue组件详解"></a>vue组件详解</h2><p>组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树：</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210809095516.png" alt="img"></p>
<p>组件是可复用的vue实例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--view层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--组件就是模版，这里将template值放在这里--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--组件，传递给组件中的值--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--双向绑定，给组件template赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">v-bind:wong</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// prop 是子组件用来接受父组件传递过来的数据的一个自定义属性。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 父组件的数据需要通过 props 把数据传给子组件，子组件需要显式地用 props 选项声明 &quot;prop&quot;：</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;my-component&quot;</span>,&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">props</span>: [<span class="string">&#x27;wong&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">&#x27;&lt;li&gt;&#123;&#123;wong&#125;&#125;&lt;/li&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// el是元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// model，model就是数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">items</span>: [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;Linux&quot;</span>,<span class="string">&quot;前端&quot;</span>]</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="单向绑定v-bind"><a href="#单向绑定v-bind" class="headerlink" title="单向绑定v-bind"></a>单向绑定v-bind</h2><p>v-bind是一个单向数据绑定，映射关系：Model-&gt;View，我们不需要进行额外的DOM操作，只需要进行Model的操作就可以实现视图的联动更新。</p>
<p>v-model是一个双向数据绑定，映射关系：View接受的数据,传给model,model的数据再传给view。把Model绑定到View的同时也将View绑定到Model上，这样就既可以通过更新Model来实现View的自动更新，也可以通过更新View来实现Model数据的更新。所以，当我们用JavaScript代码更新Model时，View就会自动更新，反之，如果用户更新了View，Model的数据也自动被更新了。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210809101338.png" alt="image-20210809101338354"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210809101447.png" alt="image-20210809101447204"></p>
<h2 id="Axios异步通信"><a href="#Axios异步通信" class="headerlink" title="Axios异步通信"></a>Axios异步通信</h2><p>Axios主要功能就是实现Ajax异步通信</p>
<p>安装下载或者cdn<a href="https://www.runoob.com/vue2/vuejs-ajax-axios.html">https://www.runoob.com/vue2/vuejs-ajax-axios.html</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在线CDN--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.导入vue.js--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入axios--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;info.name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;info.address.street&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;info.url&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="comment">// 请求的返回参数合适，必须和json字符串一样</span></span></span><br><span class="line"><span class="language-javascript">              <span class="attr">info</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="attr">name</span>: <span class="literal">null</span>,</span></span><br><span class="line"><span class="language-javascript">                  <span class="attr">address</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                      <span class="attr">street</span>: <span class="literal">null</span>,</span></span><br><span class="line"><span class="language-javascript">                      <span class="attr">city</span>: <span class="literal">null</span>,</span></span><br><span class="line"><span class="language-javascript">                      <span class="attr">country</span>: <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">                  &#125;,</span></span><br><span class="line"><span class="language-javascript">                  <span class="attr">url</span>: <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 钩子函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 链式编程</span></span></span><br><span class="line"><span class="language-javascript">            axios.<span class="title function_">get</span>(<span class="string">&#x27;../data.json&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> (<span class="variable language_">this</span>.<span class="property">info</span>=response.<span class="property">data</span>))</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算出来的结果保存在属性中～内存中运行，虚拟DOM<br>可以将不经常变化的属性进行缓存，节省我们的系统开销</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--view层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>currentTime1: &#123;&#123;currentTime1()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>currentTime2: &#123;&#123;currentTime2&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// el是元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>:<span class="string">&quot;hello vue!&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">currentTime1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> <span class="title class_">Date</span>.<span class="title function_">now</span>();  <span class="comment">// 返回一个时间戳</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 计算属性</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// methods和computed中的方法名不能重复</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">currentTime2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--view层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;p&gt;列表&lt;/p&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;ul&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;li&gt;Java&lt;/li&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;li&gt;Linux&lt;/li&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;li&gt;python&lt;/li&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/ul&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">todo-title</span> <span class="attr">slot</span>=<span class="string">&quot;todo-title&quot;</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">todo-items</span> <span class="attr">slot</span>=<span class="string">&quot;todo-items&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;item in todoItems&quot;</span> <span class="attr">v-bind:item</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-items</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">todo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//slot 插槽 这个组件要定义在前面不然出不来数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;todo&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;\</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;ul&gt;\</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;/ul&gt;\</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;div&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;todo-title&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">props</span>: [<span class="string">&#x27;title&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;todo-items&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">props</span>: [<span class="string">&#x27;item&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">&#x27;&lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// el是元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">title</span>: <span class="string">&quot;图书馆系列图书&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 列表</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">todoItems</span>: [<span class="string">&#x27;三国演义&#x27;</span>, <span class="string">&#x27;红楼梦&#x27;</span>, <span class="string">&#x27;西游记&#x27;</span>, <span class="string">&#x27;水浒传&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖@:"></a>语法糖@:</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210809130829.png" alt="image-20210809130829558"></p>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210809141313.png" alt="image-20210809141313915"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--view层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">todo-title</span> <span class="attr">slot</span>=<span class="string">&quot;todo-title&quot;</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-title</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--v-for做列表渲染的时候可以有三个参数（value,key,index）分别代表对象属性的值，对象的属性名和键值对的索引。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">todo-items</span> <span class="attr">slot</span>=<span class="string">&quot;todo-items&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in todoItems&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">v-bind:item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">v-bind:index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">v-on:remove</span>=<span class="string">&quot;removeItems(index)&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-items</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">todo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//slot 插槽 这个组件要定义在前面不然出不来数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;todo&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;\</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;ul&gt;\</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;/ul&gt;\</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;div&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;todo-title&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">props</span>: [<span class="string">&#x27;title&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;todo-items&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">props</span>: [<span class="string">&#x27;item&#x27;</span>,<span class="string">&#x27;index&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 只能绑定当前组件的方法</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">&#x27;&lt;li&gt;&#123;&#123;index&#125;&#125;----&#123;&#123;item&#125;&#125; &lt;button @click=&quot;remove&quot;&gt;删除&lt;/button&gt;&lt;/li&gt;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">remove</span>: <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.$emit(<span class="string">&#x27;remove&#x27;</span>,index);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// el是元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">title</span>: <span class="string">&quot;图书馆系列图书&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 列表</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">todoItems</span>: [<span class="string">&#x27;三国演义&#x27;</span>, <span class="string">&#x27;红楼梦&#x27;</span>, <span class="string">&#x27;西游记&#x27;</span>, <span class="string">&#x27;水浒传&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">removeItems</span>:<span class="keyword">function</span> (<span class="params">index</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除了&quot;</span>+<span class="variable language_">this</span>.<span class="property">todoItems</span>[index]+<span class="string">&quot;ok&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">todoItems</span>.<span class="title function_">splice</span>(index,<span class="number">1</span>);    <span class="comment">// 一次只删除一个元素</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总结：数据驱动、组件化<br>优化：借鉴了AngularJS和react的思想，虚拟化DOM和模块化</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210809141815.png" alt="image-20210809141814966"></p>
<p>我们一般前端UI一半使用ElementUI（饿了吗）或者ICE（阿里）</p>
<h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>​	vue-cli 官方提供的一个脚手架,用于快速生成一个 vue 的项目模板;<br> 预先定义好的目录结构及基础代码，就好比咱们在创建 Maven 项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架,我们的开发更加的快速;</p>
<p>主要的功能:<br> 统一的目录结构<br>本地调试<br>热部署<br>单元测试<br>集成打包上线<br>需要的环境<br>Node.js : <a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a><br>安装就无脑下一步就好,安装在自己的环境目录下<br>Git : <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>镜像:<a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a><br>确认nodejs安装成功:<br>cmd 下输入 node -v,查看是否能够正确打印出版本号即可!<br>cmd 下输入 npm-v,查看是否能够正确打印出版本号即可!<br>这个npm,就是一个软件包管理工具,就和linux下的apt软件安装差不多!</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210809142635.png" alt="image-20210809142635217" style="zoom:50%;" />

<p>安装淘宝加速器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -g 就是全局安装</span><br><span class="line">npm install cnpm -g</span><br></pre></td></tr></table></figure>

<p>安装vue-cli</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在命令台输入</span><br><span class="line">cnpm install vue-cli -g</span><br><span class="line">#查看是否安装成功</span><br><span class="line">vue list</span><br></pre></td></tr></table></figure>

<p>创建一个基于 webpack 模板的 vue 应用程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue init webpack myvue</span><br></pre></td></tr></table></figure>

<p>一路都选择no即可;</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210809143625.png" alt="image-20210809143625785">初始化并运行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> myvue</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210809150456.png" alt="image-20210809150455992"></p>
<p>安装Webpack<br>WebPack是一款模块加载器兼打包工具， 它能把各种资源， 如JS、JSX、ES 6、SASS、LESS、图片等都作为模块来处理和使用。<br>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install webpack -g</span><br><span class="line">npm install webpack-cli -g</span><br></pre></td></tr></table></figure>

<p>测试安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack -v</span><br><span class="line">webpack-cli -v</span><br></pre></td></tr></table></figure>

<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210809151437.png" alt="image-20210809151437500"></p>
<p>参考代码：&#x2F;Users&#x2F;oldwong&#x2F;Documents&#x2F;CodeHouse&#x2F;webStorm&#x2F;webpack-study</p>
<h2 id="vue-router路由"><a href="#vue-router路由" class="headerlink" title="vue-router路由"></a>vue-router路由</h2><p>​		Vue Router是Vue.js官方的路由管理器（路径跳转）。它和Vue.js的核心深度集成，让构建单页面应用变得易如反掌。<br>​		基于第一个vue-cli进行测试学习;先查看node_modules中是否存在 vue-router<br>​		vue-router 是一个插件包，所以我们还是需要用 npm&#x2F;cnpm 来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vue-router --save-dev</span><br></pre></td></tr></table></figure>

<p>安装完之后去node_modules路径看看是否有vue-router信息 有的话则表明安装成功</p>
<p>vue里面规定index.js是主配置</p>
<p>参考代码</p>
<p>&#x2F;Users&#x2F;oldwong&#x2F;Documents&#x2F;CodeHouse&#x2F;webStorm&#x2F;myvue</p>
<h2 id="ElementUI-1"><a href="#ElementUI-1" class="headerlink" title="ElementUI"></a>ElementUI</h2><p>根据之前创建vue-cli项目一样再来一遍 创建项目<br>1． 创建一个名为 hello-vue 的工程 vue init webpack hello-vue<br>2． 安装依赖，我们需要安装 vue-router、element-ui、sass-loader 和 node-sass 四个插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入工程目录</span><br><span class="line">cd hello-vue</span><br><span class="line"># 安装 vue-router</span><br><span class="line">npm install vue-router --save-dev</span><br><span class="line"># 安装 element-ui</span><br><span class="line">npm i element-ui -S</span><br><span class="line"># 安装依赖</span><br><span class="line">npm install</span><br><span class="line"># 安装 SASS 加载器</span><br><span class="line">cnpm install sass-loader node-sass --save-dev</span><br><span class="line"># 启动测试</span><br><span class="line">npm run dev	</span><br></pre></td></tr></table></figure>

<h2 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h2><p><strong>App.vue是项目的主组件，页面入口文件 ，所有页面都在App.vue下进行切换，app.vue负责构建定义及页面组件归集。</strong></p>
<h2 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-container</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-aside</span> <span class="attr">width</span>=<span class="string">&quot;200px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-menu</span> <span class="attr">:default-openeds</span>=<span class="string">&quot;[&#x27;1&#x27;]&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-submenu</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-caret-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-menu-item-group</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;1-1&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--插入的地方--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/user/profile&quot;</span>&gt;</span>个人信息<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;1-2&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--插入的地方--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/user/list&quot;</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-menu-item-group</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">el-submenu</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-submenu</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-caret-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>内容管理<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-menu-item-group</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;2-1&quot;</span>&gt;</span>分类管理<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;2-2&quot;</span>&gt;</span>内容列表<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-menu-item-group</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">el-submenu</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-menu</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-container</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-header</span> <span class="attr">style</span>=<span class="string">&quot;text-align: right; font-size: 12px&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-dropdown</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-setting&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 15px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-dropdown-menu</span> <span class="attr">slot</span>=<span class="string">&quot;dropdown&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">el-dropdown-item</span>&gt;</span>个人信息<span class="tag">&lt;/<span class="name">el-dropdown-item</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">el-dropdown-item</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">el-dropdown-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-dropdown-menu</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">el-dropdown</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-main</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--在这里展示视图--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-main</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-container</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&quot;Main&quot;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.el-header</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#B3C0D1</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.el-aside</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参数传递和重定向"><a href="#参数传递和重定向" class="headerlink" title="参数传递和重定向"></a>参数传递和重定向</h2><p>&#x2F;Users&#x2F;oldwong&#x2F;Documents&#x2F;CodeHouse&#x2F;webStorm&#x2F;hello-vue</p>
<h2 id="404和路由钩子"><a href="#404和路由钩子" class="headerlink" title="404和路由钩子"></a>404和路由钩子</h2><p>在钩子函数中使用异步请求<br>1、安装 Axios</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install --save vue-axios</span><br></pre></td></tr></table></figure>

<p>2、main.js引用 Axios</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">import VueAxios from &#x27;vue-axios&#x27;</span><br><span class="line">Vue.use(VueAxios, axios)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统-小林coding读书笔记</title>
    <url>/2021/11/13/note/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统-小林coding读书笔记"><a href="#操作系统-小林coding读书笔记" class="headerlink" title="操作系统-小林coding读书笔记"></a>操作系统-小林coding读书笔记</h1><h2 id="CPU缓存一致性"><a href="#CPU缓存一致性" class="headerlink" title="CPU缓存一致性"></a>CPU缓存一致性</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210510200602.png" alt="image-20210510200600952"></p>
<p>CPU一般都是多核的，L1L2缓存都是各自独自有的，那么就会带来缓存一致性的问题。</p>
<p>要想实现缓存一致性，必须做到以下两点：<br>1 某个CPU核心的cache数据更新的时候，必须要传播到其他cache里，这个就是写传播<br>2 某个CPU核心里对数据的操作顺序，必须在其他核心里看起来顺序是一致的，被称为事务的串行化</p>
<h3 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h3><p>某个CPU核心的cache数据更新的时候，必须要传播到其他cache里，最常见的实现方式就是总线嗅探。</p>
<h2 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h2><p>​		中断是用来响应硬件设备 请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应中断请求</p>
<p>​		一定要保证中断程序快速能处理，因为当CPU在处理中断时，是不能响应其他中断请求的，那么就会导致其他中断请求丢失。所以中断会分为两个阶段：<br>​		第一阶段(上半部请求)：接受硬件中断请求(从硬件中取完数据后发送一次软断请求，复杂逻辑交给下半部分请求，称为硬中断，特点是处理速度快<br>​		第二阶段(下半部请求)： 内核线程接受到上半部分软中断请求，就会异步的继续执行上半部未完成的请求， 称为软中断，特点延迟执行</p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h3><p>内核管理进程、线程；<br>管理内存，决定内存的回收；<br>管理硬件设备，为进程和硬件设备提供通信能力；<br>提供系统调用</p>
<h3 id="内核是如何工作的"><a href="#内核是如何工作的" class="headerlink" title="内核是如何工作的"></a>内核是如何工作的</h3><p>内核具有很高的权限，可以控制CPU、内存、硬盘等；但是应用程序的权限比较低，所以内核分为两个区域，用户空间和内核空间</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210510195954.png" alt="image-20210510195949778"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>​		要想在内存中同时运行两个程序是不可能的。如果第一个程序在2000的位置写入一个新的值，将会擦掉第二个程序放在相同位置上的所有内容，这样程序会崩溃。为了解决这个问题，是因为两个程序都使用了绝对物理地址，这个是要避免的。操作系统引入了虚拟地址</p>
<p>​		操作系统提供了一种机制，将不同进程的虚拟地址和不同的物理地址映射起来。如果程序要访问虚拟地址的时候，由操作系统转换为不同的物理地址，这样不同的进程运行的时候，写入不同的物理地址，这样就不会发生冲突了</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210510203440.png" alt="image-20210510203438086" style="zoom:33%;" />

<h3 id="os如何管理虚拟地址和物理地址的关系"><a href="#os如何管理虚拟地址和物理地址的关系" class="headerlink" title="os如何管理虚拟地址和物理地址的关系"></a>os如何管理虚拟地址和物理地址的关系</h3><p>主要是两种方式，分别是内存分段和内存分页</p>
<p>内存分段<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210510204202.png" alt="image-20210510204200431"></p>
<p>内存分段会带来问题，比如内存碎片的问题</p>
<p>内存分页<br>内存分段的好处是可以产生连续的内存空间，但是会出现内存碎片的问题</p>
<p>分页就是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续且尺寸固定的内存空间，我们称之为页，每一个页的大小为4KB</p>
<p>虚拟地址和真实地址通过页表进行转换<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210511160645.png" alt="image-20210511160625804" style="zoom: 33%;" /></p>
<p>总结一下，对于一个地址的转换，大致可以分为以下几个步骤：<br>1 把虚拟的内存地址，切割成页号和页偏移量<br>2 根据页号，从页表里里面查询对应的物理页号<br>3 直接拿物理页号，加上偏移量，就得到了物理地址</p>
<p>单级分页和多级分页<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210510205305.png" alt="image-20210510205302883"></p>
<p>利用程序的局限性，某一个时间段内，会局限在某个特定的内存区域。我们可以利用这个特性，把这些频繁访问的页表放在cache中，这个cache就是TLB，通常称之为页表缓存。</p>
<h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>内存分段和分页并不是对立的，可以进行组合使用</p>
<ul>
<li>先把程序分成多个有意义的段，也就是前面提到的段分页</li>
<li>接着把每个段划分成多个页，也就是对分段分出来的连续空间，再划分固定大小的页</li>
</ul>
<p>这样地址就是由段号、段内页号、段内位移三部分组成</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210511162205.png" alt="image-20210511162203462"></p>
<p>段页式地址变换中得到物理地址需要三次内存访问</p>
<ul>
<li>第一访问段表，得到页的起始地址</li>
<li>第二次访问页表，得到物理页号</li>
<li>第三次段号和页内偏移结合，得到物理地址</li>
</ul>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>我们编写的代码是静态文件，通过编译后生成可以执行的二进制码文件，当我们运行这个可执行文件的时候，CPU就会执行程序中的每一个指令，我们把运行的程序称之为进程</p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>初始状态，就绪，运行，阻塞，阻塞挂起，就绪挂起，运行结束</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210511201534.png" alt="image-20210511201533271"></p>
<h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p>进程控制块，用来描述进程的。PCB是进程的唯一标识符，这意味着一个进程存在，必然会有一个PCB，如果进程消失了，那么PCB也会消失</p>
<h3 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h3><p>CPU要想知道下一个指令从哪里开始执行，操作系统需要事先设置好CPU寄存器和程序计数器<br>所谓的上下文切换说的就是把先前一个程序的CPU寄存器和程序计数器保存起来，然后加载新的</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程相当于是进程当中一个执行的流程。进程包含多个线程，线程可以并发的执行<br>进程和线程最大的区别是：线程是调度的基本单位，进程是资源拥有的基本单位</p>
<h2 id="CPU调度算法"><a href="#CPU调度算法" class="headerlink" title="CPU调度算法"></a>CPU调度算法</h2><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>每次从就绪队列选择最先进⼊队列的进程，然后⼀直运⾏，直到进程退出或被阻塞，才会继续从队列中选择第⼀个进程接着运⾏</p>
<h3 id="最短优先调度算法"><a href="#最短优先调度算法" class="headerlink" title="最短优先调度算法"></a>最短优先调度算法</h3><p>优先选择运行时间最短的进程来运行</p>
<h3 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h3><p>每个进程被分配一个时间段，称之为是时间片，即允许进程在该时间段中运行</p>
<h3 id="最高优先级调度算法"><a href="#最高优先级调度算法" class="headerlink" title="最高优先级调度算法"></a>最高优先级调度算法</h3><p>等等…</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="进程通信的方式"><a href="#进程通信的方式" class="headerlink" title="进程通信的方式"></a>进程通信的方式</h3><p>管道，消息队列，共享内存，信号量，socket…</p>
<p>每个进程的用户空间都是相互独立的，一般不能相互访问，但是内核空间是共享的，所以进程通信必须通过内核。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210511210724.png" alt="image-20210511210722352" style="zoom:33%;" />

<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>我们可以通过makefifo来创建一个管道<br>管道的数据传输是单向</p>
<p>管道的好处在于简单，很容易知道数据已经被另外一个进程读取了<br>缺点是：通信方式效率比较低，不适合频繁的交换数据</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列的通信通信效率高于管道，A进程要给B进程发送消息，只需要把对应的消息放在消息队列。B进程需要的时候直接去取数据即可<br>消息队列是保存在内核中的消息列表</p>
<p>消息队列的缺点在于不适合大数据的传输，因为内核中的每个消息体都有最大长度的限制<br>消息在通信的过程中，存在用户态和内核态频繁切换的开销</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>消息队列的读取和写入，都会有用户态和内核态消息拷贝的过程。共享内存很好的解决了问题<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210511212245.png" alt="image-20210511212243012" style="zoom:33%;" /></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>主要实现进程间的互斥同步，而不是用于缓存进程间的通信数据<br>pv操作，p信号量-1，v信号量+1</p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>前面提到的管道，消息队列，共享内存，信号量和信号都是在同一个主机上进行线程间通信，如果想要跨网络与在不同进程之间通信，就需要socket通信了</p>
<p>根据创建socket的不同，通信方式也不同，分为TCP通信，UDP通信，本地进程通信</p>
<h2 id="os三大调度机制"><a href="#os三大调度机制" class="headerlink" title="os三大调度机制"></a>os三大调度机制</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210511213938.png" alt="image-20210511213936172"></p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>linux文件系统会给每个文件分配两个数据结构，索引节点和目录项</p>
<ul>
<li><p>索引节点：记录文件的元信息，比如说innode编号，文件大小，访问权限，创建时间等</p>
</li>
<li><p>目录项：用来记录目录项之间的层级关系</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210512201135.png" alt="image-20210511220004604" style="zoom: 50%;" /></li>
</ul>
<h2 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h2><p>有的时候我们希望给某个文件取别名，那么Linux可以通过硬链接和软链接的方式来实现，它们都是比较特殊的文件</p>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>多个目录项的索引节点指向一个文件，也就是指向同一个innode，但是innode是不可以跨越文件系统的</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210512204526.png" alt="image-20210512204526113"></p>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>相当于重建了一个新的innode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，相当于访问到另外一个文件，所以软链接是可以跨越文件系统的</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210512204732.png" alt="image-20210512204732936"></p>
<h2 id="IO多路复用三个API之-select-x2F-poll-x2F-epoll"><a href="#IO多路复用三个API之-select-x2F-poll-x2F-epoll" class="headerlink" title="IO多路复用三个API之 select&#x2F;poll&#x2F;epoll"></a>IO多路复用三个API之 select&#x2F;poll&#x2F;epoll</h2><p>首先我们介绍一下最简单的基于TCP的socket程序</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210512201115.png" alt="image-20210511220949531" style="zoom: 25%;" />

<p>这种方式只能一对一通信，因为使用的是同步阻塞，当服务器还没有处理完一个客户端的IO时，其他客户端是不能和服务器连接的</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210511221447.png" alt="image-20210511221446058"></p>
<h3 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h3><p>如果一个服务器端要支持多个客户端连接，其中比较传统的方式就是通过多进程模型，也就是为每个客户端分配一个进程来处理连接请求。</p>
<p>主进程负责监听客户的连接，一旦与客户的连接完成，accept()函数会返回一个已经连接的socket，这个时候fork一个子进程，把父进程所有东西都复制一份。</p>
<p>可以发现父进程只负责监听socket，不需要关注连接socket；子进程需要关注连接socket，不需要关注监听socket</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210512201109.png" alt="image-20210512200638724" style="zoom:50%;" />

<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>因为进程上下文切换的消耗很重，那么我们就选择轻量级的模型应对多用户的请求</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210512201100.png" alt="image-20210512201058865"></p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>既然为每个请求分配一个线程或者进程的方法不合适，是否可以只使用一个进程维护多个socket呢？可以使用IO多路复用技术</p>
<p>select、poll、epoll是如何获取网络事件的呢？在获取事件的时候，先把所有的连接传递给内核，再由内核返回产生事情的连接，然后在用户态中对这些链接事情进行处理即可</p>
<h3 id="socket和poll"><a href="#socket和poll" class="headerlink" title="socket和poll"></a>socket和poll</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210512205738.png" alt="image-20210512205727689"></p>
<p>select和poll没有本质区别，都是使用线性结构存储关注的socket集合。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210512205522.png" alt="image-20210512205522653"></p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210512211612.png" alt="image-20210512211612294"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210512211638.png" alt="image-20210512211638552"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210512211743.png" alt="image-20210512211743711"></p>
<p>总结来说：</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210512212001.png" alt="image-20210512212001600"></p>
<h3 id="IO多路复用-1"><a href="#IO多路复用-1" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p><a href="https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=851111987744563735">https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=851111987744563735</a></p>
<p>设计一个高性能的服务器，可以同时响应多个客户端的连接<br>我们可以想到写一个多线程的程序，每个线程对应一个连接，但是多线程涉及到频繁的上下文切换，需要消耗大量的资源，因此我们考虑单线程</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210513102857.png" alt="image-20210513102857796" style="zoom: 33%;" />

<h3 id="我们看一下select是如何操作的？"><a href="#我们看一下select是如何操作的？" class="headerlink" title="我们看一下select是如何操作的？"></a>我们看一下select是如何操作的？</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210513104001.png" alt="image-20210513104001633"></p>
<p>select把文件描述符集合从用户态交给内核态处理，我们知道直接交给内核态处理速度是会有所提升的。内核态完成的功能就是，对那些有数据的进行FD置位，标记这个地方有数据，然后select返回，返回之后用户态遍历文件描述符集合，判断状态</p>
<p>select中使用bitmap存储关注的文件描述符</p>
<p>select方式的缺点在于：<br>1 bitmap默认最大值为1024，只能监听0-1023的文件描述符<br>2 用户态拷贝到内核态，需要花费开销。但是肯定比单个拷贝开销小一点<br>3 时间复杂度较高，需要遍历rset两遍</p>
<h3 id="我们看下poll是如何操作的？"><a href="#我们看下poll是如何操作的？" class="headerlink" title="我们看下poll是如何操作的？"></a>我们看下poll是如何操作的？</h3><p>poll中没有使用1024位的bitmap，而是使用了数组来存储，解决了存储大小的问题<br>剩下的和select差不多</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210513105411.png" alt="image-20210513105411733"></p>
<h3 id="我们看下epoll是如何操作的？"><a href="#我们看下epoll是如何操作的？" class="headerlink" title="我们看下epoll是如何操作的？"></a>我们看下epoll是如何操作的？</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210513110254.png" alt="image-20210513110254773"></p>
<p>epoll的优点：</p>
<p>1 epoll采用了事件驱动的方式，内核中维护了一个链表记录发生事件的文件描述符。当有事件发生的时候，epoll_wait会返回有事件发生的文件描述符的个数，这样就不要像之前select或者poll一样遍历整合循环</p>
<p>2 epoll内部采用了红黑树来跟踪待检测的文件描述字</p>
<p>redis、nginx、java NIO也都是使用epoll实现的。当今一般的linux服务器，也是使用的epoll实现的</p>
<h3 id="为什么epoll底层使用红黑树呢？"><a href="#为什么epoll底层使用红黑树呢？" class="headerlink" title="为什么epoll底层使用红黑树呢？"></a>为什么epoll底层使用红黑树呢？</h3><p>epoll和poll的一个很大的区别在于，poll每次调用时都会存在一个将pollfd结构体数组中的每个结构体元素从用户态向内核态中的一个链表节点拷贝的过程，而内核中的这个链表并不会一直保存，当poll运行一次就会重新执行一次上述的拷贝过程，这说明一个问题：poll并不会在内核中为要监听的文件描述符长久的维护一个数据结构来存放他们，而epoll内核中维护了一个内核事件表，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发回调，当你要添加新的文件描述符的时候也是调用epoll_ctl函数使用EPOLL_CTL_ADD宏来插入，epoll_wait也不是每次调用时都会重新拷贝一遍所有的文件描述符到内核态。当我现在要在内核中长久的维护一个数据结构来存放文件描述符，并且时常会有插入，查找和删除的操作发生，这对内核的效率会产生不小的影响，因此需要一种插入，查找和删除效率都不错的数据结构来存放这些文件描述符，那么红黑树当然是不二的人选。<br>————————————————<br>版权声明：本文为CSDN博主「Mr_H9527」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Mr_H9527/article/details/99745659">https://blog.csdn.net/Mr_H9527/article/details/99745659</a></p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>​		跟大家分享一下我的理解（应对面试），面试官问红黑树怎么旋转调整的，一般能问到这么细的就看真本事了，要我我选择放弃。</p>
<p>​		但是问我红黑树是什么，有什么意义还是可以回答的：排序二叉树有不平衡的问题，可能左子树很长但是右子树很短，造成查询时性能不佳（logn退化成n），完全平衡的二叉树能保证层数平均，从而查询效率高，但是维护又很麻烦，每次插入和删除有很大的可能要大幅调整树结构。</p>
<p>​		红黑树就是介于完全不平衡和完全平衡之间的一种二叉树，通过每个节点有红黑两种颜色、从节点到任意叶子节点会经过相同数量的黑色节点等一系列规则，实现了树的层数最大也只会有两倍的差距，这样既能提高插入和删除的效率，又能让树相对平衡从而有还不错的查询效率。从整体上讲，红黑树就是一种中庸之道的二叉树</p>
<h3 id="二叉搜索树BST"><a href="#二叉搜索树BST" class="headerlink" title="二叉搜索树BST"></a>二叉搜索树BST</h3><p>任意一个节点的左子树小于这个节点，右子树大于这个节点<br>BST的搜索和插入的时间复杂度是0(logn)</p>
<p>BST的问题在于可能会退化成一个链表，那么我们一个解决方法就是AVL树</p>
<h3 id="AVL平衡树"><a href="#AVL平衡树" class="headerlink" title="AVL平衡树"></a>AVL平衡树</h3><p>本身就是二叉搜索树，此外左子树和右子树深度差不差过1<br>AVL最差情况下，时间复杂度也是o(logn)</p>
<h3 id="红黑树-1"><a href="#红黑树-1" class="headerlink" title="红黑树"></a>红黑树</h3><ul>
<li>红黑树的特征</li>
</ul>
<p>每个节点要么红，要么黑<br>root节点是黑<br>叶子结点必须是黑；<br>红节点的子节点必须是黑的</p>
<p>新插入的节点是红节点<br>从任意一个节点出发，到叶子节点的任意路径上，拥有的黑节点的数量是相同的</p>
<ul>
<li>红黑树确保了左右树的深度最多相差一倍</li>
</ul>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210513202312.png" alt="image-20210513202312765"></p>
<h3 id="Java中HashMap的底层当链表长度超过8了为什么选取红黑树这种结构？为什么不用AVL和BST"><a href="#Java中HashMap的底层当链表长度超过8了为什么选取红黑树这种结构？为什么不用AVL和BST" class="headerlink" title="Java中HashMap的底层当链表长度超过8了为什么选取红黑树这种结构？为什么不用AVL和BST"></a>Java中HashMap的底层当链表长度超过8了为什么选取红黑树这种结构？为什么不用AVL和BST</h3><p>BST极端情况下会退还成链表；<br>AVL树对树的平衡要求更加严格，要求左树和右树的高度差不超过1，而红黑树保证了差距最多是一倍。这样的效果就是在插入数据的时候，红黑树需要的代价小一些</p>
<p>红黑树的时间复杂度也是o(logn)</p>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>Ngork内网穿透</title>
    <url>/2021/09/17/note/ngork%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="Ngork内网穿透"><a href="#Ngork内网穿透" class="headerlink" title="Ngork内网穿透"></a>Ngork内网穿透</h1><p>问题：自己电脑上的项目，别人怎么进行访问</p>
<p><a href="http://localhost:8080/">http://localhost:8080/</a>	—  <a href="http://kuangstudy.com/">http://kuangstudy.com</a></p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>1 注册账号</p>
<p><a href="http://www.ngrok.cc/">http://www.ngrok.cc/</a></p>
<p>2 购买账号</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20201102221459.png" alt="img"></p>
<p>3 下载工具实现</p>
<p>第一步，命令行切换到这个sunny的目录下</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20201102223020.png" alt="img"></p>
<p>第二步，复制上面的隧道id，在命令行中启动这个隧道</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20201102221414.png" alt="img"></p>
<p>第三步，启动成功后显示。可能一次启动不成功，多尝试几次</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20201102222235.png" alt="img"></p>
<p>第四步，这样就可以通过外网进行一个访问了</p>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>Java8新特性</title>
    <url>/2021/07/18/note/Java8/</url>
    <content><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><p>代码位置：&#x2F;Users&#x2F;oldwong&#x2F;Documents&#x2F;CodeHouse&#x2F;IdeaProjects&#x2F;StudyJava8</p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1kK4y1p7M2?p=1">https://www.bilibili.com/video/BV1kK4y1p7M2?p=1</a></p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>lambda是一个匿名函数，可以让函数像参数一样传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mayikt.Lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java8引入了-&gt;操作符，这个操作符将表达式拆分成了两部分</span></span><br><span class="line"><span class="comment"> * 左侧：方法的参数列表</span></span><br><span class="line"><span class="comment"> * 右侧：Lambda表达式需要执行的功能</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 语法格式</span></span><br><span class="line"><span class="comment"> * 1 无参数，无返回值</span></span><br><span class="line"><span class="comment"> * 2 一个参数，无返回值</span></span><br><span class="line"><span class="comment"> * 3 两个以上的参数，并且有返回值，Labda有多个语句</span></span><br><span class="line"><span class="comment"> * 4 Lambda只有一条语句，那么return 和 &#123;&#125;都可以省略不写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//jdk1.7之前必须是final</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 原来的写法</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        r2.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);</span><br><span class="line">        con.accept(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;函数式接口&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(x, y);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        al.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        al.add(<span class="string">&quot;python&quot;</span>);</span><br><span class="line">        al.add(<span class="string">&quot;go&quot;</span>);</span><br><span class="line">        al.forEach((s) -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合排序"><a href="#集合排序" class="headerlink" title="集合排序"></a>集合排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;UserEntity&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;fangfang&quot;</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        al.sort((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line">        al.forEach((x)-&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><p>非常方便精简的形式遍历集合，实现过滤排序等<br>中止操作一旦进行了，不能回头做中间操作</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210815114715.png" alt="img" style="zoom: 67%;" />

<h2 id="list转换成set"><a href="#list转换成set" class="headerlink" title="list转换成set"></a>list转换成set</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;UserEntity&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;fangfang&quot;</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 串行流和并行流</span></span><br><span class="line"><span class="comment">         * al.stream();</span></span><br><span class="line"><span class="comment">         * al.parallelStream();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;UserEntity&gt; collect = al.stream().collect(Collectors.toSet());</span><br><span class="line">        collect.forEach((x)-&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list转换成map"><a href="#list转换成map" class="headerlink" title="list转换成map"></a>list转换成map</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;UserEntity&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaofang&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;fangfang&quot;</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        Stream&lt;UserEntity&gt; stream = al.stream();</span><br><span class="line">        Map&lt;String, UserEntity&gt; map = stream.collect(Collectors.toMap(userEntity -&gt; userEntity.getUserName(),</span><br><span class="line">                userEntity -&gt; userEntity));</span><br><span class="line">        map.forEach((BiConsumer)(o1, o2) -&gt; System.out.println(o1 + <span class="string">&quot;--&quot;</span> + o2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="stream计算求和"><a href="#stream计算求和" class="headerlink" title="stream计算求和"></a>stream计算求和</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;UserEntity&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaofang&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;fangfang&quot;</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        Stream&lt;UserEntity&gt; stream = al.stream();</span><br><span class="line">        Optional&lt;UserEntity&gt; sum = stream.reduce((user1, user2) -&gt; &#123;</span><br><span class="line">            <span class="type">UserEntity</span> <span class="variable">userEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;sum&quot;</span>, user1.getAge()+ user2.getAge());</span><br><span class="line">            <span class="keyword">return</span> userEntity;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找最大和最小"><a href="#查找最大和最小" class="headerlink" title="查找最大和最小"></a>查找最大和最小</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;UserEntity&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">4</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaofang&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;fangfang&quot;</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        Stream&lt;UserEntity&gt; stream = al.stream();</span><br><span class="line">        Optional&lt;UserEntity&gt; userEntity = stream.max((user1, user2) -&gt; user1.getAge() - user2.getAge());</span><br><span class="line">        System.out.println(userEntity.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="match匹配"><a href="#match匹配" class="headerlink" title="match匹配"></a>match匹配</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test13</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;UserEntity&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">4</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaofang&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;fangfang&quot;</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        Stream&lt;UserEntity&gt; stream = al.stream();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stream.anyMatch((user) -&gt; <span class="string">&quot;xiaoming&quot;</span>.equals(user.getUserName()));</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="filter过滤器"><a href="#filter过滤器" class="headerlink" title="filter过滤器"></a>filter过滤器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test14</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;UserEntity&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">4</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaofang&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;fangfang&quot;</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        al.stream().filter(userEntity -&gt; <span class="string">&quot;xiaofang&quot;</span>.equals(userEntity.getUserName())&amp;&amp;userEntity.getAge()&gt;<span class="number">2</span>)</span><br><span class="line">                .forEach((userEntity -&gt; System.out.println(userEntity.getUserName())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;UserEntity&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">4</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;xiaofang&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;ffang&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;angfang&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;ngfang&quot;</span>, <span class="number">32</span>));</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(<span class="string">&quot;gfang&quot;</span>, <span class="number">42</span>));</span><br><span class="line"></span><br><span class="line">        al.stream().sorted(((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(o1.getUserName().equals(o2.getUserName()))&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1.getAge(),o2.getAge());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  o1.getUserName().compareTo(o2.getUserName());</span><br><span class="line">        &#125;)).forEach((o1)-&gt; System.out.println(o1.getUserName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>最长公共子串or子序列</title>
    <url>/2021/07/14/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2or%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="最长公共子串or子序列"><a href="#最长公共子串or子序列" class="headerlink" title="最长公共子串or子序列"></a>最长公共子串or子序列</h2><h2 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (text1 == <span class="literal">null</span> || text2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> text1.length(), len2 = text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubstring</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (text1 == <span class="literal">null</span> || text2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> text1.length(), len2 = text2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>LVS+Nginx集群</title>
    <url>/2021/05/07/note/LVS+Nginx/</url>
    <content><![CDATA[<h2 id="LVS-Nginx集群"><a href="#LVS-Nginx集群" class="headerlink" title="LVS+Nginx集群"></a>LVS+Nginx集群</h2><p>LVS+Nginx做一个高可用的网关，高可用的一个方案</p>
<h2 id="什么是LVS"><a href="#什么是LVS" class="headerlink" title="什么是LVS"></a>什么是LVS</h2><p>lvs就是linux virtual server，运行在linux下的虚拟服务，性能是nginx的n倍</p>
<p>lvs是一个负载均衡调度器DIP</p>
<p>lvs是基于四层负载的调度器<br>nginx是基于七层负载的调度器</p>
<p><strong>七层负载：应用层对请求报文进行负载均衡</strong><br><strong>四层负载：基于IP+端口的负载均衡</strong></p>
<p>用户访问，lvs会产生一个虚拟ip，也就是vip，利用vip转发给nginx服务器，然后利用lvs的负载均衡转发给nginx，还可以通过keepalived，从而达到一个lvs的高可用，设置一个主从模式</p>
<h2 id="LVS官网定义"><a href="#LVS官网定义" class="headerlink" title="LVS官网定义"></a>LVS官网定义</h2><p>The Linux Virtual Server is a highly scalable and highly available server built on a cluster of real servers, with the <a href="http://kb.linuxvirtualserver.org/wiki/Load_balancer">load balancer</a> running on the Linux operating system. The architecture of the server cluster is fully transparent to end users, and the users interact as if it were a single high-performance virtual server. For more information, click <a href="http://www.linuxvirtualserver.org/whatis.html">here</a>.</p>
<p>lvs是一个负载均衡的调度器DIP，定义中的real server指的就是后端的真实服务器RS，比如是后端的nginx服务器等等</p>
<h2 id="LVS网络拓扑结构"><a href="#LVS网络拓扑结构" class="headerlink" title="LVS网络拓扑结构"></a>LVS网络拓扑结构</h2><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210806105921.png" alt="image-20210806105921818" style="zoom:50%;" />

<h2 id="为什么要LVS？"><a href="#为什么要LVS？" class="headerlink" title="为什么要LVS？"></a>为什么要LVS？</h2><ul>
<li><p>lvs是基于四层的，效率更高；nginx是七层，效率可能有所损耗</p>
</li>
<li><p>通常是通过nginx做个一个反向代理访问后台的服务，通过负载均衡做这个高可用，但是nginx只有一台，运行在一个计算机结点上，nginx最大可以支持5万的并发。企业级项目不能支持。如果nginx挂了，后台服务就全访问不到了。主备nginx也扛不住，因此我们选取lvs+nginx</p>
</li>
<li><p>单台nginx肯定不能满足需求，需要nginx集群，我们选择lvs充当nginx集群的调度者</p>
</li>
</ul>
<h2 id="LVS的三种模式"><a href="#LVS的三种模式" class="headerlink" title="LVS的三种模式"></a>LVS的三种模式</h2><p>当处理完成后，lvs返回给用户，提供了三种方式</p>
<p>NAT模式<br>基于网络地址转换模式<br>NAT模式流量从Nginx返回给LVS，然后从LVS再次返回给用户</p>
<p>TUN模式<br>流量从Nginx不再经过LVS,直接返回给用户，这种模式的性能比NAT高<br><strong>ip隧道模式</strong>，弊端：需要每个结点配置nginx服务器，nginx的ip需要暴露出来</p>
<p>DR模式<br>流量进入转发给nginx和上面相同，不同的是nginx转发给用户的时候，创建一个router，根据vip router返回给用户</p>
<p>我们一般采用DR模式</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210806104352.png" alt="image-20210806104352335"></p>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>kafka学习笔记</title>
    <url>/2021/04/02/note/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="kafka学习笔记"><a href="#kafka学习笔记" class="headerlink" title="kafka学习笔记"></a>kafka学习笔记</h1><p>参考学习视频：<a href="https://www.biibii.com/video/BV1a4411B7V9?p=11">https://www.biibii.com/video/BV1a4411B7V9?p=11</a></p>
<p><a href="https://snaicimb.gitee.io/javaguide/#/docs/system-design/distributed-system/message-queue/Kafka%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=kafka%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93">JavaGuide中的总结</a></p>
<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h1><p>kafka是一个分布式消息中间件，支持分区的，多副本的，多订阅者的，基于zookeeper协调的分布式消息系统</p>
<p> 为什么使用消息队列？</p>
<p>异步、削峰、解耦</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221520708.png" alt="image-20220716221520708"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221532382.png" alt="image-20220716221532382"></p>
<p>左边是多线程的写法，右边是消息队列的写法</p>
<p>扩展功能变得非常方便，进行了解耦合，并且实现了削峰处理</p>
<p>kafka只能保证一个partition内的消息有序性</p>
<p>消息传递模式</p>
<p>消息队列-点对点</p>
<p>消息队列-发布订阅</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221544760.png" alt="image-20220716221544760"></p>
<p>kafka的特点</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221557854.png" alt="image-20220716221557854"></p>
<p> kafka基础架构</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221607794.png" alt="image-20220716221607794"></p>
<p>1）Producer：消息生产者，就是向 kafka broker 发消息的客户端；</p>
<p>2）Consumer：消息消费者，向 kafka broker 取消息的客户端；</p>
<p>3）Consumer Group（CG ）：消费者组，由多个consumer 组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。所有的消费者都属于某个消费者组，即 消费者组是逻辑上的一个订阅者。同一个消费者组的每个消费者不能消费同一个分区的消息，消费者组中的每个消费者必须消费不同的分区的消息，</p>
<p>4）Broker：一台 kafka服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker可以容纳多个topic。</p>
<p>5）Topic ：可以理解为一个队列，生产者和消费者面向的都是一个 topic；Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</p>
<p>6）Partition ：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个分区承当发往本topic的一部分消息，分区数等于一个消费者组中消费者的个数，每个 partition 是一个有序的队列；</p>
<p>7） Repica：副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个eader和若干个 foower。生产者和消费者只从eader中存取数据，foower 只是用来数据备份。</p>
<p>8）eader ：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是eader。</p>
<p>9）foower ：每个分区多个副本中的“从”，实时从eader 中同步数据，保持和 eader 数据的同步。eader 发生故障时，某个foower 会成为新的foower。</p>
<h1 id="2-kafka架构深入"><a href="#2-kafka架构深入" class="headerlink" title="2 kafka架构深入"></a>2 kafka架构深入</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>zookeeper的依赖：主要是用来选举，zookeeper不是kafka的性能瓶颈</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221620300.png" alt="image-20220716221620300"></p>
<p>  每一个topic有多个副本，每一个topic一定有一个eader，我们的读取都是从eader里面进行读写，另外两个副本用于冗余，一定要和eader做同步，它们会主动去eader拉数据，会按照轮训去eader查询是否有新的数据</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221634095.png" alt="image-20220716221634095"></p>
<p>每一个broker都维护这自己的offset偏移量，记录执行到的位置</p>
<p>kafka0.11.0，每一个topic分成多个分区</p>
<p>kafka只能保证一个分区内的有序的，不能保证全局的有效性</p>
<p> <img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221644052.png" alt="image-20220716221644052"></p>
<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221653715.png" alt="image-20220716221653715"></p>
<p>生产者的消息不断的追加到og文件末尾，为了防止og文件过大导致效率低下，kafka采用了分片和索引机制</p>
<h2 id="kafka生产者"><a href="#kafka生产者" class="headerlink" title="kafka生产者"></a>kafka生产者</h2><p>分区策略</p>
<p>1 分区的原因</p>
<p>（1）方便集群中扩展，提高负载能力，每个partition可以调整以适应所在机器，而一个topic由多个partition组成，因此集群可以适应任意大小的数据</p>
<p>（2）提高并发，因为可以以partition为单位进行读写</p>
<p>2 分区的原则</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221725213.png" alt="image-20220716221725213"></p>
<p>数据可靠性的保证</p>
<p>上面我们已经知道数据怎么发出去了，但是kafka可能由于网络问题，没有收到，那么怎么解决呢？</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221737856.png" alt="image-20220716221737856"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221745927.png" alt="image-20220716221745927"></p>
<p>这里所说的同步副本2n+1和n+1，指的是针对一个topic有多少个副本</p>
<p>kafka选取了第二种方案</p>
<p>ISR同步备份集</p>
<p>  思考一个情况，一个eader有10个foower，因为某个故障，迟迟不能同步，那么eader就要一直等下去，直到完成同步</p>
<p>  eader 维护了一个动态的 in-sync repica set (ISR)，意为和 eader 保持同步的 foower 集合。当 ISR 中的 foower 完成数据的同步之后，eader 就会给 foower 发送 ack。如果 foower长 时 间 未 向 eader 同 步ack 数 据 ， 则 该 foower 将 被 踢 出 ISR 。eader 发生故障之后，就会从 ISR 中选举新的 eader。</p>
<p>ack应答机制</p>
<p>​     对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等 ISR 中的 foower 全部接收成功。</p>
<p>​    所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡，选择以下的配置。</p>
<p>acks 参数配置：</p>
<p>​     0：producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还没有写入磁盘就已经返回，当 broker 故障时有可能 丢失数据；</p>
<p>​    1：producer 等待 broker 的 ack，partition 的 eader 落盘成功后返回 ack，如果在 foower同步成功之前 eader 故障，那么将会丢失数据</p>
<p>​    -1（a）：producer 等待 broker 的 ack，partition 的 eader 和 foower 全部落盘成功后才返回 ack。但是如果在 foower 同步完成后，broker 发送 ack 之前，eader 发生故障，那么会造成 数据重复。Kafka通过幂等性解决了这个数据重复的问题。</p>
<p> 数据一致性问题</p>
<p>针对ISR引入出了EO和HW两个概念：</p>
<p>每个og文件维护两个字段：</p>
<p>EO （og End Offset）：指的是每个副本最大的 offset ；</p>
<p>HW（High Watermark） 所有副本中最小的EO，HW之前的数据才对Consumer可见</p>
<p>（1 ）foower 故障</p>
<p>​    foower 发生故障后会被临时踢出 ISR，待该 foower 恢复后，foower 会读取本地磁盘记录的上次的 HW，并将 og 文件高于 HW 的部分截取掉，从 HW 开始向 eader 进行同步。等该 foower 的 EO 大于等于该 Partition 的 当前的 HW，即 foower 追上 eader 之后，就可以重新加入 ISR 了。</p>
<p>（2 ）eader 故障</p>
<p>​    eader 发生故障之后，会从 ISR 中通过竞争选出一个新的 eader，之后，为保证多个副本之间的数据一致性，其余的 foower 会先将各自的 og 文件高于 HW 的部分截掉，然后从新的 eader同步数据。</p>
<p>  注意： 这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221801773.png" alt="image-20220716221801773"></p>
<h2 id="kafka消费者"><a href="#kafka消费者" class="headerlink" title="kafka消费者"></a>kafka消费者</h2><p>消费</p>
<p>  consumer 采用 pu（拉）模式从 broker 中读取数据。</p>
<p>  push （推）模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pu 模式则可以根据 consumer 的消费能力以适当的速率消费消息。</p>
<p>  pu 模式不足之处是，如果 kafka 没有数据，消费者可能会陷入循环中，一直返回空数据。针对这一点，Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有数据可供消费，consumer 会等待一段时间之后再返回，这段时长即为 timeout。</p>
<p>分区分配策略</p>
<p>​     一个 consumer group 中有多个 consumer，一个 topic 有多个 partition，所以必然会涉及到 partition 的分配问题，即确定那个 partition 由哪个 consumer 来消费。</p>
<p>​     Kafka 有两种分配策略，一是 RoundRobin，一是 Range。</p>
<p>​     roundRobin按照组来划分的，range是按照主题来划分的</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221825679.png" alt="image-20220716221825679"></p>
<p>robin轮训会将整体看为一个组，可能造成业务逻辑错误</p>
<p>我们默认的策略是range</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221834487.png" alt="image-20220716221834487"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221844994.png" alt="image-20220716221844994"></p>
<p>offset的维护</p>
<p>​     由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢复后继续消费。</p>
<p>​    Kafka 0.9 版本之前，consumer 默认将 offset 保存在 Zookeeper 中，从 0.9 版本开始，consumer 默认将 offset 保存在 Kafka 一个内置的 topic 中，该 topic 为__consumer_offsets。</p>
<h2 id="kafka高效读取的原因"><a href="#kafka高效读取的原因" class="headerlink" title="kafka高效读取的原因"></a>kafka高效读取的原因</h2><p>1 kafka有分区这个概念</p>
<p>  每一个topic都有多个分区，可以并发的进行事务处理</p>
<p>2 顺序写磁盘</p>
<p>  单台kafka也比单台的消息队列快</p>
<p>  Kafka 的 producer 生产数据，要写入到 og 文件中，写的过程是一直追加到文件末端，为顺序写。官网有数据表明，同样的磁盘，顺序写能到 600M&#x2F;s，而随机写只有 100K&#x2F;s。这与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。</p>
<p>3零复制技术</p>
<h2 id="zookeeper在kafka中的作用"><a href="#zookeeper在kafka中的作用" class="headerlink" title="zookeeper在kafka中的作用"></a>zookeeper在kafka中的作用</h2><p>Kafka 集群中有一个 broker 会被选举为 Controer，负责管理集群 broker 的上下线，所有 topic 的分区、副本分配和 eader 选举等工作。</p>
<p>Controer 的管理工作都是依赖于 Zookeeper 的。</p>
<h1 id="3-Kafka-API"><a href="#3-Kafka-API" class="headerlink" title="3 Kafka API"></a>3 Kafka API</h1><p>  Kafka 的 Producer 发送消息采用的是 异步发送的方式。在消息发送的过程中，涉及到了两个线程 ——main 线程和 Sender 线程，以及 一个线程共享变量 ——RecordAccumuator。main 线程将消息发送给 RecordAccumuator，Sender 线程不断从 RecordAccumuator 中拉取消息发送到 Kafka broker。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221912823.png" alt="image-20220716221912823"></p>
<h1 id="4-面试"><a href="#4-面试" class="headerlink" title="4 面试"></a>4 面试</h1><h2 id="1-和其他消息队列相比-Kafka的优势在哪里？"><a href="#1-和其他消息队列相比-Kafka的优势在哪里？" class="headerlink" title="1 和其他消息队列相比,Kafka的优势在哪里？"></a>1 <a href="https://snaicimb.gitee.io/javaguide/#/docs/system-design/distributed-system/message-queue/Kafka%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=%E5%92%8C%E5%85%B6%E4%BB%96%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9B%B8%E6%AF%94kafka%E7%9A%84%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%A">和其他消息队列相比,Kafka的优势在哪里？</a></h2><p>我们现在经常提到 Kafka 的时候就已经默认它是一个非常优秀的消息队列了，我们也会经常拿它给 RocketMQ、RabbitMQ 对比。我觉得 Kafka 相比其他消息队列主要的优势如下：</p>
<p> 极致的性能 ：基于 Scaa 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。</p>
<p> 生态系统兼容性无可匹敌 ：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域</p>
<h2 id="2-kafka的消息队列模型"><a href="#2-kafka的消息队列模型" class="headerlink" title="2 kafka的消息队列模型"></a>2 kafka的消息队列模型</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221922587.png" alt="image-20220716221922587"></p>
<p>​     发布订阅模型（Pub-Sub） 使用主题（Topic） 作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。</p>
<h2 id="3-zookeeper的作用是什么？"><a href="#3-zookeeper的作用是什么？" class="headerlink" title="3 zookeeper的作用是什么？"></a>3 zookeeper的作用是什么？</h2><p>Kafka 集群中有一个 broker 会被选举为 Controer，负责管理集群 broker 的上下线，所有 topic 的分区、副本分配和 eader 选举等工作。</p>
<p>Controer 的管理工作都是依赖于 Zookeeper 的。</p>
<h2 id="4-kafka如何保证消息的消费有序"><a href="#4-kafka如何保证消息的消费有序" class="headerlink" title="4 kafka如何保证消息的消费有序"></a>4 kafka如何保证消息的消费有序</h2><p>​     每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。Kafka只能为我们保证Partition(分区) 中的消息有序，而不能保证 Topic(主题) 中的 Partition(分区) 的有序。</p>
<p>​    消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221932340.png" alt="image-20220716221932340"></p>
<h2 id="5-kafka如何保证消息不丢失"><a href="#5-kafka如何保证消息不丢失" class="headerlink" title="5 kafka如何保证消息不丢失"></a>5 kafka如何保证消息不丢失</h2><p>1 生产者丢失数据</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221939756.png" alt="image-20220716221939756"></p>
<p>2 消费者丢失数据</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221947102.png" alt="image-20220716221947102"></p>
<p>3 kafka丢失数据</p>
<p>可以参考上面kafka生产者，数据可靠性的保证</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716221954274.png" alt="image-20220716221954274"></p>
<p>ISR </p>
<p>高水位和低水位</p>
<p>副本数据的同步策略，要么同步一半的时候返回ack，要么同步全部完成的时候返回ack，kafka选取第二种方式</p>
<h2 id="6-kafka如何保证不重复消费数据"><a href="#6-kafka如何保证不重复消费数据" class="headerlink" title="6 kafka如何保证不重复消费数据"></a>6 kafka如何保证不重复消费数据</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220716222002509.png" alt="image-20220716222002509"></p>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode刷题总结归纳</title>
    <url>/2021/02/02/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Hot100需要注意的题目"><a href="#Hot100需要注意的题目" class="headerlink" title="Hot100需要注意的题目"></a>Hot100需要注意的题目</h2><ul>
<li><input disabled="" type="checkbox"> 647 回文子串</li>
<li><input disabled="" type="checkbox"> 188 买卖股票的时机</li>
<li><input disabled="" type="checkbox"> 43 字符串乘法</li>
<li><input disabled="" type="checkbox"> 1143 最长公共子序列</li>
<li><input disabled="" type="checkbox"> 148 快排链表</li>
<li><input disabled="" type="checkbox"> 213 打家劫舍II</li>
<li><input disabled="" type="checkbox"> 678 有效的括号字符串</li>
<li><input disabled="" type="checkbox"> 42 接雨水（单调栈）</li>
<li><input disabled="" type="checkbox"> 剑指offer51 逆序对（归并排序）</li>
<li><input disabled="" type="checkbox"> 93.复原ip地址</li>
<li><input disabled="" type="checkbox"> 131.分割回文串</li>
<li><input checked="" disabled="" type="checkbox"> 146LRU：yyds</li>
<li><input checked="" disabled="" type="checkbox"> 148排序链表：归并排序</li>
<li><input checked="" disabled="" type="checkbox"> 207课程表：拓扑排序</li>
<li><input checked="" disabled="" type="checkbox"> 208<strong>实现前缀树 字典树</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>215 topk 堆排序</strong></li>
<li><input checked="" disabled="" type="checkbox"> 236 二叉树公共祖先</li>
<li><input checked="" disabled="" type="checkbox"> 279 完全平方数 dp</li>
<li><input checked="" disabled="" type="checkbox"> <strong>309 最佳买卖股票的时机 dp</strong></li>
<li><input checked="" disabled="" type="checkbox"> 322零钱兑换 完全背包</li>
<li><input checked="" disabled="" type="checkbox"> <strong>337 打家劫舍III dp</strong></li>
<li><input checked="" disabled="" type="checkbox"> 347 前topk高频（优先队列）</li>
<li><input checked="" disabled="" type="checkbox"> 406 <strong>根据身高重建队列</strong>（看一下list添加元素到指定index）</li>
<li><input checked="" disabled="" type="checkbox"> 416 分割等和子集（01背包）</li>
<li><input checked="" disabled="" type="checkbox"> 437 路径综合III</li>
<li><input checked="" disabled="" type="checkbox"> 438 找到字符串中所有字母异位词</li>
<li><input checked="" disabled="" type="checkbox"> 538 把二叉搜索树转换成累加树</li>
<li><input checked="" disabled="" type="checkbox"> 617 合并二叉树（递归）</li>
<li><input checked="" disabled="" type="checkbox"> <strong>139 单词拆分（dp)</strong></li>
<li><input checked="" disabled="" type="checkbox"> 128最长连续子序列（map)</li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></li>
<li><input checked="" disabled="" type="checkbox"> 105 前序和中序建立二叉树</li>
<li><input checked="" disabled="" type="checkbox"> <strong>96 不同的二叉搜索树</strong></li>
<li><input checked="" disabled="" type="checkbox"> 101 对称二叉树</li>
<li><input checked="" disabled="" type="checkbox"> 84 <strong>柱形图中的最大矩形</strong></li>
<li><input checked="" disabled="" type="checkbox"> 79 单词搜索（回溯）</li>
<li><input checked="" disabled="" type="checkbox"> 56 <strong>合并区间（排序+合并）</strong></li>
<li><input checked="" disabled="" type="checkbox"> 46 全排列（回溯） &amp;&amp; II</li>
<li><input checked="" disabled="" type="checkbox"> 39 组合数（回溯）</li>
<li><input checked="" disabled="" type="checkbox"> <strong>33 搜索旋转排序数组（二分）,真重要，看我239那个qq账号提交的个人解答</strong></li>
<li><input checked="" disabled="" type="checkbox"> 31 下一个排列</li>
<li><input checked="" disabled="" type="checkbox"> 32 最长有效括号</li>
<li><input checked="" disabled="" type="checkbox"> 23 合并K个升序列表（优先队列）</li>
<li><input checked="" disabled="" type="checkbox"> 15 三数之和（双指针）</li>
<li><input checked="" disabled="" type="checkbox"> <strong>1004 最大连续1的个数 (滑动窗口模板)</strong></li>
</ul>
<h2 id="0-基础"><a href="#0-基础" class="headerlink" title="0 基础"></a>0 基础</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>之前一直没用 addAll 这个，都是遍历再添加，学会了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; t = (ArrayList&lt;Integer&gt;) Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        list.addAll(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="基本类型和包装类"><a href="#基本类型和包装类" class="headerlink" title="基本类型和包装类"></a>基本类型和包装类</h3><p>我在用stack.remove()方法时遇到了这个问题<br>stack.remove(int cur)<br>stack.remobe(Object obj)<br>当时我需要移除一个指定的元素，因此需要用包装类，不能直接用int类型！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>); <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a.intValue(); <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure>

<h3 id="列表和数组长度"><a href="#列表和数组长度" class="headerlink" title="列表和数组长度"></a>列表和数组长度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      ArrayList&lt;TestMain&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">      s.length();        </span><br></pre></td></tr></table></figure>

<h3 id="数组比较相等"><a href="#数组比较相等" class="headerlink" title="数组比较相等"></a>数组比较相等</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="type">int</span>[] aToz = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] aTozCur = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];           </span><br><span class="line"><span class="keyword">if</span>(Arrays.equals(aTozCur,aToz))&#123;</span><br><span class="line">     	res.add(i-lenp+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="列表根据下标插入元素"><a href="#列表根据下标插入元素" class="headerlink" title="列表根据下标插入元素"></a>列表根据下标插入元素</h3><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">https://leetcode-cn.com/problems/queue-reconstruction-by-height/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> people.length;</span><br><span class="line">        <span class="comment">// 排序，从身高大到小排序，然后根据第二位升序排序</span></span><br><span class="line">        Arrays.sort(people,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1,<span class="type">int</span>[] o2)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1[<span class="number">0</span>]o2[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> o2[<span class="number">0</span>]-o1[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行插入</span></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[len][<span class="number">2</span>];</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] arr:people)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> arr[<span class="number">1</span>];</span><br><span class="line">            list.add(idx,arr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] arr:list)&#123;</span><br><span class="line">            res[cnt++] = arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if(map.containsKey())&#123;</span></span><br><span class="line">        <span class="comment">//    ...</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> map.getOrDefault(nums[i],<span class="number">0</span>);</span><br><span class="line">            map.put(nums[i],a+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Integer key:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key)<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map使用</p>
<p><a href="https://leetcode-cn.com/problems/group-anagrams/">https://leetcode-cn.com/problems/group-anagrams/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">// map存储，key是顺序的结果，value是列表</span></span><br><span class="line">        HashMap&lt;String,List&lt;String&gt;&gt;map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:strs)&#123;</span><br><span class="line">            <span class="type">char</span>[] chs = s.toCharArray();</span><br><span class="line">            Arrays.sort(chs);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.valueOf(chs);</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">                map.put(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(key).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">peek()<span class="comment">//返回队首元素</span></span><br><span class="line">poll()<span class="comment">//返回队首元素，队首元素出队列</span></span><br><span class="line">add()<span class="comment">//添加元素</span></span><br><span class="line">size()<span class="comment">//返回队列元素个数</span></span><br><span class="line">isEmpty()<span class="comment">//判断队列是否为空，为空返回true,不空返回false</span></span><br></pre></td></tr></table></figure>

<p>合并topK个升序列表</p>
<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="comment">// 给定的是链表数组！</span></span><br><span class="line">        <span class="comment">// Java默认的优先队列就是小顶堆</span></span><br><span class="line">        <span class="keyword">if</span>(lists.length0) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Queue&lt;ListNode&gt; que = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(a.val-b.val));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lists.length;i++)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> lists[i];</span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                que.add(node);</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依次取出优先队列的首元素，组成一个链表</span></span><br><span class="line">        <span class="comment">// 时间复杂度o(Klogn)</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dump;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="comment">// 去除node先前后面连接的节点</span></span><br><span class="line">            node.next = <span class="literal">null</span>;</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pushed.length!=popped.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;popped.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.size()<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt&lt;pushed.length)&#123;</span><br><span class="line">                    s.add(pushed[cnt++]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(s.peek()!=popped[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;=pushed.length)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                s.add(pushed[cnt++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈顶元素和poped相同，出栈</span></span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向LinkedList里面添加元素"><a href="#向LinkedList里面添加元素" class="headerlink" title="向LinkedList里面添加元素"></a>向LinkedList里面添加元素</h3><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</a></p>
<p>注意这块代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(node.leftnull &amp;&amp; node.rightnull &amp;&amp; target0)&#123;</span><br><span class="line">            <span class="comment">// res.add(lst); 这样写就是错误的！！</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(lst));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>上面的写法就是错误的！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node,<span class="type">int</span> target,LinkedList&lt;Integer&gt; lst)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nodenull) <span class="keyword">return</span> ;</span><br><span class="line">        lst.add(node.val);</span><br><span class="line">        target-=node.val;</span><br><span class="line">        <span class="keyword">if</span>(node.leftnull &amp;&amp; node.rightnull &amp;&amp; target0)&#123;</span><br><span class="line">            <span class="comment">// res.add(lst); 这样写就是错误的！！</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(lst));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left,target,lst);</span><br><span class="line">        dfs(node.right,target,lst);</span><br><span class="line">        lst.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; lst = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,target,lst);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="copyOfRange"><a href="#copyOfRange" class="headerlink" title="copyOfRange"></a>copyOfRange</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210723105043.png" alt="image-20210723105037906"></p>
<h2 id="1-排序问题"><a href="#1-排序问题" class="headerlink" title="1 排序问题"></a>1 排序问题</h2><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>快排原理:<a href="https://www.jianshu.com/p/7631d95fdb0b">https://www.jianshu.com/p/7631d95fdb0b</a></p>
<p><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html">https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html</a></p>
<p>这里的等于一定一定不要漏掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&lt;j &amp;&amp; nums[j]&gt;=pivot) j--;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j &amp;&amp; nums[i]&lt;=pivot) i++;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 哨兵结点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[l];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivot) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivot) i++;</span><br><span class="line">        <span class="comment">// 交换i和j的位置</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换哨兵结点和前后指针相遇的点</span></span><br><span class="line">    nums[l] = nums[i];</span><br><span class="line">    nums[i] = pivot;</span><br><span class="line">    quickSort(nums, l, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a+b&lt;b+a</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(String[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> i=l,j=r;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">          	<span class="comment">//这里一定是&gt;=</span></span><br><span class="line">            <span class="comment">// while(i&lt;j &amp;&amp; nums[j]&gt;=pivot) j--;</span></span><br><span class="line">            <span class="comment">// while(i&lt;j &amp;&amp; nums[i]&lt;=pivot) i++;</span></span><br><span class="line">            <span class="comment">// 大的放在后面</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; (nums[j]+nums[l]).compareTo(nums[l]+nums[j])&gt;=<span class="number">0</span>) j--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; (nums[i]+nums[l]).compareTo(nums[l]+nums[i])&lt;=<span class="number">0</span>) i++;</span><br><span class="line">            pivot = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = pivot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换哨兵结点和前后指针相遇的点</span></span><br><span class="line">        nums[i] = nums[l];</span><br><span class="line">        nums[l] = pivot;	<span class="comment">//pivot前面记录了nums[i]</span></span><br><span class="line">        quickSort(nums,l,i-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            mergeSort(arr, low, mid);</span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">            merge(arr, low, mid, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                tmp[cnt++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[cnt++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            tmp[cnt++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">            tmp[cnt++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用临时数组覆盖先前的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; tmp.length; idx++) &#123;</span><br><span class="line">            arr[low + idx] = tmp[idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        s.mergeSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : a) &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排列表"><a href="#归并排列表" class="headerlink" title="归并排列表"></a>归并排列表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归的中止条件</span></span><br><span class="line">        <span class="comment">// head.nextnull 不写会报错</span></span><br><span class="line">        <span class="keyword">if</span>(headnull || head.nextnull)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mid</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="literal">null</span> &amp;&amp; fast.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(tmp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// merge进行合并</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> t;</span><br><span class="line">        <span class="keyword">while</span>(left!=<span class="literal">null</span> &amp;&amp; right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val &lt; right.val)&#123;</span><br><span class="line">                <span class="comment">// 顺序很重要！！</span></span><br><span class="line">                t.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            t = t.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="literal">null</span>) t.next = left;</span><br><span class="line">        <span class="keyword">if</span>(right!=<span class="literal">null</span>) t.next = right;</span><br><span class="line">      	<span class="comment">//返回的dump.next</span></span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(arrnull || arr.length &lt; <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i -<span class="number">1</span>; j++) &#123;   <span class="comment">// 这里说明为什么需要-1</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序TopK问题"><a href="#堆排序TopK问题" class="headerlink" title="堆排序TopK问题"></a>堆排序TopK问题</h3><p>建堆的过程：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p>
<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p>
<p>面试官不希望你API写出这道题目，你可以手写建堆完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 公司面试希望你手动实现堆排序</span></span><br><span class="line">        <span class="comment">// 堆排序</span></span><br><span class="line">        heapSort(nums,<span class="number">0</span>,nums.length,k);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> begin,<span class="type">int</span> end,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始调整顺序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=end/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            adjustHeap(nums,i,end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第k大元素已经排好序</span></span><br><span class="line">        <span class="keyword">if</span>(endnums.length-k) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(end1) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次交换头元素和最后一个元素</span></span><br><span class="line">        swap(nums,<span class="number">0</span>,end-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 继续递归</span></span><br><span class="line">        heapSort(nums,begin,end-<span class="number">1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="comment">// 当前节点是i，那么左节点是2*i+1,右节点是2*i+2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;end &amp;&amp; nums[left]&gt;nums[i]) swap(nums,left,i);</span><br><span class="line">        <span class="keyword">if</span>(right&lt;end &amp;&amp; nums[right]&gt;nums[i]) swap(nums,right,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java默认是小顶堆，这里我们将小顶堆转换成大顶堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 堆来实现topk问题</span></span><br><span class="line">        <span class="comment">// Java默认提供的priority实现的是小顶堆</span></span><br><span class="line">        <span class="keyword">if</span>(arr.length0 || k0)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(b-a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(que.size()&lt;k)&#123;</span><br><span class="line">                que.add(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(que.peek()&gt;arr[i])&#123;</span><br><span class="line">                    que.poll();</span><br><span class="line">                    que.add(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> pq:que)&#123;</span><br><span class="line">            res[cnt++] = pq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><a href="https://leetcode-cn.com/problems/course-schedule/">https://leetcode-cn.com/problems/course-schedule/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        <span class="comment">// 拓扑排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立一个临接矩阵</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先统计入度为0的节点，加入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] cp:prerequisites)&#123;</span><br><span class="line">            indegree[cp[<span class="number">0</span>]]++;</span><br><span class="line">            adj.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i]<span class="number">0</span>)&#123;</span><br><span class="line">                que.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">font</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从临接矩阵拿所有相连的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> cur : adj.get(font))&#123;</span><br><span class="line">                indegree[cur]--;</span><br><span class="line">                <span class="keyword">if</span>(indegree[cur]<span class="number">0</span>)&#123;</span><br><span class="line">                    que.add(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义排序comparator"><a href="#自定义排序comparator" class="headerlink" title="自定义排序comparator"></a>自定义排序comparator</h3><p>一个很坑的点！！</p>
<p>自定义排序的这个数组不能是int类型的！！！！必须是Integer类型的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  	<span class="comment">//不能使用基本数据类型</span></span><br><span class="line">    Integer[] arr = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">54</span>,<span class="number">21</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//降序</span></span><br><span class="line">    Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    		<span class="comment">//重写compare方法，最好加注解，不加也没事</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">          	<span class="comment">//返回值&gt;0交换</span></span><br><span class="line">            <span class="keyword">return</span> b-a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">Collections.sort(arrayList,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a,Integer b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">https://leetcode-cn.com/problems/queue-reconstruction-by-height/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        <span class="comment">// 先按照高度从高向低排</span></span><br><span class="line">        Arrays.sort(people,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a ,<span class="type">int</span>[] b)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">0</span>]b[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> b[<span class="number">0</span>]-a[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 更加第二个位置进行插入</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] ans:people)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> res.size();</span><br><span class="line">            <span class="keyword">if</span>(size&lt;=ans[<span class="number">1</span>])&#123;</span><br><span class="line">                res.add(ans);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果比size要大，那么需要插入制定的位置</span></span><br><span class="line">                res.add(ans[<span class="number">1</span>],ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] t:res)&#123;</span><br><span class="line">            result[cnt++] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2 字符串"></a>2 字符串</h2><h3 id="StirngBuilder"><a href="#StirngBuilder" class="headerlink" title="StirngBuilder"></a>StirngBuilder</h3><p><a href="https://www.cnblogs.com/superjustin/p/12250571.html">https://www.cnblogs.com/superjustin/p/12250571.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一、创建Stringbuilder对象</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">strB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、append(String str)/append(Char c)：字符串连接</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder:&quot;</span>+strB.append(<span class="string">&quot;ch&quot;</span>).append(<span class="string">&quot;111&quot;</span>).append(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//return &quot;StringBuilder:ch111c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、toString()：返回一个与构建起或缓冲器内容相同的字符串</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;String:&quot;</span>+strB.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//return &quot;String:ch111c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、appendcodePoint(<span class="type">int</span> cp)：追加一个代码点，并将其转换为一个或两个代码单元并返回<span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder.appendCodePoint:&quot;</span>+strB.appendCodePoint(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//return &quot;StringBuilder.appendCodePoint:ch111c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、setCharAt(<span class="type">int</span> i, <span class="type">char</span> c)：将第 i 个代码单元设置为 c（可以理解为替换）</span><br><span class="line"></span><br><span class="line">strB.setCharAt(<span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder.setCharAt:&quot;</span> + strB);</span><br><span class="line"></span><br><span class="line"><span class="comment">//return &quot;StringBuilder.setCharAt:chd11c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、insert(<span class="type">int</span> offset, String str)/insert(<span class="type">int</span> offset, Char c)：在指定位置之前插入字符(串)</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder.insertString:&quot;</span>+ strB.insert(<span class="number">2</span>, <span class="string">&quot;LS&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//return &quot;StringBuilder.insertString:chLSd11c&quot;</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder.insertChar:&quot;</span>+ strB.insert(<span class="number">2</span>, <span class="string">&#x27;L&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//return &quot;StringBuilder.insertChar:chLLSd11c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、delete(<span class="type">int</span> startIndex,<span class="type">int</span> endIndex)：删除起始位置（含）到结尾位置（不含）之间的字符串</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder.delete:&quot;</span>+ strB.delete(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//return &quot;StringBuilder.delete:chSd11c&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><p>字符串截取函数substring，是小写字符！</p>
<h3 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lens</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenp</span> <span class="operator">=</span> p.length();</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(lens&lt;lenp) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] ps = p.toCharArray();</span><br><span class="line">    Arrays.sort(ps);</span><br><span class="line">    p = Arrays.toString(ps);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lenp-<span class="number">1</span>;i&lt;lens;i++)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(pre,i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 比较sub和p是否相等</span></span><br><span class="line">        <span class="type">char</span>[] subs = sub.toCharArray();</span><br><span class="line">        Arrays.sort(subs);</span><br><span class="line">        sub = Arrays.toString(subs);</span><br><span class="line">        <span class="keyword">if</span>(sub.equals(p))&#123;</span><br><span class="line">            res.add(i-lenp+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pre++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-二分"><a href="#3-二分" class="headerlink" title="3 二分"></a>3 二分</h2><h3 id="二分边界模板"><a href="#二分边界模板" class="headerlink" title="二分边界模板"></a>二分边界模板</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左区间端点可能包含目标值的时候</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right + <span class="number">1</span>)&gt;&gt;&gt;<span class="number">1</span>;<span class="comment">//中点选择右中位数</span></span><br><span class="line">    <span class="keyword">if</span> ( nums[mid] &gt; target)&#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        left = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右区间端点可能包含目标值的时候</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right)&gt;&gt;&gt;<span class="number">1</span>;<span class="comment">//中点选择左中位数</span></span><br><span class="line">    <span class="keyword">if</span> ( nums[mid] &lt; target)&#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找某个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//标准的二分模板允许左闭右闭[left, right]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]target)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            	<span class="comment">//如果mid都大于target也就是说 右边界可以缩小到mid-1</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            	<span class="comment">//同理 左边界可以缩小的mid +1</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><p>二分查找无非查找一个目标值，查找左边界，查找有边界</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTarget</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]  target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLeft</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可能l越界了</span></span><br><span class="line">        <span class="keyword">if</span> (l  nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[l]  target ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRight</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l - <span class="number">1</span>]  target ? l - <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">BinarySearch</span> <span class="variable">bs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearch</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> bs.findTarget(arr, <span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;find index is = &quot;</span> + index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left_index</span> <span class="operator">=</span> bs.findLeft(arr, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;find left boarder is = &quot;</span> + left_index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">right_index</span> <span class="operator">=</span> bs.findRight(arr, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;find right boarder is = &quot;</span> + right_index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="旋转数组中寻找数据"><a href="#旋转数组中寻找数据" class="headerlink" title="旋转数组中寻找数据"></a>旋转数组中寻找数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span> <span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 先找到旋转点的位置index</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 寻找一个左边界</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=nums[<span class="number">0</span>])&#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftlen) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 判断left是不是转折点</span></span><br><span class="line">        <span class="keyword">if</span>(left0 || (left+<span class="number">1</span>&lt;len &amp;&amp; nums[left]&lt;nums[left+<span class="number">1</span>]))&#123;</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">            right = len-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left是转折点，判断在前面一段还是后面一段</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;=nums[<span class="number">0</span>])&#123;</span><br><span class="line">            right = left-<span class="number">1</span>;</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = len-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二分查找target</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target) right = mid -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-dp"><a href="#4-dp" class="headerlink" title="4 dp"></a>4 dp</h2><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210514213611.png" alt="image-20210514213611117"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(snull || s.length()&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="comment">// dp问题</span></span><br><span class="line">        <span class="comment">// dp[i][j]表示从i-j是不是为回文串</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxx</span> <span class="operator">=</span> <span class="number">1</span>,begin =<span class="number">0</span>,end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意j必须从1开始，要么就会越界了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)s.charAt(j) &amp;&amp; (j-i&lt;=<span class="number">2</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;maxx)&#123;</span><br><span class="line">                        maxx = j-i+<span class="number">1</span>;</span><br><span class="line">                        begin = i;</span><br><span class="line">                        end = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回文串的个数"><a href="#回文串的个数" class="headerlink" title="回文串的个数"></a>回文串的个数</h3><p><a href="https://leetcode-cn.com/problems/palindromic-substrings/">https://leetcode-cn.com/problems/palindromic-substrings/</a></p>
<p>一定要注意那个循环是j在外围！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length()<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=j;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)s.charAt(j) &amp;&amp; (j-i&lt;=<span class="number">2</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="01背包问题、完全背包"><a href="#01背包问题、完全背包" class="headerlink" title="01背包问题、完全背包"></a>01背包问题、完全背包</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/image-20220703234325613.png" alt="image-20220703234325613"></p>
<p>背包问题参考背包九讲</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//01背包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= V[i]; j--) &#123;</span><br><span class="line">        f[j] = max(f[j], f[j-V[i]] + W[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> V[i]; j &lt;= m; j++) &#123;</span><br><span class="line">        f[j] = max(f[j], f[j-V[i]] + W[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210516194851.png" alt="image-20210516194851671"></p>
<p><a href="https://leetcode-cn.com/problems/target-sum/">https://leetcode-cn.com/problems/target-sum/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 494</span></span><br><span class="line"><span class="comment"> * 输入: nums: [1, 1, 1, 1, 1], S: 3</span></span><br><span class="line"><span class="comment"> * 输出: 5</span></span><br><span class="line"><span class="comment"> * 解释:</span></span><br><span class="line"><span class="comment"> * -1+1+1+1+1 = 3</span></span><br><span class="line"><span class="comment"> * +1-1+1+1+1 = 3</span></span><br><span class="line"><span class="comment"> * +1+1-1+1+1 = 3</span></span><br><span class="line"><span class="comment"> * +1+1+1-1+1 = 3</span></span><br><span class="line"><span class="comment"> * +1+1+1+1-1 = 3</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * sum(P) 前面符号为+的集合；sum(N) 前面符号为减号的集合</span></span><br><span class="line"><span class="comment"> * 所以题目可以转化为</span></span><br><span class="line"><span class="comment"> * sum(P) - sum(N) = target </span></span><br><span class="line"><span class="comment"> * =&gt; sum(nums) + sum(P) - sum(N) = target + sum(nums)</span></span><br><span class="line"><span class="comment"> * =&gt; 2 * sum(P) = target + sum(nums) </span></span><br><span class="line"><span class="comment"> * =&gt; sum(P) = (target + sum(nums)) / 2</span></span><br><span class="line"><span class="comment"> * 因此题目转化为01背包，也就是能组合成容量为sum(P)的方式有多少种</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> S)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; S || (sum + S) % <span class="number">2</span>  <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> (sum + S) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[w + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> w; j &gt;= num; j--) &#123;</span><br><span class="line">            dp[j] += dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>416 分割等和子集：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/submissions/">https://leetcode-cn.com/problems/partition-equal-subset-sum/submissions/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 01背包问题</span></span><br><span class="line">        <span class="comment">// 每个元素都是可以选或者不选，要求是否可以装满target/2</span></span><br><span class="line">        <span class="comment">// 判断容量为sum/2的背包能装下的最大数是不是sum/2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">21</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=target;j&gt;=num;j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j],dp[j-num]+num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target]target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完全平方和"><a href="#完全平方和" class="headerlink" title="完全平方和"></a>完全平方和</h3><p>完全平方和：<a href="https://leetcode-cn.com/problems/perfect-squares/">https://leetcode-cn.com/problems/perfect-squares/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 完全背包问题</span></span><br><span class="line">        <span class="comment">// 内循环是顺序</span></span><br><span class="line">        <span class="comment">// dp[i]表示组成数字i时的最少完全平方数的个数</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j*j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="comment">// 当前这个j物品选或者不选</span></span><br><span class="line">                dp[i] = Math.min(dp[i],dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长公共子串LCS"><a href="#最长公共子串LCS" class="headerlink" title="最长公共子串LCS"></a>最长公共子串LCS</h3><p><a href="https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=117&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=117&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">LCS</span> <span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str1.length(),len2 = str2.length();</span><br><span class="line">        <span class="comment">// dp[i][j]表示以str1[i]结尾和以str2[j]结尾的字符串的公共子串的最大长度</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxx</span> <span class="operator">=</span> <span class="number">0</span>,index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str1.charAt(i)str2.charAt(j))&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j+<span class="number">1</span>]&gt;maxx)&#123;</span><br><span class="line">                        maxx = dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                        index = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(index-maxx+<span class="number">1</span>,index+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-设计模式"><a href="#5-设计模式" class="headerlink" title="5 设计模式"></a>5 设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.pattern.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarvingSingleon</span> &#123;</span><br><span class="line">    <span class="comment">// static确保唯一性</span></span><br><span class="line">    <span class="comment">// private防止外界通过s.starvingSingleton()生成实例</span></span><br><span class="line">    <span class="comment">// final一旦初始化就不能改变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StarvingSingleon</span> <span class="variable">starvingSingleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StarvingSingleon</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StarvingSingleon</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StarvingSingleon <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> starvingSingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(StarvingSingleon.getInstance());</span><br><span class="line">        System.out.println(StarvingSingleon.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.pattern.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyDoubleCheckSingleton</span> &#123;</span><br><span class="line">    <span class="comment">// 为什么要加上volatile关键字</span></span><br><span class="line">    <span class="comment">// lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton();这个步骤实际上是分成三个步骤的</span></span><br><span class="line">    <span class="comment">// 但是执行顺序并不是固定的，可能线程1执行了步骤1和3，还没有执行步骤2，即instance还没有被初始化</span></span><br><span class="line">    <span class="comment">// 虽然instance没有初始化，但是已经分配了内存空间</span></span><br><span class="line">    <span class="comment">// 如果此时其他线程2进入第一个if判断，由于分配了空间,不为null，就直接返回结果了</span></span><br><span class="line">    <span class="comment">// volatile修饰的关键字可以禁止指令重排！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckSingleton lazyDoubleCheckSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyDoubleCheckSingleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检测</span></span><br><span class="line">        <span class="keyword">if</span>(lazyDoubleCheckSingletonnull)&#123;</span><br><span class="line">            <span class="comment">// 同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lazyDoubleCheckSingleton)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lazyDoubleCheckSingletonnull)&#123;</span><br><span class="line">                    <span class="comment">// 这个步骤是分了三个步骤完成的</span></span><br><span class="line">                    <span class="comment">// memory = allocate()  1分配空间</span></span><br><span class="line">                    <span class="comment">// instance(memory)     2初始化对象</span></span><br><span class="line">                    <span class="comment">// instance = memory()  3设置instance指向分配的内存地址，此时instance！=null</span></span><br><span class="line">                    lazyDoubleCheckSingleton = <span class="keyword">new</span> <span class="title class_">LazyDoubleCheckSingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyDoubleCheckSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真的安全吗？可以用反射来攻击这个模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> StarvingSingleon.class;</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// 由于构造函数是私有的</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// starving并不安全</span></span><br><span class="line">        <span class="comment">// org.pattern.singleton.StarvingSingleon@43a25848</span></span><br><span class="line">        <span class="comment">// org.pattern.singleton.StarvingSingleon@3ac3fd8b</span></span><br><span class="line">        System.out.println(constructor.newInstance());</span><br><span class="line">        System.out.println(StarvingSingleon.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>枚举方式实现安全的单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.pattern.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过看反射的源码，可以看出反射在通过newInstance创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败。</span></span><br><span class="line"><span class="comment">// 枚举类型不能通过反射创建newInstance()创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumStarvingSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EnumStarvingSingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumStarvingSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ContainerHolder.HOLDER.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">ContainerHolder</span>&#123;</span><br><span class="line">        <span class="comment">// 枚举的常量</span></span><br><span class="line">        HOLDER;</span><br><span class="line">        <span class="keyword">private</span> EnumStarvingSingleton instance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举类也可以有构造器，构造器默认都是private修饰，而且只能是private。因为枚举类的实例不能让外界来创建！</span></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">ContainerHolder</span><span class="params">()</span>&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">EnumStarvingSingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ContainerHolder.class;</span><br><span class="line">        <span class="comment">// 报错，无法通过构造函数构造</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 枚举的构造函数</span></span><br><span class="line"><span class="comment">         *     protected Enum(String name, int ordinal) &#123;</span></span><br><span class="line"><span class="comment">         *         this.name = name;</span></span><br><span class="line"><span class="comment">         *         this.ordinal = ordinal;</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(EnumStarvingSingleton.getInstance());</span><br><span class="line">        System.out.println(constructor.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双重校验的单例模式"><a href="#双重校验的单例模式" class="headerlink" title="双重校验的单例模式"></a>双重校验的单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleIntance</span> &#123;</span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleIntance</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MySingleIntance singleIntance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySingleIntance <span class="title function_">getSingleIntance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 减少性能开销</span></span><br><span class="line">        <span class="keyword">if</span>(singleIntancenull)&#123;</span><br><span class="line">            <span class="comment">// 线程A和B同时到这个地方，A先拿到锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果A释放锁，B就进来了，这个if</span></span><br><span class="line">                <span class="comment">// 为了防止生成多个重复的对象</span></span><br><span class="line">                <span class="keyword">if</span>(singleIntancenull)&#123;</span><br><span class="line">                    singleIntance = <span class="keyword">new</span> <span class="title class_">MySingleIntance</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleIntance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.bilibili.com/video/BV1dA411a7qB?from=search&amp;seid=8454062223519003881">https://www.bilibili.com/video/BV1dA411a7qB?from=search&amp;seid=8454062223519003881</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重校验锁实例</span></span><br><span class="line"><span class="comment"> * 1 为什么要进行两次非空校验</span></span><br><span class="line"><span class="comment"> * 第一个 if 判断是为了减少性能开销</span></span><br><span class="line"><span class="comment"> * 第二个 if 判断是为了避免生成多个对象实例。</span></span><br><span class="line"><span class="comment"> * 2 为什么要用volatile关键字？</span></span><br><span class="line"><span class="comment"> * 为了禁止JVM的指令重排</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="comment">// 构造函数私有化，外部不能通过构造函数自己创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile保证可见性质并且防止JVM进行指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingleInstance singleInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleInstance  <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleInstance.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleInstance  <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleInstance = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-树"><a href="#6-树" class="headerlink" title="6 树"></a>6 树</h2><h3 id="前序和中序建立二叉树"><a href="#前序和中序建立二叉树" class="headerlink" title="前序和中序建立二叉树"></a>前序和中序建立二叉树</h3><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">        <span class="keyword">if</span>(len0) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">root_val</span> <span class="operator">=</span> preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">root_index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root_val);</span><br><span class="line">        <span class="comment">// 寻找根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]root_val)&#123;</span><br><span class="line">                root_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归建立二叉树</span></span><br><span class="line">        <span class="comment">// preorder为什么从1开始呢？因为root是第0个节点，rootIndex是中序遍历中root节点的下标</span></span><br><span class="line">        root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,root_index+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,root_index));</span><br><span class="line">        root.right = buildTree(Arrays.copyOfRange(preorder,root_index+<span class="number">1</span>,len),Arrays.copyOfRange(inorder,root_index+<span class="number">1</span>,len));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TireNode</span>&#123;</span><br><span class="line">        TireNode[] next;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TireNode</span><span class="params">()</span>&#123;</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            next = <span class="keyword">new</span> <span class="title class_">TireNode</span>[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    TireNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TireNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(Character ch:word.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next[ch-<span class="string">&#x27;a&#x27;</span>]<span class="literal">null</span>)&#123;</span><br><span class="line">                node.next[ch-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TireNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next[ch-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(Character ch:word.toCharArray())&#123;</span><br><span class="line">            node = node.next[ch-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(nodenull) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(Character ch:prefix.toCharArray())&#123;</span><br><span class="line">            node = node.next[ch-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(nodenull) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="如何写树的递归（-）"><a href="#如何写树的递归（-）" class="headerlink" title="如何写树的递归（**）"></a>如何写树的递归（**）</h3><p>我们用二叉树展开成链表这个例子</p>
<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/</a></p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210613151513.png" alt="image-20210613151507169" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(rootnull) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 先把左右树都捋直了</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在是两棵捋直的左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1 flatten的操作理解为把给定的一棵树捋直并放在右子树上<br>2 我们先通过两个flatten，将左右都捋直<br>3 然后对两个捋直的树left和right，通通放在根节点root的右侧</p>
<p>递归的重点在于要想好flatten的含义，并且要从整体上把握递归，不要去想底下具体分支的流程，从整体把握</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210613152449.png" alt="image-20210613152449932" style="zoom:50%;" />

<p>掌握这个方法会发现递归写树轻松了</p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a></p>
<p>比如124二叉树的最大路径和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxx</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calMaxValue</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nodenull) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> calMaxValue(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> calMaxValue(node.right);</span><br><span class="line">        <span class="keyword">return</span> calThreeMax(node.val,node.val+leftMax,node.val+rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历树的每一个结点，计算当前结点作为根节点最大值</span></span><br><span class="line">        <span class="keyword">if</span>(rootnull) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> calMaxValue(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> calMaxValue(root.right);</span><br><span class="line">        left = left&gt;<span class="number">0</span>?left:<span class="number">0</span>;</span><br><span class="line">        right = right&gt;<span class="number">0</span>?right:<span class="number">0</span>;</span><br><span class="line">        maxx = Math.max(maxx,left + right + root.val);</span><br><span class="line"></span><br><span class="line">        maxPathSum(root.left);</span><br><span class="line">        maxPathSum(root.right);</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calThreeMax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(x,y),z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我写的calMaxValue这个递归方法<br>从整体上把握递归，想象calMaxValue为记录左右子树的最大值<br>那么当前单条支路的最大值就是(node.val,node.val+leftMax,node.val+rightMax)中的较大值，一定要从整体的角度思考问题</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210613163013.png" alt="image-20210613163013053" style="zoom:50%;" />



<h2 id="7-常见的题型"><a href="#7-常见的题型" class="headerlink" title="7 常见的题型"></a>7 常见的题型</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p><a href="https://leetcode-cn.com/problems/lru-cache/">https://leetcode-cn.com/problems/lru-cache/</a></p>
<p>为什么用双向链表呢？<br>因为双向链表可以直接获取某个节点的前驱节点！</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210523190933.png" alt="image-20210523190933706" style="zoom:50%;" />

<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210523190758.png" alt="image-20210523190758171"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="comment">//获取和插入的时间复杂度都是o(1)</span></span><br><span class="line">    <span class="comment">// HashMap+双向链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DlistNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        DlistNode pre;</span><br><span class="line">        DlistNode next;</span><br><span class="line"></span><br><span class="line">        DlistNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        DlistNode(<span class="type">int</span> _key, <span class="type">int</span> _val) &#123;</span><br><span class="line">            key = _key;</span><br><span class="line">            val = _val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, DlistNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DlistNode&gt;();</span><br><span class="line">    <span class="comment">// 建立伪头和尾节点</span></span><br><span class="line">    DlistNode tail, head;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = capacity;</span><br><span class="line">        <span class="built_in">this</span>.cnt = <span class="number">0</span>;</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DlistNode</span>();</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DlistNode</span>();</span><br><span class="line">        <span class="comment">// 双向链连接初始化</span></span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DlistNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node  <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 该节点移动到链表的头部</span></span><br><span class="line">        removeNode(node);</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DlistNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node  <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">DlistNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DlistNode</span>(key, value);</span><br><span class="line">            <span class="comment">// cache中建立这个节点的记录</span></span><br><span class="line">            cache.put(key, tmp);</span><br><span class="line">            <span class="comment">// 加入链表的头部</span></span><br><span class="line">            <span class="comment">// 注意这里是把tmp加到链表的头部</span></span><br><span class="line">            moveToHead(tmp);</span><br><span class="line"></span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; size) &#123;</span><br><span class="line">                <span class="type">DlistNode</span> <span class="variable">t</span> <span class="operator">=</span> removeLastNode();</span><br><span class="line">                <span class="comment">// 从cache中删除</span></span><br><span class="line">                cache.remove(t.key);</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该节点移动到链表的头部</span></span><br><span class="line">            removeNode(node);</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="comment">// 更新这个节点的值</span></span><br><span class="line">            node.val = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除双向链表中的某一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DlistNode node)</span> &#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除双向链表的尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> DlistNode <span class="title function_">removeLastNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DlistNode</span> <span class="variable">tmp</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        removeNode(tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个节点移动到头部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DlistNode node)</span> &#123;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="翻转链表和快慢指针找链表中心"><a href="#翻转链表和快慢指针找链表中心" class="headerlink" title="翻转链表和快慢指针找链表中心"></a>翻转链表和快慢指针找链表中心</h3><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode cur)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</span></span><br><span class="line">        <span class="comment">// 其一，find mid node 使用快慢指针找到链表中点。 </span></span><br><span class="line">        <span class="comment">// 其二，reverse 逆序后半部分。 其三，check 从头、中点，开始比较是否相同。</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找链表的中点</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="literal">null</span> &amp;&amp; fast.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到链表的中间结点</span></span><br><span class="line">        <span class="comment">// 反转后半部分链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseList(next);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check从头中点开始比较是否相同</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span> &amp;&amp; cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val!=cur.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口模版"><a href="#滑动窗口模版" class="headerlink" title="滑动窗口模版"></a>滑动窗口模版</h3><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210514213550.png" alt="image-20210514213550069"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 思路，滑动窗口，当窗口不满足的时候，左窗口向右边移动到满足</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = <span class="number">0</span>,maxx = <span class="number">1</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(right&lt;len &amp;&amp; left&lt;=right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="keyword">while</span>(map.containsKey(ch))&#123;</span><br><span class="line">                <span class="comment">// 删除left位置的元素</span></span><br><span class="line">                map.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把这个元素放在map中</span></span><br><span class="line">            map.put(ch,<span class="number">1</span>);</span><br><span class="line">            maxx = Math.max(maxx,right-left+<span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>注意这个最后结果的添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(curnums.length)&#123;</span><br><span class="line">    <span class="comment">//res.add(tmp);</span></span><br><span class="line">    res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(tmp));</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你按照注释那样写的话就会报错！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> cur,<span class="type">int</span>[] vis,ArrayList&lt;Integer&gt; tmp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curnums.length)&#123;</span><br><span class="line">            <span class="comment">//res.add(tmp);</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(tmp));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]<span class="number">0</span>)&#123;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">                dfs(nums,cur+<span class="number">1</span>,vis,tmp);</span><br><span class="line">                tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">                vis[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] vis = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dfs(nums,<span class="number">0</span>,vis,tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="topK频率问题"><a href="#topK频率问题" class="headerlink" title="topK频率问题"></a>topK频率问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// topk高频的元素</span></span><br><span class="line">        <span class="comment">// 你所设计算法的时间复杂度 必须 优于 O(n log n)</span></span><br><span class="line">        <span class="comment">// 维护一个大小是k的小根堆</span></span><br><span class="line">        <span class="comment">// 这里不能采用大根堆，因为大根堆需要压入所有的元素，如果数据量过大，就挂了</span></span><br><span class="line">        <span class="comment">// 小顶堆</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            map.put(x,map.getOrDefault(x,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(map.get(a)-map.get(b)));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(que.size()&lt;k)&#123;</span><br><span class="line">                que.add(x);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> que.peek();</span><br><span class="line">                <span class="keyword">if</span>(map.get(x)&gt;map.get(peek))&#123;</span><br><span class="line">                    <span class="comment">// 去除队列顶最小的元素，把x压入队列</span></span><br><span class="line">                    que.poll();</span><br><span class="line">                    que.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将优先队列的元素返回</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:que)&#123;</span><br><span class="line">            res[cnt++]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用线程池启动三个线程"><a href="#用线程池启动三个线程" class="headerlink" title="用线程池启动三个线程"></a>用线程池启动三个线程</h3><h2 id="8-双端队列"><a href="#8-双端队列" class="headerlink" title="8 双端队列"></a>8 双端队列</h2><p>题目传送门：<a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=117&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=117&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">maxInWindows</span><span class="params">(<span class="type">int</span> [] num, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 维护一个单调栈</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> num.length;</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(size0 || len0 || size&gt;len) <span class="keyword">return</span> al;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; num[dq.getLast()]&lt;num[i])&#123;</span><br><span class="line">                dq.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加入初始最大的第一个元素</span></span><br><span class="line">        al.add(num[dq.getFirst()]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len-size+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 推出过期的元素</span></span><br><span class="line">            <span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; i&gt;dq.getFirst())&#123;</span><br><span class="line">                dq.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 推出比新加入元素小的元素</span></span><br><span class="line">            <span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; num[dq.getLast()]&lt;num[i+size-<span class="number">1</span>])&#123;</span><br><span class="line">                dq.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入尾元素</span></span><br><span class="line">            dq.add(i+size-<span class="number">1</span>);</span><br><span class="line">            al.add(num[dq.getFirst()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> al;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-非递归中序遍历"><a href="#9-非递归中序遍历" class="headerlink" title="9 非递归中序遍历"></a>9 非递归中序遍历</h2><p>传送门：<a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=117&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=117&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    TreeNode <span class="title function_">KthNode</span><span class="params">(TreeNode pRoot, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 非递归实现中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(pRootnull || k0) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(pRoot!=<span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.add(pRoot);</span><br><span class="line">                pRoot = pRoot.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pRoot = stack.pop();</span><br><span class="line">                <span class="comment">// 这样就可以中序存储一个数组了</span></span><br><span class="line">                <span class="comment">// list.add(pRoot)</span></span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span>(cntk)&#123;</span><br><span class="line">                    <span class="keyword">return</span> pRoot;</span><br><span class="line">                &#125;</span><br><span class="line">                pRoot = pRoot.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-滑动窗口模板"><a href="#10-滑动窗口模板" class="headerlink" title="10 滑动窗口模板"></a>10 滑动窗口模板</h2><p>先看东哥写的<a href="https://labuladong.github.io/algo/2/19/26/">https://labuladong.github.io/algo/2/19/26/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findSubArray</span>(<span class="params">nums</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(nums) <span class="comment"># 数组/字符串长度</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 双指针，表示当前遍历的区间[left, right]，闭区间</span></span><br><span class="line">    sums = <span class="number">0</span> <span class="comment"># 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数</span></span><br><span class="line">    res = <span class="number">0</span> <span class="comment"># 保存最大的满足题目要求的 子数组/子串 长度</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; N: <span class="comment"># 当右边的指针没有搜索到 数组/字符串 的结尾</span></span><br><span class="line">        sums += nums[right] <span class="comment"># 增加当前右边指针的数字/字符的求和/计数</span></span><br><span class="line">        <span class="keyword">while</span> 区间[left, right]不符合题意: <span class="comment"># 此时需要一直移动左指针，直至找到一个符合题意的区间</span></span><br><span class="line">            sums -= nums[left] <span class="comment"># 移动左指针前需要从counter中减少left位置字符的求和/计数</span></span><br><span class="line">            left += <span class="number">1</span> <span class="comment"># 真正的移动左指针，注意不能跟上面一行代码写反</span></span><br><span class="line">        <span class="comment"># 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>) <span class="comment"># 需要更新结果</span></span><br><span class="line">        right += <span class="number">1</span> <span class="comment"># 移动右指针，去探索新的区间</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">链接：https://leetcode.cn/problems/<span class="built_in">max</span>-consecutive-ones-iii/solution/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11-多线程循环输出"><a href="#11-多线程循环输出" class="headerlink" title="11 多线程循环输出"></a>11 多线程循环输出</h2><p>面试b站的时候，面试官出的一道题目<br>实战一下线程同步，实现两个方法生成一个水分子H2O，一个方法输出一个O,另一个方法输出一个H,水分子需要由2个H和一个O构成，没写好 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 交替打印 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s1.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">                    s2.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s2.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">                    s3.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s3.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;O&quot;</span>);</span><br><span class="line">                    s1.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题二：两个线程交替打印输出1-100</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>springcloud微服务</title>
    <url>/2020/11/02/note/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="springcloud微服务"><a href="#springcloud微服务" class="headerlink" title="springcloud微服务"></a>springcloud微服务</h1><p>参考教程：<a href="https://www.bilibili.com/video/BV1S5411c7hM?p=13">https://www.bilibili.com/video/BV1S5411c7hM?p=13</a></p>
<h2 id="四种参数传递的方式"><a href="#四种参数传递的方式" class="headerlink" title="四种参数传递的方式"></a>四种参数传递的方式</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image002.png" alt="img"></p>
<p>@ResponseBody：将控制器方法返回值转换成json格式字符串，并响应请求</p>
<p>@RequestBosy：将请求中json格式字符串自动转为java中的对象</p>
<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>​    微服务是一种<strong>架构</strong>，基于单个应用开发出一系列微小的服务，每个服务<strong>基于项目中业务</strong>进行拆分，拆分出来的服务<strong>独立部署，</strong>这些服务基于<strong>分布式管理</strong></p>
<h2 id="为什么是微服务"><a href="#为什么是微服务" class="headerlink" title="为什么是微服务"></a>为什么是微服务</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image004.png" alt="img"></p>
<p>优点：</p>
<p>1 服务专注于自己的职责，服务之间松耦合，避免一个模块的问题导致服务崩溃</p>
<p>2 将服务拆分成单独的小服务，单独部署，高度自治</p>
<p>缺点：服务治理和服务监控是关键</p>
<h2 id="微服务解决方案"><a href="#微服务解决方案" class="headerlink" title="微服务解决方案"></a>微服务解决方案</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image006.png" alt="img"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image008.png" alt="img"></p>
<h2 id="什么是SpringCloud"><a href="#什么是SpringCloud" class="headerlink" title="什么是SpringCloud"></a>什么是SpringCloud</h2><h3 id="官方定义和核心组件"><a href="#官方定义和核心组件" class="headerlink" title="官方定义和核心组件"></a>官方定义和核心组件</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image010.png" alt="img"></p>
<p>springcloud和springboot的对应关系</p>
<p>注意：springcloud和boot的版本号，必须要对应！强制规定了版本必须对应</p>
<p>我们选取的</p>
<p>springcloud的Hoxton</p>
<p>springboot的2.2.5</p>
<p>jdk1.8</p>
<p>maven3.x</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image012.png" alt="img"></p>
<h2 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h2><h4 id="什么是服务注册中心"><a href="#什么是服务注册中心" class="headerlink" title="什么是服务注册中心"></a>什么是服务注册中心</h4><p>​    整个微服务架构中单独抽取出来的一个服务，这个服务不完成项目中任何业务的功能，仅仅在微服务中记录微服务健康状况的检查，让服务元数据信息存储</p>
<p>​    存储所有微服务信息，比如服务名称、IP、端口等等</p>
<h4 id="常用的注册中心"><a href="#常用的注册中心" class="headerlink" title="常用的注册中心"></a>常用的注册中心</h4><p>Eureka</p>
<p>springcloud做了基础springcloud-netflix-eureka，包含两个组件，eureka-server和eureka-client</p>
<p>eureka开发完成后，访问<a href="http://localhost:8761，可以访问可视化界面">http://localhost:8761，可以访问可视化界面</a></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image014.png" alt="img"></p>
<p>服务名称不能有下划线并且推荐使用大写</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image016.png" alt="img"></p>
<p>我们注册一个eureka-client看一下结果</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image018.png" alt="img"></p>
<p>这个client，日后就是一个个我们开发的服务</p>
<p><strong>eureka自我保护机制</strong></p>
<p>​    并不会因为某一次或者某几次心跳没有收到回复就直接移除</p>
<p>​    心跳出现问题的时候，我先不认为你是宕机了，我先认为是网络等原因出现了问题，先不清楚这个服务在eureka中注册的服务列表</p>
<p>​    自我保护机制默认是开启的，在自我保护模式下，eureka将停止移除实例</p>
<p> <strong>那什么时候会清除呢？</strong></p>
<p>1 心跳的次数高于预期的阈值</p>
<p>​    没有开启自我保护机制：如果实在90秒内我们没有接收到微服务实例的心跳。30s可以发送一次心跳请求。15分钟可以按照30s分成很多组</p>
<p>​    自我保护机制：Eureka会在运行期间，15分钟内丢失心跳比例是否在15%以上，如果低于85%，Eureka会把他们保护起来，这些实例不会过期</p>
<p>​    我们可以自己设置参数的值，来减少移除实例的时间</p>
<p><strong>eureka集群搭建</strong></p>
<p>目前我们还是推荐使用eureka1版本</p>
<p><strong><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image020.jpg" alt="img"></strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image022.jpg" alt="img"></p>
<p>Consul</p>
<p> <strong>eureka的问题</strong></p>
<p>1 最新版本停止更新</p>
<p>2 每次我们必须手动开发服务注册中心</p>
<p> <strong>consul简介</strong></p>
<p>​    基于go语言开发的服务注册中心，轻量级的注册中心google</p>
<p>​    相当于开发了一个程序，我们不用自己开发，直接把我们有的微服务注册进去就可以了，我们只需要下载、安装启动即可</p>
<h4 id="不同服务注册中心区别"><a href="#不同服务注册中心区别" class="headerlink" title="不同服务注册中心区别"></a>不同服务注册中心区别</h4><p>后面将nacos的时候会讲</p>
<h2 id="服务之间通信方式"><a href="#服务之间通信方式" class="headerlink" title="服务之间通信方式"></a>服务之间通信方式</h2><h4 id="基于RestTemplate的服务调用"><a href="#基于RestTemplate的服务调用" class="headerlink" title="基于RestTemplate的服务调用"></a>基于RestTemplate的服务调用</h4><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image024.jpg" alt="img"></p>
<p>​    springcloud采用HTTP协议传输数据，用户服务向订单服务发送HTTP 请求，订单服务将结果进行返回；使用http rest方式传输数据</p>
<p>​    RPC采用TCP进行通信，直接使用二进制传输数据；</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image026.png" alt="img"></p>
<p><strong>如何用java代码发起http请求</strong></p>
<p>​    spring框架提供了HttpClient对象，<strong>RestTemplate</strong> <strong>（可以理解为java****代码中的浏览器）</strong>发起一个Http请求</p>
<h4 id="基于Ribbon的服务调用"><a href="#基于Ribbon的服务调用" class="headerlink" title="基于Ribbon的服务调用"></a>基于Ribbon的服务调用</h4><p>​    restTemplate的问题，直接去调用了订单服务，调用的时候指明了IP+端口，如果订单服务是一个集群，我们每次调用的都是同一个服务。没有办法实现请求的负载均衡。此外由于路径是写死的，如果服务提供者路径一变，那么不利于后续处理</p>
<p>​    使用springcloud提供组件Ribbon解决负载均衡调用，用来实现请求调用时的负载均衡。Ribbon是一个负载均衡的客户端组件，但是发送请求还是需要依赖于RestTemplate</p>
<p>  <strong>ribbon的原理</strong></p>
<p>​    用户服务调用订单服务的时候，不再具体指定调用的url:端口，而是告诉ribbon调用服务的名称，ribbon会根据服务名去注册中心找订单列表，然后ribbon会去做一个负载均衡，默认采用轮询的策略</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image028.jpg" alt="img"></p>
<p>ribbon是客户端负载均衡的组件，因为是把订单服务的列表拉取到客户端然后再次进行负载均衡</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image030.png" alt="img"></p>
<p>当然也可以用注解</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image032.png" alt="img"></p>
<p>总结：我们日后就会使用<strong>restTemplate+ribbon的方式实现通信</strong></p>
<h4 id="ribbon负载均衡的策略"><a href="#ribbon负载均衡的策略" class="headerlink" title="ribbon负载均衡的策略"></a>ribbon负载均衡的策略</h4><p>​    通过源码可以知道Ribbon底层<strong>负载均衡策略父接口IRule</strong>，这个父接口有很多负载均衡策略的实现</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image034.jpg" alt="img"></p>
<p>如何修改负载均衡策略</p>
<p>比如用户服务调用订单服务，我们修改用户服务的配置文件</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image036.jpg" alt="img"></p>
<p>总结：</p>
<p>restTemplate+ribbon可以实现服务间通信，但是路径写死，不够灵活</p>
<h4 id="openFeign"><a href="#openFeign" class="headerlink" title="openFeign"></a>openFeign</h4><p>​    springcloud现在还是推荐我们使用openFeign作为通信组件；openFeign和RestTemplate作用一样，都是http客户端。openFegin底层也是用的RestTemplate，经过封装，是得服务间的通信变得更加简单。</p>
<p>​    openFeign底层集成了Ribbon组件，可以实现负载均衡的功能</p>
<p> <strong>openFeign简单</strong></p>
<p>1 使用写一个接口，加一个注解</p>
<p>2 调用服务代码更加简洁</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image038.jpg" alt="img"></p>
<p> openFeign组件的使用</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image040.png" alt="img"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image042.png" alt="img"></p>
<h4 id="参数传递和响应处理"><a href="#参数传递和响应处理" class="headerlink" title="参数传递和响应处理"></a>参数传递和响应处理</h4><h4 id="openFeign默认的超时处理"><a href="#openFeign默认的超时处理" class="headerlink" title="openFeign默认的超时处理"></a>openFeign默认的超时处理</h4><p>​    使用openFeign组件在服务间通信时要求被调用的服务必须在1s内给出响应，如果超出1s，那么openFeign将直接报错</p>
<p>修改openFeign调用一个服务的超时时间</p>
<p>​    比如类别服务调用商品服务，我们可以在类别服务配置：调用openFeign调用商品服务的超时时间</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image044.jpg" alt="img"></p>
<p> 修改openFeign调用所有服务的超时时间</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image046.jpg" alt="img"></p>
<h4 id="openFeign的日志显示"><a href="#openFeign的日志显示" class="headerlink" title="openFeign的日志显示"></a>openFeign的日志显示</h4><p>​    为了更好的方便我们开发过程中调试openFeign的数据传递和响应处理，openFeign在设计的时候添加了日志功能</p>
<h2 id="Hystrix组件的使用"><a href="#Hystrix组件的使用" class="headerlink" title="Hystrix组件的使用"></a>Hystrix组件的使用</h2><h4 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h4><p> <strong>现象</strong>：同一个时刻，所有的微服务都不可用的情况的现象，称之为服务雪崩</p>
<p> <strong>引发</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image048.jpg" alt="img"></p>
<h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><p> 如何解决微服务的雪崩问题</p>
<p>（1）服务熔断&#x3D;&gt;springcloud提供了<strong>hystrix</strong></p>
<p>作用：所有的微服务都需要引入Hystrix组件，相当于是一个监控器，这个组件具有服务熔断的功能</p>
<p>熔断相当于保险丝，有了Hystrix相当于给微服务加上了保险丝</p>
<p>只要发现服务器处理不掉了，就立刻熔断掉，是一种保护机制</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image050.jpg" alt="img"></p>
<p>（2）Hystrix的执行流程</p>
<p>是对调用链路的保护，是解决服务雪崩的重要手段</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image052.png" alt="img"></p>
<h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>（1）定义:当服务压力剧增的时候，根据当前的业务状况以及流量，<strong>对一些服务和页面进行有策略的降级</strong>，以缓解服务器的压力，<strong>保证核心组件的运行</strong>，同时保证大部分用户可以收到响应。</p>
<p>​    比如说双十一期间，我们可以关闭退款这个服务，保证支付下单这几个核心服务的运行</p>
<h4 id="降级和熔断总结"><a href="#降级和熔断总结" class="headerlink" title="降级和熔断总结"></a>降级和熔断总结</h4><p>（1）共同点：目的一致，都是从可靠性的角度考虑，为了防止系统的整体缓慢甚至是崩溃，采用的技术手段</p>
<p>（2）不同点：服务熔断一般是某个服务故障引发，服务降级一般是从整体负荷考虑</p>
<p>​    服务熔断必定会触发降级，所以熔断也是降级的一种，<strong>区别在于熔断是对链路的保护，降级是系统过载的一种保护过程</strong></p>
<h4 id="服务熔断的实现Hystrix"><a href="#服务熔断的实现Hystrix" class="headerlink" title="服务熔断的实现Hystrix"></a>服务熔断的实现Hystrix</h4><p>（1）防雪崩利器sentinel，可以用来替换hystrix</p>
<p>（2）如何在项目中使用Hystrix组件</p>
<p>a 在所有的微服务模块中引入Hystrix依赖</p>
<p>b 在入口类上加上注解</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image054.png" alt="img"></p>
<p>我们还要告诉熔断之后的快速响应处理</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image056.png" alt="img"></p>
<p>我们看一下熔断后的状态</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image058.jpg" alt="img"></p>
<p>​    我们这样处理仅仅是服务端的一个处理，我们还希望openFeign在调用这个服务的时候也能拿到熔断之后的处理结果</p>
<p>​    因为我们openFeign访问的url不是这个url，我们openFeign不会拿到这个结果，而是拿到是个不友好的页面，直接是一个异常页面</p>
<p>​    我们这个仅仅是服务提供方的熔断策略，我们还需要处理服务调用方openFegin一个处理方案</p>
<h4 id="Hystrix和OpenFeign的组合"><a href="#Hystrix和OpenFeign的组合" class="headerlink" title="Hystrix和OpenFeign的组合"></a>Hystrix和OpenFeign的组合</h4><p><strong>1 Hystrix断路器打开的条件</strong></p>
<p>当满足一定的阈值条件（默认10s内20个请求失败）</p>
<p>当失败率到达一定的条件（默认10s内超过50%的请求失败）</p>
<p><strong>2</strong> <strong>触发熔断机制流程</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image060.jpg" alt="img"></p>
<p>整个流程：当Hystrix监控到该服务接口出发1，2两个阈值的时候，会在系统中自动触发断路器，在熔断器打开的过程中，任何访问这个接口的请求都不可用，同时在断路器打开5s后会进入到半开状态，此时允许一个请求到达服务接口。如果请求成功，断路器彻底关闭，如果请求失败，断路器重新打开</p>
<p><strong>3</strong> <strong>实战过程中断路器的调用</strong></p>
<p>有自定义的和默认的两种方案</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image062.jpg" alt="img"></p>
<p>4 openFeign如何和Hystrix集成使用</p>
<p>在我们写openFeign调用对象的接口的时候，给出熔断的处理</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image064.png" alt="img"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image066.png" alt="img"></p>
<p>最后，我们在配置文件开启openFeign支持降级</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image068.png" alt="img"></p>
<p><strong>总结：</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image070.jpg" alt="img"></p>
<h4 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix Dashboard"></a>Hystrix Dashboard</h4><p>作用：hystrix提供了可视化的工具，看到什么时候断路器的开启和关闭</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image072.jpg" alt="img"></p>
<p>hystrix Dashboard需要我们自己编写代码</p>
<p>仪表盘组件不需要注册到中心，它只是一个监控，没有任何业务代码，也可以注册到中心</p>
<p>@EnableDiscoveryClient会自动注册到consul zk nacos</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image074.jpg" alt="img"></p>
<p>@EnableHystrixDashboard可以开启仪表盘应用</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image076.jpg" alt="img"></p>
<p>DashBoard存在一些bug，需要修改一下</p>
<p>DashBoard应该监控被调用的微服务，而不是放在dashboardl类上</p>
<p><strong><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image078.jpg" alt="img"></strong></p>
<h4 id="Hystrix和Hystrix-Board"><a href="#Hystrix和Hystrix-Board" class="headerlink" title="Hystrix和Hystrix Board"></a>Hystrix和Hystrix Board</h4><p>​    Hystrix目前不处于积极开发中，目前处于维护模式；官方也说明<strong>Hystrix1.5.18</strong>目前hystrix已经足够的稳定</p>
<p>​    Springcloud提供了一个替换的组件，resillence4j，用来替换Hystrix，实时自适应系统熔断，但是目前流行度并不高。sentinel，是阿里提供的一个解决方案，被称作为流量卫兵，可以做流量控制，降级策略，我们推荐用sentinel解决服务熔断的问题</p>
<p>​    Hystrix的问题是熔断的规则过于单一，并不是实时的操作</p>
<h4 id="组件的快速回顾"><a href="#组件的快速回顾" class="headerlink" title="组件的快速回顾"></a>组件的快速回顾</h4><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image080.jpg" alt="img"></p>
<h2 id="Gateway组件的使用"><a href="#Gateway组件的使用" class="headerlink" title="Gateway组件的使用"></a>Gateway组件的使用</h2><h4 id="什么是服务网关"><a href="#什么是服务网关" class="headerlink" title="什么是服务网关"></a>什么是服务网关</h4><p>1 统一了微服务的入口，方便对平台众多服务的管控</p>
<p>2 可以实现路由转发，也可以实现负载均衡</p>
<p>3 可以身份认证，响应数据的脱敏，流量和并发控制，基于API调用的计量或者计费</p>
<p><strong><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image082.jpg" alt="img"></strong></p>
<h4 id="服务网管组件"><a href="#服务网管组件" class="headerlink" title="服务网管组件"></a>服务网管组件</h4><p>1 netflix zuul1.x（效率低） zuul2.x</p>
<p>zuul不推荐使用了</p>
<p>2 springcloud gateway组件<strong>（推荐）</strong></p>
<p>动态路由</p>
<p>gateway &#x3D; 路由转发router+请求过滤filter</p>
<h4 id="网关使用"><a href="#网关使用" class="headerlink" title="网关使用"></a>网关使用</h4><p>网关中不能引入springmvc的模型，pom文件中不能引入spring-cloud-starter-web</p>
<p>网关中一定要去掉spring-cloud-starter-web! 因为gateway采用的是webflux</p>
<p><strong>路由</strong></p>
<p><strong><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image084.jpg" alt="img"></strong></p>
<p><strong><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image086.jpg" alt="img"></strong></p>
<h4 id="网关配置细节"><a href="#网关配置细节" class="headerlink" title="网关配置细节"></a>网关配置细节</h4><p>上面的这种写法不能做到负载均衡，只能转发到一个固定的机器</p>
<p>gateway也是借助ribbon实现负载均衡的</p>
<p>uri 必须按照这个规则写：uri: lb:&#x2F;&#x2F;category ，也就是loadbalance，然后去服务注册中心去拉取服务id是category</p>
<p>以后我们就用这种方法实现负载均衡的方式</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image088.jpg" alt="img"></p>
<h4 id="网关的断言和过滤"><a href="#网关的断言和过滤" class="headerlink" title="网关的断言和过滤"></a>网关的断言和过滤</h4><p><strong>1</strong> **断言(predicate)**<strong>和过滤(filter)</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image090.png" alt="img"></p>
<p>断言：当请求到达网关的时候的<strong>前置处理</strong>，满足需求，那么就放行处理</p>
<p>官方提供了很多断言的方法，比如说基于cookie的断言等等，这里没有细看…..</p>
<p><strong>2</strong> <strong>内置的filter</strong></p>
<p><strong>这里没有细看，先跳过了…..</strong></p>
<h2 id="config组件"><a href="#config组件" class="headerlink" title="config组件"></a>config组件</h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>config server组件，统一配置中心</p>
<p><strong>用来实现微服务系统中服务配置统一管理组件netflix config</strong></p>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>​    统一配置中心服务端（集中管理配置文件），统一配置中心客户端client</p>
<p>统一配置中心，管理全局微服务的配置</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image092.jpg" alt="img"></p>
<p>​    这样又产生了问题，每个配置中心之间还要同步。于是我们把配置文件<strong>交给远程仓库进行管理，统一配置中心的功能就是拉取到本地仓库</strong></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image094.jpg" alt="img"></p>
<p>​    如果我们现在修改了新的版本，只需要在github修改好配置，然后让所有的服务重新启动，重新拉取配置就可以了</p>
<h4 id="统一配置中心"><a href="#统一配置中心" class="headerlink" title="统一配置中心"></a>统一配置中心</h4><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image096.jpg" alt="img"></p>
<p>客户端client先导入pom依赖</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image098.png" alt="img"></p>
<p>客户端开启获取config-server，配置远端配置中心server的id</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image100.jpg" alt="img"></p>
<p>我们得指定获取的是哪一个配置文件</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image102.png" alt="img"></p>
<p>我们在config-server端去配置</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image104.png" alt="img"></p>
<p><strong>注册中心的配置不能放在远端的仓库，其他的配置文件可以放在远端仓库！</strong></p>
<p> <strong>坑点</strong></p>
<p>​    如果我们通过远端配置文件，这个配置文件不能命名为application.yaml，我们需要修改配置文件的名字bootstrap.yaml</p>
<p>​    bootstrap代表启动的意思</p>
<p><strong><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image106.png" alt="img"></strong></p>
<p><strong>总结：</strong></p>
<p><strong><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image108.jpg" alt="img"></strong></p>
<h4 id="手动设置刷新"><a href="#手动设置刷新" class="headerlink" title="手动设置刷新"></a>手动设置刷新</h4><p>​    先前我们通过远端配置设置信息，但是一旦配置修改了，我们必须重新启动全部微服务，比较麻烦。</p>
<p>​    springcloud给我们提供了两个解决方案：1 手动配置刷新 2 自动配置刷新</p>
<h2 id="Bus组件"><a href="#Bus组件" class="headerlink" title="Bus组件"></a>Bus组件</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image110.jpg" alt="img"></p>
<p> <strong>SpringCloud Bus</strong></p>
<p>​    利用bus广播特性，当一个状态（配置文件）发生改变时，通知到bus中所有服务节点更新当前状态</p>
<p><strong>自动配置没有细看….</strong></p>
<h2 id="springcloud总结"><a href="#springcloud总结" class="headerlink" title="springcloud总结"></a>springcloud总结</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/clip_image112.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式入门</title>
    <url>/2020/06/11/note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>参考狂神视频：<a href="https://www.bilibili.com/video/BV1mc411h719?p=1">https://www.bilibili.com/video/BV1mc411h719?p=1</a></p>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410102410.png" alt="image-20210410102410457" style="zoom:67%;" />

<p>​		创建性模式主要用来创建对象的<br>​		结构型模式主要是用来从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题</p>
<h2 id="oop七大原则"><a href="#oop七大原则" class="headerlink" title="oop七大原则"></a>oop七大原则</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>子类可以扩展父类的功能,但不能改变父类原有的功能。 里氏代换原则告诉我们,在软件中将一个基类对象替换成它的子类对象,程序将不会产生任何错误和异常。<br>子类中可以增加自己特有的方法，但是子类尽量不要重写父类的方法，而是另写一个方法</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。降低耦合度</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成&#x2F;聚合的方式，而不是使用继承。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>JUC并发编程中讲解了单例模式</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>实现了创建者和调用者的分离<br>详细分类：简单工厂模式、工厂方法模式</p>
<p>核心本质：<br>    实力化对象不使用new，用工厂方法进行代替<br>    将选择实现类，创建对象的统一管理和控制，从而将调用者和我们的实现类解耦</p>
<p>简单方法模式</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410100805.png" alt="image-20210410100805026" style="zoom:67%;" />

<p>简单方法模式并不能做到开闭原则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuildCarFactory</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name.equals(<span class="string">&quot;wuling&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">wuling</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name.equals(<span class="string">&quot;tesla&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tesla</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果此时我们要生产一个奥迪，那么还需要在工厂里面再加入一个分支。这样不满足开闭原子。我们要做到不改变工厂的话，需要采用工厂方法模式<br>我们采用工厂方法模式</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410102008.png" alt="image-20210410102008346" style="zoom:50%;" />

<p>此时每一个车都有一个车工厂，此时扩展不需要修改CarFactory</p>
<p>根据设计原则我们需要使用工厂方法模式，但是简单工厂模式比较简单，我们实际写的时候，很多用简单工厂模式</p>
<p>抽象工厂模式</p>
<p>围绕一个超级工厂创建其他工厂，是用来创建工厂的</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410103311.png" alt="image-20210410103311465"></p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410104325.png" alt="image-20210410104324987" style="zoom:50%;" />

<p>用户想要获取一个对象，就去创建一个对应的工厂（concreteCreator），通过工厂去获取对应的对象</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410141329.png" alt="image-20210410141329396"></p>
<p>比如说现在要多生产一个 笔记本，需要在IProductFactory里面增加一个笔记本product</p>
<p>工厂模式优点：我们不需要关注产品内部是怎么创建的，我们只需要负责从产品工厂里面拿数据就可以了</p>
<p>应用场景：spring中IOC容器创建管理bean对象、反射class对象的newInstance方法</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>提供了一种创建对象的最佳方式<br>主要作用：在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂对象</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410143422.png" alt="image-20210410143422962"></p>
<p>抽象的建造者</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410144018.png" alt="image-20210410144018029"></p>
<p>具体的调用者</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410144202.png" alt="image-20210410144202950" style="zoom:50%;" />

<p>指挥者是核心，负责工程如何构建的</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410144436.png" alt="image-20210410144436633"></p>
<p>现在我们可以创建一个调用程序<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410144826.png" alt="image-20210410144826199"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410144900.png" alt="image-20210410144900417"></p>
<p>如果我们想改变类的调用顺序，只需要去操作指挥者就可以了；如果我们有不同的工人，就可以创建不同的楼</p>
<p>上面就是Builder模式的常规用法，导演类director在builder模式中具有很重要的作用，它可以决定如何去构建产品，控制调用的先后顺序，并向调用者返回完整的产品类</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>之前介绍的都是创造性模式，现在我们介绍的是结构性模式，是为了从程序结构上实现松耦合的</p>
<p>思考笔记本电脑查适配器上网的场景</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410152314.png" alt="image-20210410152314666"></p>
<p>笔记本电脑借助适配器连上网线上网</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410151224.png" alt="image-20210410151224241"></p>
<p>转接器的抽象</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410152115.png" alt="image-20210410152051317"></p>
<p>需要设置一个适配器</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410152518.png" alt="image-20210410152518520"></p>
<p>客户端就是电脑需要上网</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410152635.png" alt="image-20210410152635863"></p>
<p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容的那些类可以在一起工作</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410155012.png" alt="image-20210410155012210"></p>
<p>适配器的优点：<br>可以把多个不同的是配置适配到同一个目标</p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式是将抽象部分和它的实现部分分离，使它们都可以独立的变化。它是一种对象结构型模式，又被称之为接口模式</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410155521.png" alt="image-20210410155521336"></p>
<p>此时多继承耦合度太高，此外联想台式机不符合单一职能的规则</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410160023.png" alt="image-20210410160023586"></p>
<p>我们类型写一个抽象类，品牌写一个抽象类，然后通过一个桥把他们连接起来</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410162148.png" alt="image-20210410162148752" style="zoom:50%;" />

<p>我们可以测试一下</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410162519.png" alt="image-20210410162518991"></p>
<p>思维图</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410163052.png" alt="image-20210410163052606" style="zoom:50%;" />

<p>桥接类似于多继承方案，但是多继承违背了类的单一职责原则，复用性差，桥接模式是比多继承方案更好的解决方法，极大减少了子类的个数，降低了维护的成本</p>
<p>应用场景：Java语言通过Java虚拟机实现了平台的无关性</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410163604.png" alt="image-20210410163604035"></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>参考《Spring》的笔记</p>
<h2 id="IOC的工厂模式"><a href="#IOC的工厂模式" class="headerlink" title="IOC的工厂模式"></a>IOC的工厂模式</h2><h2 id="AOP的代理模式"><a href="#AOP的代理模式" class="headerlink" title="AOP的代理模式"></a>AOP的代理模式</h2><p>参考《Spring》的笔记</p>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>注解和反射</title>
    <url>/2020/06/05/note/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="注解和反射"><a href="#注解和反射" class="headerlink" title="注解和反射"></a>注解和反射</h2><p>参考视频：<a href="https://www.bilibili.com/video/BV1p4411P7V3?p=1&amp;vd_source=ec8158f9c5639641ada55d1a5998f03b">https://www.bilibili.com/video/BV1p4411P7V3?p=1&amp;vd_source=ec8158f9c5639641ada55d1a5998f03b</a></p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解的作用就是负责注解其他注解，Java定义了四个元注解，他们用来对其他注解进行说明<br>@Target：注解使用的范围（注册在类上or方法上or..)<br>@Retention：描述注解的生命周期，什么时候注解有效(source&lt;class&lt;<strong>runtime</strong>)，默认是Runtime<br>@Document：表示是否将我们的注解生成在文档中<br>@Inherited：子类可以继承父类的注解</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>可以使用@Interface自定义注解，自动继承了java.lang.annotation.Annotation接口<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411120303.png" alt="image-20210411120303578"></p>
<p>我们可以通过反射机制读取注解</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>动态语言：是在运行时可以改变结构的语言<br>静态语言：运行时结构不可以发生改变</p>
<p>Java不是动态语言，但是可以称之为准动态语言，可以利用反射机制获取类似动态语言的特性</p>
<h3 id="Java反射机制概述"><a href="#Java反射机制概述" class="headerlink" title="Java反射机制概述"></a>Java反射机制概述</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411153314.png" alt="image-20210411153314338"></p>
<h3 id="理解class类并获取class实例"><a href="#理解class类并获取class实例" class="headerlink" title="理解class类并获取class实例"></a>理解class类并获取class实例</h3><p>Object类中有一个getClass方法，通过这个方法我们就可以获得类的信息。包括类的属性，方法和构造器，类到底实现了哪些接口。对于每一个类而言，JRE都为它保留了一个不变的class类型的对象</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411154551.png" alt="image-20210411154551705"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411154648.png" alt="image-20210411154648291"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411154830.png" alt="image-20210411154830073"></p>
<h3 id="哪些类有class对象"><a href="#哪些类有class对象" class="headerlink" title="哪些类有class对象"></a>哪些类有class对象</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411160029.png" alt="image-20210411160029653"></p>
<p>只要元素类型和维度一样，那么就是同一个class</p>
<h3 id="类加载的内存分析"><a href="#类加载的内存分析" class="headerlink" title="类加载的内存分析"></a>类加载的内存分析</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411160457.png" alt="image-20210411160457914"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411160834.png" alt="image-20210411160833997"></p>
<p>写一个代码做介绍</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411161417.png" alt="image-20210411161417552"></p>
<p>我们看这个代码的流程</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411162145.png" alt="image-20210411162145966"></p>
<p>每个类都拥有唯一的class对象</p>
<p>问：&#x3D;&#x3D;类加载的过程&#x3D;&#x3D;<br>1 根据类的全限定名，读取为二进制的字节流<br>2 在方法区将静态的二进制字节流转换成特定的数据结构<br>3 在堆中生成这个类的class对象，作为访问方法区中类数据的一个入口</p>
<h3 id="分析类的初始化"><a href="#分析类的初始化" class="headerlink" title="分析类的初始化"></a>分析类的初始化</h3><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411164004.png" alt="image-20210411164004042"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411164053.png" alt="image-20210411164053016"></p>
<h3 id="获取类的运行时结构"><a href="#获取类的运行时结构" class="headerlink" title="获取类的运行时结构"></a>获取类的运行时结构</h3><h3 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411165333.png" alt="image-20210411165333241"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411165538.png" alt="image-20210411165538821"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411170115.png" alt="image-20210411170115787"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411170212.png" alt="image-20210411170212936"></p>
<h3 id="性能对比分析"><a href="#性能对比分析" class="headerlink" title="性能对比分析"></a>性能对比分析</h3><p>通过反射调用执行方法速度至少要比直接执行慢10倍以上</p>
<h3 id="获取泛型信息"><a href="#获取泛型信息" class="headerlink" title="获取泛型信息"></a>获取泛型信息</h3><h3 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h3>]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>Spring入门</title>
    <url>/2020/02/02/note/spring%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="Spring入门"><a href="#Spring入门" class="headerlink" title="Spring入门"></a>Spring入门</h2><p>本地代码：&#x2F;Users&#x2F;oldwong&#x2F;Documents&#x2F;CodeHouse&#x2F;IdeaProjects&#x2F;Spring-Study-master</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring是一个轻量级控制反转（IOC） 和面向切面（AOP）的框架</p>
<p>官网： <a href="https://spring.io/projects/spring-framework#overview">https://spring.io/projects/spring-framework#overview</a><br>官方下载： <a href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a><br>GitHub： <a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410195032.png" alt="image-20210410195032376"></p>
<h2 id="IOC理论推导"><a href="#IOC理论推导" class="headerlink" title="IOC理论推导"></a>IOC理论推导</h2><p>​		使用set注入后，我们不需要关注对象的创建了，系统的耦合度大大降低，我们只需要关注业务的实现</p>
<h3 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h3><p>​		IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语言中也有应用，并非 Spirng 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</p>
<p>​		将对象之间的相互依赖关系交给 IOC 容器来管理，并由 IOC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<h2 id="IOC创建对象的方式"><a href="#IOC创建对象的方式" class="headerlink" title="IOC创建对象的方式"></a>IOC创建对象的方式</h2><p>1 使用无参构造创建对象，默认</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hou.service.UserServiceImp&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ref引用spring中已经创建很好的对象--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--value是一个具体的值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userdaomysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2 使用有参构造器进行注入</p>
<p>下标赋值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hou.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hou&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>参数名注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--直接通过参数名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hou.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hou&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总结：在配置文件加载的时候，容器中的对象就已经初始化了</p>
<h2 id="DI（依赖注入）"><a href="#DI（依赖注入）" class="headerlink" title="DI（依赖注入）"></a>DI（依赖注入）</h2><p>IOC容器注入的方式构造器注入和set方法注入</p>
<h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>前面说过了</p>
<h3 id="set方式注入【重点】"><a href="#set方式注入【重点】" class="headerlink" title="set方式注入【重点】"></a>set方式注入【重点】</h3><ul>
<li><p>依赖注入：set注入</p>
<ul>
<li>依赖：bean对象的创建依赖于容器！</li>
<li>注入：bean对象中的所有属性，由容器来注入！</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.Address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xian&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hou&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--数组注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--list--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>eat<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>drink<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>play<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>wangzhe<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>daota<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>lol<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">null</span>&gt;</span><span class="tag">&lt;/<span class="name">null</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--properties--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;infor&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;id&quot;</span>&gt;</span>20200405<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span>&gt;</span>hdk<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h2><p><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;use2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;kun&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;19&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>prototype</strong> : 原型模式，每次请求都会创建一个新的 bean 实例。<br><strong>request</strong> : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。<br><strong>session</strong> : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。<br><strong>global-session</strong>： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。</p>
<p><strong>Portlet</strong>是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</p>
<h2 id="bean的自动装配"><a href="#bean的自动装配" class="headerlink" title="bean的自动装配"></a>bean的自动装配</h2><p>spring会在上下文中自动寻找，并自动给bean装配属性</p>
<p>在Spring中有三种装配方式<br>    1 在xml中显示配置<br>    2 在java中显示配置<br>    3 隐式的自动装配bean</p>
<p>小结：</p>
<p>@Autowired和@Resource的区别</p>
<p>autowired是通过byType匹配<br>resource默认是通过byname方式实现，找不到就通过byType注入</p>
<h2 id="使用JavaConfig方式注解"><a href="#使用JavaConfig方式注解" class="headerlink" title="使用JavaConfig方式注解"></a>使用JavaConfig方式注解</h2><p>我们现在不使用spring的xml配置了<br>JavaConfig是Spring的一个子项目，目前推荐</p>
<p>我们使用JavaConfig配置的时候，不需要再使用配置文件！</p>
<p>import把另外一个配置文件导入，让他们可以同时使用！</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410212331.png" alt="image-20210410212331657"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410212448.png" alt="image-20210410212447971"></p>
<p>这种Java的配置方式，在SpringBoot中随处可见</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>&#x2F;Users&#x2F;oldwong&#x2F;Documents&#x2F;CodeHouse&#x2F;IdeaProjects&#x2F;Spring-Study-master&#x2F;spring-08-proxy</p>
<p>为什么学习代理模式？因为这个就是SpringAOP的底层（无论你面试什么公司，AOP和SpringMVC必问！）</p>
<p>代理者和真实角色需要实现同一个接口，代理者才能帮助真实角色调用</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410214228.png" alt="image-20210410214228406"></p>
<p>代理模式的分类：静态代理、动态代理</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410214937.png" alt="image-20210410214937603"></p>
<p>静态代理优点：</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时，变得更加集中和方便 .</li>
</ul>
<p>缺点 :</p>
<ul>
<li>一个真实角色就有一个代理角色，代码量翻倍～开发效率降低</li>
</ul>
<p>我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>反射的优点是可以动态的加载一些类</p>
<ul>
<li>动态代理的角色和静态代理的一样 .</li>
<li>动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的</li>
<li>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理<ul>
<li>基于接口的动态代理—-JDK动态代理</li>
<li>基于类的动态代理–cglib</li>
<li>现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist</li>
</ul>
</li>
</ul>
<p>需要了解两个类：proxy、InvocationHandler；proxy是作为生成代理类，invoke可以执行代理方法；</p>
<p>我们这里采用的是基于JDK的动态代理，每一个代理实例都会关联一个调用处理程序，当在代理实例调用方法时，会调用执行它的invoke方法</p>
<p>关联的调用程序就是InvocationHandler</p>
<p>参考代码：&#x2F;Users&#x2F;oldwong&#x2F;Documents&#x2F;CodeHouse&#x2F;IdeaProjects&#x2F;Spring-Study-master&#x2F;spring-08-proxy</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210410234017.png" alt="image-20210410234017185"></p>
<p>我们可以进行测试<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411095842.png" alt="image-20210411095842034"></p>
<p>我们可以写一个代理类的通用模版<br><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411100038.png" alt="image-20210411100038311"></p>
<p>动态代理的好处：</p>
<ul>
<li>一个动态代理类代理的是一个接口，一般是对应着一类业务</li>
<li>一个动态代理类可以代理多个类，只要实现了接口就行</li>
</ul>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>​		AOP面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发的一个热点，也是Spring框架中的一个重点内容。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的灵活性，同时提高了程序的开发效率</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411101056.png" alt="image-20210411101056450"></p>
<p>前置通知、后置通知、环绕通知，我们都是可以通过动态代理自己实现的，只是现在spring帮我们完成了这部分的工作</p>
<p>方法一：spring的API接口</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411103842.png" alt="image-20210411103842288"></p>
<p>方法二：使用注解实现AOP</p>
<p>在@Aspect上面再加上一个注解@Component，作为一个bean注入（老师这里是在application.xml中写入的）</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411104355.png" alt="image-20210411104355355"></p>
<h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><ul>
<li>声明式事务：AOP，在配置文件中配置（推荐使用）</li>
<li>编程式事务：需要在代码中进行事务的管理，在代码中硬编码。(不推荐使用)</li>
</ul>
<p>为什么需要事务？</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411105805.png" alt="image-20210411105805684"></p>
<h2 id="IOC的工厂模式"><a href="#IOC的工厂模式" class="headerlink" title="IOC的工厂模式"></a>IOC的工厂模式</h2><h2 id="AOP的代理模式"><a href="#AOP的代理模式" class="headerlink" title="AOP的代理模式"></a>AOP的代理模式</h2><h2 id="AOP在项目中怎么使用的"><a href="#AOP在项目中怎么使用的" class="headerlink" title="AOP在项目中怎么使用的"></a>AOP在项目中怎么使用的</h2><p>可以考虑aop打印日志？操作前和操作后</p>
<h2 id="bean-生命周期"><a href="#bean-生命周期" class="headerlink" title="bean 生命周期"></a>bean 生命周期</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411205745.jpg" alt="preview"></p>
<p>Bean 的生命周期</p>
<p>背诵口诀：实例化，填充属性，name，factory，applicationContext，before-init，init，after-init，调用，destory</p>
<p>1.Spring对Bean进行实例化（相当于程序中的new Xx()）</p>
<p>2.Spring将值和Bean的引用注入进Bean对应的属性中</p>
<p>3.如果Bean实现了BeanNameAware接口，Spring将Bean的ID传递给setBeanName()方法<br><strong>（实现BeanNameAware清主要是为了通过Bean的引用来获得Bean的ID，一般业务中是很少有用到Bean的ID的</strong>）</p>
<p>4.如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanDactory(BeanFactory bf)方法并把BeanFactory容器实例作为参数传入。<br><strong>（实现BeanFactoryAware 主要目的是为了获取Spring容器，如Bean通过Spring容器发布事件等）</strong></p>
<p>5.如果Bean实现了ApplicationContextAware接口，Spring容器将调用setApplicationContext(ApplicationContext ctx)方法，把y应用上下文作为参数传入.<br><strong>(作用与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调用setApplicationContext方法时会把它自己作为setApplicationContext 的参数传入，而Spring容器在调用setBeanDactory前需要程序员自己指定（注入）setBeanDactory里的参数BeanFactory )</strong></p>
<p>6.如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessBeforeInitialization（预初始化）方法<br><strong>（作用是在Bean实例创建成功后对进行增强处理，如对Bean进行修改，增加某个功能）</strong></p>
<p>7.如果Bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet方法，作用与在配置文件中对Bean使用init-method声明初始化的作用一样，都是在Bean的全部属性设置成功后执行的初始化方法。</p>
<p>8.如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessAfterInitialization（后初始化）方法<br><strong>（作用与6的一样，只不过6是在Bean初始化前执行的，而这个是在Bean初始化后执行的，时机不同 )</strong></p>
<p>9.经过以上的工作后，Bean将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁</p>
<p>10.如果Bean实现了DispostbleBean接口，Spring将调用它的destory方法，作用与在配置文件中对Bean使用destory-method属性的作用一样，都是在Bean实例销毁前执行的方法。</p>
<p>参考：Spring实战</p>
<h2 id="如何解决bean的循环依赖"><a href="#如何解决bean的循环依赖" class="headerlink" title="如何解决bean的循环依赖"></a>如何解决bean的循环依赖</h2><p>​		循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411210804.png" alt="img" style="zoom:67%;" />

<p>spring通常有两种DI注入的方式，构造器注入和set注入<br>        在不考虑Bean的初始化方法和一些Spring回调的情况下，Spring首先去调用A对象的构造函数实例化A，然后查找A依赖的对象本例子中是B（合作者）。一但找到合作者，Spring就会调用合作者(B)的构造函数实例化B。如果B还有依赖的对象Spring会把B上依赖的所有对象都按照相同的机制实例化然后调用A对象的setB(B b)把b对象注入给A。<br>        因为Spring调用一个对象的set方法注入前,这个对象必须先被实例化。所以在”使用set方法注入”的情况下Spring会首先调用对象的构造函数。</p>
<img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411211726.png" alt="img" style="zoom:67%;" />

<p>​		如果发现配置了对象的构造注入，那么Spring会在调用构造函数前把构造函数需要的依赖对象都实例化好，然后再把这些实例化后的对象作为参数去调用构造函数。</p>
<p>　　在使用构造函数和set方法依赖注入时，Spring处理对象和对象依赖的对象的顺序时不一样的。一般把一个Bean设计为构造函数接收依赖对象时，其实是表达了这样一种关系：他们（依赖对象）不存在时我也不存在，即“没有他们就没有我”。<br>　　通过<strong>构造函数的注入</strong>方式其实表达了2个对象间的一种<strong>强的聚合关系：组合关系</strong>。</p>
<p>​		通过<strong>set方法注入</strong>的方式表达了2个对象间较<strong>弱的</strong>依赖关系：聚合关系。就像一辆车，如果没有车内音像车也时可以工作的。当你不要求合作者于自己被创建 时，“set方法注入”注入比较合适。</p>
<p>以下是第二个版本的解释</p>
<p>​		关于Spring bean的创建，其本质上还是一个对象的创建，既然是对象，读者朋友一定要明白一点就是，一个完整的对象包含两部分：当前对象实例化和对象属性的实例化。在Spring中，对象的实例化是通过反射实现的，而对象的属性则是在对象实例化之后通过一定的方式设置的。这个过程可以按照如下方式进行理解：</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411211915.jpg" alt="img"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411212401.jpg" alt="img"></p>
<p>到这里，Spring整个解决循环依赖问题的实现思路已经比较清楚了。对于整体过程，读者朋友只要理解两点：</p>
<ul>
<li>Spring是通过递归的方式获取目标bean及其所依赖的bean的；</li>
<li>Spring实例化一个bean的时候，是分两步进行的，首先实例化目标bean，然后为其注入属性。</li>
</ul>
<p>​    结合这两点，也就是说，Spring在实例化一个bean的时候，是首先递归的实例化其所依赖的所有bean，直到某个bean没有依赖其他bean，此时就会将该实例返回，然后反递归的将获取到的bean设置为各个上层bean的属性的。</p>
<p>以下是第三个版本的解释</p>
<p>​		基于构造器的循环依赖，就更不用说了，<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependency-resolution">官方文档</a>都摊牌了，你想让构造器注入支持循环依赖，是不存在的，不如把代码改了。<br>​		那么默认单例的属性注入场景，Spring是如何支持循环依赖的？<br>​		spring是通过缓存机制解决循环依赖的，底层是建立一个singletonObjects的Map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; cacheMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 假装扫描出来的对象</span></span><br><span class="line">        Class[] classes = &#123;A.class, B.class&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Class aClass : classes) &#123;</span><br><span class="line">            getBean(aClass);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check</span></span><br><span class="line">        System.out.println(getBean(B.class).getA()  getBean(A.class));</span><br><span class="line">        System.out.println(getBean(A.class).getB()  getBean(B.class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; beanClass)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 本文用类名小写 简单代替bean的命名规则</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> beanClass.getSimpleName().toLowerCase();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果已经是一个bean，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (cacheMap.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) cacheMap.get(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将对象本身实例化</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> beanClass.getDeclaredConstructor().newInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 放入缓存</span></span><br><span class="line">        cacheMap.put(beanName, object);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把所有字段当成需要注入的bean，创建并注入到当前bean中</span></span><br><span class="line">        Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 获取需要注入字段的class</span></span><br><span class="line">            Class&lt;?&gt; fieldClass = field.getType();</span><br><span class="line">            <span class="type">String</span> <span class="variable">fieldBeanName</span> <span class="operator">=</span> fieldClass.getSimpleName().toLowerCase();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果需要注入的bean，已经在缓存Map中，那么把缓存Map中的值注入到该field即可</span></span><br><span class="line">            <span class="comment">// 如果缓存没有 继续创建</span></span><br><span class="line">            field.set(object, cacheMap.containsKey(fieldBeanName)</span><br><span class="line">                                ? cacheMap.get(fieldBeanName) : getBean(fieldClass));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 属性填充完成，返回</span></span><br><span class="line">        <span class="keyword">return</span> (T) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		先去缓存里找Bean，没有则实例化当前的Bean放到Map，如果有需要依赖当前Bean的，就能从Map取到。</p>
<h2 id="动态代理的两种方式"><a href="#动态代理的两种方式" class="headerlink" title="动态代理的两种方式"></a>动态代理的两种方式</h2><p>​		JDK动态代理：代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理</p>
<p>​		CGLIB动态代理：代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理</p>
<p>​		通过“继承”可以继承父类所有的公开方法，然后可以重写这些方法，在重写时对这些方法增强，这就是cglib的思想。</p>
<p>​		cglib的原理是这样，它生成一个继承B的类型C（代理类），这个代理类持有一个MethodInterceptor，我们setCallback时传入的。 C重写所有B中的方法（方法名一致），然后在C中，构建名叫“CGLIB”+“$父类方法名$”的方法（下面叫cglib方法，所有非private的方法都会被构建），方法体里只有一句话super.方法名()，可以简单的认为保持了对父类方法的一个引用，方便调用。</p>
<p>​		这样的话，C中就有了重写方法、cglib方法、父类方法（不可见），还有一个统一的拦截方法（增强方法intercept）。其中重写方法和cglib方法肯定是有映射关系的。</p>
<p>实现一个业务类</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411214838.png" alt="image-20210411214838240"></p>
<p>自定义MethodInterceptor：</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411214909.png" alt="image-20210411214909534"></p>
<p>生成CGLIB代理对象调用目标方法：</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411214936.png" alt="image-20210411214936765"></p>
<p>运行结果:</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210411214959.png" alt="img"></p>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
  <entry>
    <title>RESTful风格</title>
    <url>/2020/01/02/note/restful%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="RESTful风格"><a href="#RESTful风格" class="headerlink" title="RESTful风格"></a>RESTful风格</h2><p>REST全称是Representational State Transfer，意思是表征状态转移。 </p>
<p>一句话概括，<strong>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</strong></p>
<p>下面我们结合REST原则，围绕资源展开讨论，从资源的定义、获取、表述、关联、状态变迁等角度，列举一些关键概念并加以解释。</p>
<ul>
<li>资源与URI</li>
<li>统一资源接口</li>
<li>资源的表述</li>
<li>资源的链接</li>
<li>状态的转移</li>
</ul>
<h2 id="资源和URI"><a href="#资源和URI" class="headerlink" title="资源和URI"></a>资源和URI</h2><p>任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念</p>
<p>URI既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。URI 的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210819114705.png" alt="image-20210819114705904"></p>
<h2 id="统一资源接口"><a href="#统一资源接口" class="headerlink" title="统一资源接口"></a>统一资源接口</h2><p>RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。</p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210819114538.png" alt="image-20210819114538657"></p>
<h2 id="URL设计"><a href="#URL设计" class="headerlink" title="URL设计"></a>URL设计</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210819115303.png" alt="image-20210819115303927"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210819115340.png" alt="image-20210819115340586"></p>
<p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210819115436.png" alt="image-20210819115436643"></p>
<h2 id="服务器返回的响应"><a href="#服务器返回的响应" class="headerlink" title="服务器返回的响应"></a>服务器返回的响应</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210819115846.png" alt="image-20210819115846567"></p>
<h2 id="如何设计API"><a href="#如何设计API" class="headerlink" title="如何设计API"></a>如何设计API</h2><p><img src="https://typorayuimages.oss-cn-hangzhou.aliyuncs.com/fx/img/20210819135132.png" alt="image-20210819135132712"></p>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
  </entry>
</search>
